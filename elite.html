<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Elite Docking Sequence</title>
<style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }
    
    body {
        background: #000;
        overflow: hidden;
        cursor: none;
    }
    
    #elite-canvas {
        display: block;
        width: 100%;
        height: 100vh;
    }
</style>
</head>
<body>
<canvas id="elite-canvas"></canvas>

<script>
const canvas = document.getElementById('elite-canvas');
const ctx = canvas.getContext('2d');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// Elite green color
const ELITE_GREEN = '#00ff00';
const ELITE_DIM = '#004400';

// Stars
const stars = [];
const NUM_STARS = 200;

for (let i = 0; i < NUM_STARS; i++) {
    stars.push({
        x: Math.random() * 2 - 1,
        y: Math.random() * 2 - 1,
        z: Math.random() * 3 + 0.5
    });
}

// Station rotation
let stationRotation = 0;
let stationApproach = 0;

// 3D projection
function project(x, y, z, scale = 1) {
    const fov = 400;
    const distance = fov / (z + 3);
    return {
        x: canvas.width / 2 + x * distance * scale,
        y: canvas.height / 2 + y * distance * scale,
        scale: distance
    };
}

// Rotate point around axis
function rotateX(point, angle) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    return {
        x: point.x,
        y: point.y * cos - point.z * sin,
        z: point.y * sin + point.z * cos
    };
}

function rotateY(point, angle) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    return {
        x: point.x * cos + point.z * sin,
        y: point.y,
        z: -point.x * sin + point.z * cos
    };
}

function rotateZ(point, angle) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    return {
        x: point.x * cos - point.y * sin,
        y: point.x * sin + point.y * cos,
        z: point.z
    };
}

// Draw starfield
function drawStars() {
    ctx.fillStyle = ELITE_GREEN;
    
    for (let star of stars) {
        // Move stars toward viewer
        star.z -= 0.005;
        if (star.z < 0.1) {
            star.z = 3 + Math.random();
            star.x = Math.random() * 2 - 1;
            star.y = Math.random() * 2 - 1;
        }
        
        const projected = project(star.x, star.y, star.z);
        const size = Math.max(1, 3 - star.z);
        const brightness = Math.min(1, (3 - star.z) / 2);
        
        ctx.globalAlpha = brightness * 0.7;
        ctx.beginPath();
        ctx.arc(projected.x, projected.y, size, 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.globalAlpha = 1;
}

// Create Coriolis station (dodecahedron-like structure)
function createCoriolisStation(size) {
    // Octahedron vertices for the classic Elite look
    const vertices = [
        { x: 0, y: -size, z: 0 },      // Top
        { x: size, y: 0, z: 0 },       // Right
        { x: 0, y: 0, z: size },       // Front
        { x: -size, y: 0, z: 0 },      // Left
        { x: 0, y: 0, z: -size },      // Back
        { x: 0, y: size, z: 0 }        // Bottom
    ];
    
    // Edges connecting vertices
    const edges = [
        [0, 1], [0, 2], [0, 3], [0, 4],  // Top to middle
        [5, 1], [5, 2], [5, 3], [5, 4],  // Bottom to middle
        [1, 2], [2, 3], [3, 4], [4, 1]   // Middle ring
    ];
    
    return { vertices, edges };
}

// Create the docking slot (rotating rectangle on front face)
function createDockingSlot(size, slotRotation) {
    const slotSize = size * 0.3;
    const slotDepth = size * 0.1;
    const z = size * 0.5;  // Position on front face
    
    // Rectangular slot vertices
    let vertices = [
        { x: -slotSize * 0.6, y: -slotSize * 0.3, z: z },
        { x: slotSize * 0.6, y: -slotSize * 0.3, z: z },
        { x: slotSize * 0.6, y: slotSize * 0.3, z: z },
        { x: -slotSize * 0.6, y: slotSize * 0.3, z: z },
        // Inner slot (recessed)
        { x: -slotSize * 0.5, y: -slotSize * 0.25, z: z + slotDepth },
        { x: slotSize * 0.5, y: -slotSize * 0.25, z: z + slotDepth },
        { x: slotSize * 0.5, y: slotSize * 0.25, z: z + slotDepth },
        { x: -slotSize * 0.5, y: slotSize * 0.25, z: z + slotDepth }
    ];
    
    // Rotate slot around Z axis (matches station rotation visible from front)
    vertices = vertices.map(v => rotateZ(v, slotRotation));
    
    const edges = [
        [0, 1], [1, 2], [2, 3], [3, 0],  // Outer rectangle
        [4, 5], [5, 6], [6, 7], [7, 4],  // Inner rectangle
        [0, 4], [1, 5], [2, 6], [3, 7]   // Connecting edges
    ];
    
    return { vertices, edges };
}

// Create additional station detail structures
function createStationDetails(size) {
    const details = [];
    
    // Antenna/communication arrays
    const antennaLength = size * 0.4;
    details.push({
        vertices: [
            { x: 0, y: -size - antennaLength, z: 0 },
            { x: 0, y: -size, z: 0 }
        ],
        edges: [[0, 1]]
    });
    
    // Cross struts on faces
    const strutSize = size * 0.7;
    const faces = [
        { axis: 'xy', z: size * 0.5 },
        { axis: 'xy', z: -size * 0.5 }
    ];
    
    return details;
}

// Draw wireframe structure
function drawWireframe(structure, rotX, rotY, rotZ, zOffset = 0, color = ELITE_GREEN, lineWidth = 1.5) {
    const transformedVertices = structure.vertices.map(v => {
        let point = { ...v };
        point = rotateX(point, rotX);
        point = rotateY(point, rotY);
        point = rotateZ(point, rotZ);
        point.z += zOffset;
        return point;
    });
    
    ctx.strokeStyle = color;
    ctx.lineWidth = lineWidth;
    ctx.shadowBlur = 8;
    ctx.shadowColor = color;
    
    for (let edge of structure.edges) {
        const p1 = project(transformedVertices[edge[0]].x, transformedVertices[edge[0]].y, transformedVertices[edge[0]].z);
        const p2 = project(transformedVertices[edge[1]].x, transformedVertices[edge[1]].y, transformedVertices[edge[1]].z);
        
        // Only draw if in front of camera
        if (transformedVertices[edge[0]].z > -2.5 && transformedVertices[edge[1]].z > -2.5) {
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        }
    }
    
    ctx.shadowBlur = 0;
}

// Draw the Coriolis station
function drawStation() {
    const size = 0.8;
    const station = createCoriolisStation(size);
    
    // Station tilted toward viewer (classic Elite angle)
    const tiltX = 0.3;
    const tiltY = stationRotation;
    const tiltZ = stationRotation * 0.7;
    
    // Pulsing approach effect
    const zOffset = 1 + Math.sin(stationApproach * 0.5) * 0.3;
    
    // Draw main station structure
    drawWireframe(station, tiltX, tiltY, tiltZ, zOffset, ELITE_GREEN, 2);
    
    // Draw docking slot (rotates with station)
    const dockingSlot = createDockingSlot(size, stationRotation);
    drawWireframe(dockingSlot, tiltX, tiltY, tiltZ, zOffset, ELITE_GREEN, 1.5);
    
    // Draw station detail - cross pattern on visible faces
    drawStationCrossPattern(size, tiltX, tiltY, tiltZ, zOffset);
}

// Draw cross pattern detail on station faces
function drawStationCrossPattern(size, rotX, rotY, rotZ, zOffset) {
    const crossSize = size * 0.4;
    
    // Front face cross
    const frontCross = {
        vertices: [
            { x: -crossSize, y: 0, z: size * 0.48 },
            { x: crossSize, y: 0, z: size * 0.48 },
            { x: 0, y: -crossSize, z: size * 0.48 },
            { x: 0, y: crossSize, z: size * 0.48 }
        ],
        edges: [[0, 1], [2, 3]]
    };
    
    drawWireframe(frontCross, rotX, rotY, rotZ, zOffset, ELITE_DIM, 1);
    
    // Side face crosses
    const sideCross = {
        vertices: [
            { x: size * 0.48, y: -crossSize * 0.7, z: 0 },
            { x: size * 0.48, y: crossSize * 0.7, z: 0 },
            { x: size * 0.48, y: 0, z: -crossSize * 0.7 },
            { x: size * 0.48, y: 0, z: crossSize * 0.7 }
        ],
        edges: [[0, 1], [2, 3]]
    };
    
    drawWireframe(sideCross, rotX, rotY, rotZ, zOffset, ELITE_DIM, 1);
}

// Draw scanner/radar display at bottom
function drawScanner() {
    const scannerWidth = 200;
    const scannerHeight = 60;
    const scannerX = canvas.width / 2 - scannerWidth / 2;
    const scannerY = canvas.height - scannerHeight - 30;
    
    ctx.strokeStyle = ELITE_GREEN;
    ctx.lineWidth = 1;
    ctx.shadowBlur = 5;
    ctx.shadowColor = ELITE_GREEN;
    
    // Scanner border
    ctx.beginPath();
    ctx.moveTo(scannerX, scannerY + scannerHeight);
    ctx.lineTo(scannerX + scannerWidth * 0.1, scannerY);
    ctx.lineTo(scannerX + scannerWidth * 0.9, scannerY);
    ctx.lineTo(scannerX + scannerWidth, scannerY + scannerHeight);
    ctx.closePath();
    ctx.stroke();
    
    // Center line
    ctx.beginPath();
    ctx.moveTo(scannerX + scannerWidth / 2, scannerY);
    ctx.lineTo(scannerX + scannerWidth / 2, scannerY + scannerHeight);
    ctx.stroke();
    
    // Horizontal grid lines
    ctx.globalAlpha = 0.3;
    for (let i = 1; i < 4; i++) {
        const y = scannerY + (scannerHeight / 4) * i;
        const shrink = i * 5;
        ctx.beginPath();
        ctx.moveTo(scannerX + shrink, y);
        ctx.lineTo(scannerX + scannerWidth - shrink, y);
        ctx.stroke();
    }
    ctx.globalAlpha = 1;
    
    // Station blip (rotating)
    const blipAngle = stationRotation * 2;
    const blipX = scannerX + scannerWidth / 2 + Math.cos(blipAngle) * 30;
    const blipY = scannerY + scannerHeight / 2 + Math.sin(blipAngle) * 15;
    
    ctx.fillStyle = ELITE_GREEN;
    ctx.beginPath();
    ctx.arc(blipX, blipY, 3, 0, Math.PI * 2);
    ctx.fill();
    
    // Your ship (center)
    ctx.beginPath();
    ctx.arc(scannerX + scannerWidth / 2, scannerY + scannerHeight - 10, 2, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.shadowBlur = 0;
}

// Draw targeting reticle
function drawReticle() {
    const cx = canvas.width / 2;
    const cy = canvas.height / 2;
    
    ctx.strokeStyle = ELITE_GREEN;
    ctx.lineWidth = 1;
    ctx.shadowBlur = 3;
    ctx.shadowColor = ELITE_GREEN;
    ctx.globalAlpha = 0.6;
    
    // Crosshair
    const size = 30;
    const gap = 8;
    
    ctx.beginPath();
    ctx.moveTo(cx - size, cy);
    ctx.lineTo(cx - gap, cy);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(cx + gap, cy);
    ctx.lineTo(cx + size, cy);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(cx, cy - size);
    ctx.lineTo(cx, cy - gap);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(cx, cy + gap);
    ctx.lineTo(cx, cy + size);
    ctx.stroke();
    
    // Outer brackets
    const bracketSize = 80;
    const bracketLength = 20;
    
    // Top-left
    ctx.beginPath();
    ctx.moveTo(cx - bracketSize, cy - bracketSize + bracketLength);
    ctx.lineTo(cx - bracketSize, cy - bracketSize);
    ctx.lineTo(cx - bracketSize + bracketLength, cy - bracketSize);
    ctx.stroke();
    
    // Top-right
    ctx.beginPath();
    ctx.moveTo(cx + bracketSize - bracketLength, cy - bracketSize);
    ctx.lineTo(cx + bracketSize, cy - bracketSize);
    ctx.lineTo(cx + bracketSize, cy - bracketSize + bracketLength);
    ctx.stroke();
    
    // Bottom-left
    ctx.beginPath();
    ctx.moveTo(cx - bracketSize, cy + bracketSize - bracketLength);
    ctx.lineTo(cx - bracketSize, cy + bracketSize);
    ctx.lineTo(cx - bracketSize + bracketLength, cy + bracketSize);
    ctx.stroke();
    
    // Bottom-right
    ctx.beginPath();
    ctx.moveTo(cx + bracketSize - bracketLength, cy + bracketSize);
    ctx.lineTo(cx + bracketSize, cy + bracketSize);
    ctx.lineTo(cx + bracketSize, cy + bracketSize - bracketLength);
    ctx.stroke();
    
    ctx.globalAlpha = 1;
    ctx.shadowBlur = 0;
}

// Draw speed/fuel bars (Elite style)
function drawStatusBars() {
    const barWidth = 100;
    const barHeight = 8;
    const startX = 30;
    const startY = canvas.height - 100;
    
    ctx.font = '10px monospace';
    ctx.fillStyle = ELITE_GREEN;
    ctx.shadowBlur = 3;
    ctx.shadowColor = ELITE_GREEN;
    
    // Speed indicator
    ctx.fillText('SP', startX, startY);
    ctx.strokeStyle = ELITE_GREEN;
    ctx.lineWidth = 1;
    ctx.strokeRect(startX + 20, startY - 8, barWidth, barHeight);
    
    const speed = 0.3 + Math.sin(stationApproach * 0.3) * 0.1;
    ctx.fillRect(startX + 20, startY - 8, barWidth * speed, barHeight);
    
    // Fuel indicator
    ctx.fillText('FU', startX, startY + 20);
    ctx.strokeRect(startX + 20, startY + 12, barWidth, barHeight);
    ctx.fillRect(startX + 20, startY + 12, barWidth * 0.7, barHeight);
    
    // Cabin temperature
    ctx.fillText('CT', startX, startY + 40);
    ctx.strokeRect(startX + 20, startY + 32, barWidth, barHeight);
    ctx.fillRect(startX + 20, startY + 32, barWidth * 0.2, barHeight);
    
    // Laser temperature
    ctx.fillText('LT', startX, startY + 60);
    ctx.strokeRect(startX + 20, startY + 52, barWidth, barHeight);
    ctx.fillRect(startX + 20, startY + 52, barWidth * 0.1, barHeight);
    
    ctx.shadowBlur = 0;
}

// Draw altitude indicator
function drawAltitude() {
    const x = canvas.width - 130;
    const y = canvas.height - 100;
    const barWidth = 100;
    const barHeight = 8;
    
    ctx.font = '10px monospace';
    ctx.fillStyle = ELITE_GREEN;
    ctx.shadowBlur = 3;
    ctx.shadowColor = ELITE_GREEN;
    
    ctx.fillText('AL', x, y);
    ctx.strokeStyle = ELITE_GREEN;
    ctx.lineWidth = 1;
    ctx.strokeRect(x + 20, y - 8, barWidth, barHeight);
    
    const altitude = 0.5 + Math.sin(stationApproach * 0.2) * 0.2;
    ctx.fillRect(x + 20, y - 8, barWidth * altitude, barHeight);
    
    // Shields
    ctx.fillText('FS', x, y + 20);
    ctx.strokeRect(x + 20, y + 12, barWidth, barHeight);
    ctx.fillRect(x + 20, y + 12, barWidth * 0.9, barHeight);
    
    ctx.fillText('AS', x, y + 40);
    ctx.strokeRect(x + 20, y + 32, barWidth, barHeight);
    ctx.fillRect(x + 20, y + 32, barWidth * 0.85, barHeight);
    
    // Energy banks
    ctx.fillText('EN', x, y + 60);
    ctx.strokeRect(x + 20, y + 52, barWidth, barHeight);
    ctx.fillRect(x + 20, y + 52, barWidth * 0.95, barHeight);
    
    ctx.shadowBlur = 0;
}

// Draw compass
function drawCompass() {
    const cx = canvas.width - 60;
    const cy = 60;
    const radius = 30;
    
    ctx.strokeStyle = ELITE_GREEN;
    ctx.lineWidth = 1;
    ctx.shadowBlur = 5;
    ctx.shadowColor = ELITE_GREEN;
    
    // Circle
    ctx.beginPath();
    ctx.arc(cx, cy, radius, 0, Math.PI * 2);
    ctx.stroke();
    
    // Station direction indicator
    const angle = stationRotation;
    const dotX = cx + Math.cos(angle) * (radius * 0.6);
    const dotY = cy + Math.sin(angle) * (radius * 0.6);
    
    ctx.fillStyle = ELITE_GREEN;
    ctx.beginPath();
    ctx.arc(dotX, dotY, 4, 0, Math.PI * 2);
    ctx.fill();
    
    // Center dot
    ctx.beginPath();
    ctx.arc(cx, cy, 2, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.shadowBlur = 0;
}

// Draw "DOCKING COMPUTER" text when active
function drawDockingText() {
    ctx.font = '14px monospace';
    ctx.fillStyle = ELITE_GREEN;
    ctx.shadowBlur = 5;
    ctx.shadowColor = ELITE_GREEN;
    ctx.textAlign = 'center';
    
    const blink = Math.sin(stationApproach * 3) > 0;
    if (blink) {
        ctx.fillText('DOCKING COMPUTER ACTIVE', canvas.width / 2, 40);
    }
    
    ctx.textAlign = 'left';
    ctx.shadowBlur = 0;
}

// Main animation loop
function animate() {
    // Clear to black
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw elements
    drawStars();
    drawStation();
    drawReticle();
    drawScanner();
    drawStatusBars();
    drawAltitude();
    drawCompass();
    drawDockingText();
    
    // Update rotation
    stationRotation += 0.008;
    stationApproach += 0.02;
    
    requestAnimationFrame(animate);
}

// Handle resize
window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
});

// Start
animate();
</script>
</body>
</html>
