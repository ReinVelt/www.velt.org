            <button class="arcade-button" onclick="addTestDice()" style="font-size: 10px;">üè¢ TEST WAREHOUSE</button>
<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WARGAME - Elite Action Strategy</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #00ff00;
            overflow: hidden;
            height: 100vh;
        }

        #gameCanvas {
            display: block;
            background: linear-gradient(180deg, #000011, #000033, #000011);
        }

        /* UI Overlay */
        .ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .ui-panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ff00;
            border-radius: 10px;
            padding: 10px;
            font-size: 14px;
            pointer-events: auto;
            backdrop-filter: blur(5px);
        }

        .title-panel {
            top: 10px;
            left: 10px;
            width: 250px;
            z-index: 110;
        }

        .score-panel {
            top: 120px;
            left: 10px;
            width: 200px;
        }

        .phase-panel {
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            text-align: center;
        }

        .enemies-panel {
            top: 10px;
            right: 220px;
            width: 150px;
            text-align: center;
        }
        
        .dice-display-panel {
            top: 10px;
            right: 10px;
            width: 200px;
            min-height: 80px;
        }
        
        .dice-display-container {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            min-height: 40px;
            align-items: flex-start;
        }
        
        .dice-display-item {
            width: 30px;
            height: 30px;
            background: linear-gradient(45deg, #ffff00, #ffaa00);
            border: 2px solid #fff;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #000;
            font-size: 14px;
            box-shadow: 0 0 10px #ffff0066;
            animation: diceCollected 0.5s ease-out;
        }
        
        .dice-display-item.used {
            background: linear-gradient(45deg, #666, #333);
            color: #999;
            opacity: 0.6;
        }
        
        @keyframes diceCollected {
            0% {
                transform: scale(0) rotate(180deg);
                opacity: 0;
            }
            50% {
                transform: scale(1.2) rotate(90deg);
            }
            100% {
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
        }
        
        @keyframes diceNotification {
            0% {
                transform: translate(-50%, -50%) scale(0) rotate(180deg);
                opacity: 0;
            }
            30% {
                transform: translate(-50%, -50%) scale(1.3) rotate(0deg);
                opacity: 1;
            }
            70% {
                transform: translate(-50%, -50%) scale(1.1) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -100%) scale(0.8) rotate(0deg);
                opacity: 0;
            }
        }
        
        .no-dice-message {
            color: #666;
            font-size: 10px;
            text-align: center;
            width: 100%;
            padding: 10px 0;
        }

        .controls-panel {
            bottom: 60px; /* Moved up to avoid ground overlap */
            right: 10px;
            width: 200px;
        }

        .dice-selection-panel {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            max-height: 400px;
            display: none;
            text-align: center;
            border-color: #ffff00 !important;
        }

        .inventory-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 600px;
            max-height: 500px;
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #ffff00;
            border-radius: 15px;
            padding: 20px;
            display: none;
            z-index: 200;
            backdrop-filter: blur(10px);
            pointer-events: auto;
        }

        .inventory-header {
            font-size: 20px;
            color: #ffff00;
            margin-bottom: 15px;
            text-shadow: 0 0 10px #ffff00;
        }

        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-bottom: 20px;
            max-height: 200px;
            overflow-y: auto;
        }

        .inventory-dice {
            width: 80px;
            height: 80px;
            background: linear-gradient(45deg, #333, #555);
            border: 3px solid #666;
            border-radius: 12px;
            font-size: 20px;
            font-weight: bold;
            color: #ccc;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            pointer-events: auto;
            z-index: 10;
        }

        .inventory-dice .dice-icon {
            font-size: 24px;
            margin-bottom: 2px;
        }

        .inventory-dice .dice-value {
            font-size: 10px;
            color: #ffffff;
            text-shadow: 1px 1px 2px #000000;
        }

        .inventory-dice.available {
            border-color: #ffffff;
            color: #000;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        }

        .inventory-dice.selected {
            border-color: #ffff00;
            box-shadow: 0 0 20px #00ff00;
            transform: scale(1.05);
        }

        /* Material-specific styles */
        .inventory-dice.material-aluminium {
            background: linear-gradient(45deg, #c0c0c0, #808080);
        }

        .inventory-dice.material-steel {
            background: linear-gradient(45deg, #708090, #404040);
        }

        .inventory-dice.material-chips {
            background: linear-gradient(45deg, #00ff00, #008800);
        }

        .inventory-dice.material-copper {
            background: linear-gradient(45deg, #ff8844, #cc5500);
        }

        .inventory-dice.material-gold {
            background: linear-gradient(45deg, #ffd700, #ffaa00);
        }

        .inventory-dice.material-worm {
            background: linear-gradient(45deg, #ff00ff, #aa00aa);
        }

        .inventory-dice.used {
            background: linear-gradient(45deg, #666, #333);
            border-color: #999;
            color: #666;
            cursor: not-allowed;
        }

        .inventory-dice.used-symbol {
            background: linear-gradient(45deg, #aa5500, #663300);
            border-color: #cc6600;
            color: #ffaa66;
            cursor: not-allowed;
            opacity: 0.6;
            position: relative;
        }

        .inventory-dice.used-symbol::after {
            content: "‚úó";
            position: absolute;
            top: -5px;
            right: -5px;
            background: #ff0000;
            color: #fff;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
        }

        .inventory-dice:hover:not(.used):not(.used-symbol) {
            transform: scale(1.1);
            box-shadow: 0 0 25px currentColor;
        }

        .dice-symbol-group {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 20px;
            height: 20px;
            background: #ff00ff;
            border-radius: 50%;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
        }

        .inventory-summary {
            background: rgba(0, 50, 0, 0.8);
            border: 2px solid #00ff00;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            text-align: left;
        }

        .summary-line {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 14px;
        }

        .inventory-buttons {
        display: flex;
        justify-content: center;
        }

        .inventory-button {
            padding: 12px 20px;
            background: linear-gradient(45deg, #ff00ff, #aa00aa);
            border: 2px solid #ffffff;
            color: #ffffff;
            font-family: inherit;
            font-weight: bold;
            text-transform: uppercase;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s ease;
            font-size: 14px;
        }

        .inventory-button:hover {
            background: linear-gradient(45deg, #ffffff, #ffff00);
            color: #000;
            box-shadow: 0 0 15px #ffff00;
        }

        .inventory-button:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
            box-shadow: none;
        }

        .inventory-button.confirm {
            background: linear-gradient(45deg, #00ff00, #00aa00);
        }

        .inventory-button.end-turn {
            background: linear-gradient(45deg, #ff4444, #aa0000);
        }

        .status-panel {
            top: 80px; /* Moved to top area, below title */
            left: 280px; /* Right of the title panel */
            right: 10px; /* Full width across top */
            height: 40px; /* Slightly smaller */
            display: flex;
            align-items: center;
            overflow: hidden;
            z-index: 105; /* Above other elements */
        }

        .neon {
            text-shadow: 
                0 0 5px currentColor,
                0 0 10px currentColor,
                0 0 15px #ff00ff;
        }

        .arcade-button {
            display: block;
            width: 100%;
            margin: 5px 0;
            padding: 8px 12px;
            background: linear-gradient(45deg, #ff00ff, #aa00aa);
            border: 2px solid #ffffff;
            color: #ffffff;
            font-family: inherit;
            font-weight: bold;
            text-transform: uppercase;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.2s ease;
            font-size: 12px;
        }

        .arcade-button:hover {
            background: linear-gradient(45deg, #ffffff, #ffff00);
            color: #000;
            box-shadow: 0 0 15px #ffff00;
        }

        .arcade-button:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
        }

        .dice-button {
            display: inline-block;
            width: 60px;
            height: 60px;
            margin: 5px;
            background: linear-gradient(45deg, #ffff00, #ff8800);
            border: 3px solid #ffffff;
            border-radius: 10px;
            font-size: 24px;
            font-weight: bold;
            color: #000;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .dice-button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px #ffff00;
        }

        .dice-button.selected {
            background: linear-gradient(45deg, #00ff00, #00aa00);
            border-color: #ffff00;
        }

        .score-value {
            color: #ffff00;
            font-size: 16px;
            font-weight: bold;
            margin: 5px 0;
        }

        .status-text {
            color: #00ffff;
            font-size: 14px; /* Slightly larger for top position */
            text-transform: uppercase;
            animation: textScroll 20s linear infinite; /* Slower for wider area */
            white-space: nowrap;
        }

        @keyframes textScroll {
            0% { transform: translateX(100%); }
            100% { transform: translateX(-100%); }
        }

        .game-title {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(90deg, #ff00ff, #00ffff, #ff00ff);
            padding: 5px 0;
            text-align: center;
            z-index: 101;
            pointer-events: none;
            height: 35px;
        }

        .title-text {
            font-size: clamp(12px, 2.5vw, 18px);
            font-weight: bold;
            color: #000;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #gameCanvas {
            margin-top: 35px;
            height: calc(100vh - 35px);
        }

        .sound-indicator {
            position: fixed;
            top: 45px;
            right: 220px;
            color: #00ff00;
            font-size: 20px;
            z-index: 1001;
            cursor: pointer;
            pointer-events: auto;
        }

        .phase-shooting { border-color: #ff0000 !important; color: #ff0000 !important; }
        .phase-selecting { border-color: #ffff00 !important; color: #ffff00 !important; }
        .phase-game { border-color: #00ff00 !important; color: #00ff00 !important; }
    </style>
</head>
<body>
    <!-- Game Title -->
    <div class="game-title">
        <h1 class="title-text">‚öîÔ∏è WARGAME ‚öîÔ∏è</h1>
    </div>

    <!-- 2D Canvas -->
    <canvas id="gameCanvas"></canvas>

    <!-- UI Overlay -->
    <div class="ui-overlay">
        <!-- Sound Indicator -->
        <div class="sound-indicator" id="soundToggle" onclick="toggleSound()">üîä</div>

        <!-- Game Title -->
        <div class="ui-panel title-panel">
            <div class="neon title" style="font-size: 20px; color: #00ff00; margin-bottom: 10px;">‚öîÔ∏è WARGAME ‚öîÔ∏è</div>
            <div style="font-size: 11px; color: #ffff00; text-align: center; line-height: 1.3;">
                <div>üåç DEFEND THE BASE! üö®</div>
                <div>Enemy drones carry strategic materials:</div>
                <div>ü•á Gold ‚Ä¢ üîß Copper ‚Ä¢ ÔøΩ Steel ‚Ä¢ üñ•Ô∏è Chips ‚Ä¢ üêõ Worms</div>
                <div>Intercept & trade for defense upgrades!</div>
            </div>
        </div>

        <!-- Score Panel -->
        <div class="ui-panel score-panel">
            <div class="neon" style="color: #00ffff; font-size: 12px; margin-bottom: 5px;">SPELER</div>
            <div class="score-value neon" id="playerScore">0 üêõ</div>
            <div class="neon" style="color: #00ffff; font-size: 12px; margin: 10px 0 5px;">TOTAAL SCORE</div>
            <div class="score-value neon" id="totalScore">0</div>
            <div class="neon" style="color: #00ffff; font-size: 12px; margin: 10px 0 5px;">BEURT SCORE</div>
            <div class="score-value" id="turnScore">0</div>
            <div class="neon" style="color: #ffff00; font-size: 12px; margin: 10px 0 5px;">üí∞ MONEY</div>
            <div class="score-value neon" style="color: #ffff00;" id="moneyCounter">$0</div>
            <div class="neon" style="color: #00ffff; font-size: 12px; margin: 10px 0 5px;">üíª HACKED üöÄ</div>
            <div class="score-value neon" style="color: #00ffff;" id="missileCounter">0</div>
        </div>

        <!-- Collected Dice Display -->
        <div class="ui-panel dice-display-panel">
            <div class="neon" style="color: #ffff00; font-size: 12px; margin-bottom: 5px;">VERZAMELDE DOBBELSTENEN</div>
            <div class="dice-display-container" id="diceDisplayContainer">
                <div class="no-dice-message" id="noDiceMessage">Nog geen dobbelstenen</div>
            </div>
        </div>

        <!-- Phase Panel -->
        <div class="ui-panel phase-panel phase-shooting" id="phasePanel">
            <div class="neon" style="font-size: 16px; margin-bottom: 5px;" id="phaseTitle">INTERCEPT DRONES!</div>
            <div style="font-size: 12px;" id="phaseInstructions">Defend base with ‚Üê ‚Üí movement, SPACE to fire!</div>
        </div>

        <!-- Enemies Panel -->
        <div class="ui-panel enemies-panel">
            <div class="neon" style="color: #ff00ff; font-size: 12px; margin-bottom: 5px;">DRONES/ROCKETS</div>
            <div class="score-value neon" style="color: #ff00ff;" id="enemiesLeft">8</div>
            <div class="neon" style="color: #ff00ff; font-size: 12px; margin: 10px 0 5px;">WAREHOUSE</div>
            <div class="score-value neon" style="color: #ffff00;" id="diceCollected">0</div>
        </div>

        <!-- Inventory Dialog -->
        <div class="inventory-dialog" id="inventoryDialog">
            <div class="inventory-header">
                ÔøΩÔ∏è INTERCEPTED CARGO ÔøΩÔ∏è
            </div>
            
            <div class="inventory-summary" id="inventorySummary">
                <div class="summary-line">
                    <span>Huidige Score:</span>
                    <span id="currentTurnScore">0</span>
                </div>
                <div class="summary-line">
                    <span>Heeft Regenworm:</span>
                    <span id="hasWormIndicator">‚ùå</span>
                </div>
                <div class="summary-line">
                    <span>Geselecteerde Groepen:</span>
                    <span id="selectedGroupsText">Geen</span>
                </div>
            </div>
            
            <div style="font-size: 14px; margin-bottom: 10px; color: #ffff00;">
                Klik op dobbelstenen om ze te selecteren (moet ALLE van hetzelfde symbool nemen!)
            </div>
            
            <div class="inventory-grid" id="inventoryGrid">
                <!-- Dice will be populated here -->
            </div>
            
            <div class="inventory-buttons">
                <button class="inventory-button confirm" id="confirmButton" onclick="confirmDiceSelection()" disabled>
                    ‚úì TRADE MATERIALS & CONTINUE
                </button>
                <button class="inventory-button end-turn" id="endTurnButton" onclick="endTurnFromInventory()" disabled>
                    ‚èπÔ∏è SECURE WAREHOUSE
                </button>
                <button class="inventory-button skip-round" id="skipRoundButton" onclick="skipRoundNoWorm()" style="background-color: #666; display: none;">
                    ‚è≠Ô∏è SKIP ROUND (NO WORM)
                </button>
            </div>
        </div>

        <!-- Controls Panel -->
        <div class="ui-panel controls-panel">
            <div style="font-size: 11px; margin-bottom: 10px; color: #00ffff;">BESTURING:</div>
            <div style="font-size: 10px; margin-bottom: 5px;">‚Üê ‚Üí Beweging</div>
            <div style="font-size: 10px; margin-bottom: 10px;">SPATIE Schieten</div>
            <button class="arcade-button" onclick="newGame()">üîÑ NIEUW SPEL</button>
            <button class="arcade-button" onclick="showInventoryDialog()" id="inventoryBtn">üì¶ WAREHOUSE (<span id="diceCount">0</span>)</button>
            <button class="arcade-button" onclick="addTestDice()" style="font-size: 10px;">ÔøΩ TEST CARGO</button>
        </div>

        <!-- Status Panel -->
        <div class="ui-panel status-panel">
            <div class="status-text" id="gameStatus">
                WELCOME TO WARGAME! ‚òÖ DEFEND THE BASE AND COLLECT STRATEGIC MATERIALS! ‚òÖ
            </div>
        </div>
    </div>

    <script>
        // Game Variables
        let canvas, ctx;
        let animationId;
        let keys = {};
        
        // Game Objects
        let tank, bullets, enemies, explosions, stars, dice, particles, civilians, fireBrigade, constructionSites;
        let upgradeSystem;
        
        // Game State
        let gameState = {
            phase: 'shooting', // 'shooting', 'selecting', 'game'
            tiles: [],
            playerStack: [],
            computerStack: [],
            selectedDice: [],
            availableDice: [],
            allTurnDice: [], // All dice collected this turn (including used ones)
            selectedGroups: [],
            usedSymbols: [],
            turnScore: 0,
            hasWorm: false,
            // Defense upgrade system
            defensePoints: 0, // Points earned from picomino game
            totalPointsEarned: 0,
            money: 0, // Money from intercepted cargo
            convertedMissiles: [], // Missiles hacked and converted by hackers
            currentPlayer: 'human',
            gameOver: false,
            soundEnabled: true,
            enemiesNeeded: 8,
            enemiesKilled: 0,
            diceCollected: 0
        };

        // Material system functions
        function getMaterialDisplay(value) {
            switch(value) {
                case 1: return 'üî©Al'; // Aluminium
                case 2: return 'üõ†Ô∏èSt'; // Steel  
                case 3: return 'üíæCh'; // Chips
                case 4: return '‚ö°Cu'; // Copper
                case 5: return 'üèÜAu'; // Gold
                case 'worm': return 'üêõ'; // Worm
                default: return value;
            }
        }
        
        function getMaterialName(value) {
            switch(value) {
                case 1: return 'Aluminium';
                case 2: return 'Steel';
                case 3: return 'Chips';
                case 4: return 'Copper';
                case 5: return 'Gold';
                case 'worm': return 'Worm';
                default: return value;
            }
        }

        function getMaterialValue(value) {
            switch(value) {
                case 1: return 100;  // Aluminium
                case 2: return 150;  // Steel
                case 3: return 300;  // Chips
                case 4: return 250;  // Copper
                case 5: return 500;  // Gold
                case 'worm': return 1000; // Worm
                default: return 0;
            }
        }

        function getMaterialClass(value) {
            switch(value) {
                case 1: return 'material-aluminium';
                case 2: return 'material-steel';
                case 3: return 'material-chips';
                case 4: return 'material-copper';
                case 5: return 'material-gold';
                case 'worm': return 'material-worm';
                default: return '';
            }
        }

        // Background Scenery System (Static Elements)
        class BackgroundElement {
            constructor(type, x, size, distance) {
                this.type = type; // 'hill', 'forest', 'city'
                this.x = x;
                this.size = size;
                this.distance = distance; // 1.0 = foreground, 0.1 = far background
                this.baseY = canvas.height - 250; // Ground level (raised for subway visibility)
                this.color = this.getColor();
                this.height = this.getHeight();
                this.rendered = false; // Flag to prevent re-rendering
                this.canvas = null; // Pre-rendered canvas
                this.initializePreRender();
            }
            
            initializePreRender() {
                // Create off-screen canvas for this element
                this.canvas = document.createElement('canvas');
                this.canvas.width = Math.max(this.getWidth(), canvas.width + 100); // Ensure full coverage
                this.canvas.height = this.height + 100;
                this.ctx = this.canvas.getContext('2d');
                this.preRender();
            }
            
            getWidth() {
                switch(this.type) {
                    case 'hill':
                        return 100 + this.size * 100;
                    case 'forest':
                        return 80 + this.size * 60;
                    case 'village':
                        return 60 + this.size * 40; // Smaller than cities
                    default:
                        return 100;
                }
            }
            
            getColor() {
                const alpha = 0.2 + (this.distance * 0.4); // Darker, more atmospheric
                switch(this.type) {
                    case 'hill':
                        return `rgba(20, 60, 20, ${alpha})`; // Much darker green
                    case 'forest':
                        return `rgba(10, 40, 10, ${alpha})`; // Very dark green
                    case 'village':
                        return `rgba(40, 30, 20, ${alpha})`; // Dark brown for village
                    default:
                        return `rgba(60, 60, 60, ${alpha})`;
                }
            }
            
            getHeight() {
                switch(this.type) {
                    case 'hill':
                        return 60 + this.size * 40;
                    case 'forest':
                        return 30 + this.size * 20;
                    case 'village':
                        return 25 + this.size * 20; // Lower than cities
                    default:
                        return 50;
                }
            }
            
            preRender() {
                this.ctx.save();
                this.ctx.globalAlpha = 0.6 + (this.distance * 0.4);
                
                switch(this.type) {
                    case 'hill':
                        this.preRenderHill();
                        break;
                    case 'forest':
                        this.preRenderForest();
                        break;
                    case 'village':
                        this.preRenderVillage();
                        break;
                }
                
                this.ctx.restore();
                this.rendered = true;
            }
            
            render() {
                if (this.rendered && this.canvas) {
                    // Simply blit the pre-rendered canvas - adjust for wider canvas
                    const offsetX = this.x - (this.canvas.width - this.getWidth()) / 2;
                    ctx.drawImage(this.canvas, offsetX, this.baseY - this.height - 50);
                }
            }
            
            preRenderHill() {
                const width = this.canvas.width;
                const centerX = 0; // Start from left edge
                const centerY = this.height + 50;
                
                this.ctx.fillStyle = this.color;
                
                // Create seamless hill silhouette across full width
                this.ctx.beginPath();
                this.ctx.moveTo(0, centerY);
                
                // Generate smooth continuous curve
                const segments = 20; // More segments for smoother curves
                const points = [];
                
                for (let i = 0; i <= segments; i++) {
                    const x = (i * width) / segments;
                    const normalizedX = i / segments; // 0 to 1
                    
                    // Create rolling background hills with multiple sine waves
                    const heightVariation = 
                        Math.sin(normalizedX * Math.PI * 2 + this.x * 0.01) * 12 +    // Main hills
                        Math.sin(normalizedX * Math.PI * 5 + this.x * 0.02) * 6 +     // Medium details
                        Math.sin(normalizedX * Math.PI * 12 + this.x * 0.03) * 3;     // Fine details
                    
                    const y = centerY - this.height + heightVariation;
                    points.push({x, y});
                }
                
                // Draw smooth curve through all points
                this.ctx.lineTo(points[0].x, points[0].y);
                
                for (let i = 1; i < points.length - 1; i++) {
                    const currentPoint = points[i];
                    const nextPoint = points[i + 1];
                    
                    // Use quadratic curves for smooth transitions
                    const controlX = currentPoint.x + (nextPoint.x - currentPoint.x) * 0.5;
                    const controlY = currentPoint.y;
                    
                    this.ctx.quadraticCurveTo(controlX, controlY, nextPoint.x, nextPoint.y);
                }
                
                // Close the hill shape
                this.ctx.lineTo(width, centerY);
                this.ctx.lineTo(0, centerY);
                this.ctx.closePath();
                this.ctx.fill();
                
                // Add subtle highlight
                this.ctx.strokeStyle = `rgba(100, 150, 100, ${this.distance * 0.2})`;
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.moveTo(0, points[0].y);
                
                for (let i = 1; i < points.length; i++) {
                    this.ctx.lineTo(points[i].x, points[i].y);
                }
                this.ctx.stroke();
            }
            
            preRenderForest() {
                const width = this.getWidth();
                const centerX = 25;
                const centerY = this.height + 50;
                const treeCount = 5 + Math.floor(this.size * 8);
                
                for (let i = 0; i < treeCount; i++) {
                    const treeX = centerX + (i * width / treeCount) + (Math.random() - 0.5) * 10;
                    const treeHeight = this.height + (Math.random() - 0.5) * 15;
                    
                    // Tree trunk
                    this.ctx.fillStyle = `rgba(101, 67, 33, ${this.distance * 0.8})`;
                    this.ctx.fillRect(treeX - 2, centerY - 15, 4, 15);
                    
                    // Tree canopy - multiple layers for depth
                    this.ctx.fillStyle = this.color;
                    this.ctx.beginPath();
                    this.ctx.arc(treeX, centerY - treeHeight + 10, 8 + this.size * 3, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Additional foliage layers
                    this.ctx.beginPath();
                    this.ctx.arc(treeX - 3, centerY - treeHeight + 5, 6 + this.size * 2, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.beginPath();
                    this.ctx.arc(treeX + 3, centerY - treeHeight + 5, 6 + this.size * 2, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
            
            preRenderVillage() {
                const width = this.getWidth();
                const centerX = 25;
                const centerY = this.height + 50;
                const buildingCount = 2 + Math.floor(this.size * 3); // Fewer buildings than cities
                
                for (let i = 0; i < buildingCount; i++) {
                    const buildingX = centerX + (i * width / buildingCount) + (Math.random() - 0.5) * 15;
                    const buildingWidth = 8 + Math.random() * 12; // Smaller buildings
                    const buildingHeight = this.height + (Math.random() - 0.5) * 15; // Less height variation
                    
                    // Village house body (darker, more rural)
                    this.ctx.fillStyle = this.color;
                    this.ctx.fillRect(buildingX, centerY - buildingHeight, buildingWidth, buildingHeight);
                    
                    // Simple cottage roof
                    this.ctx.fillStyle = `rgba(60, 30, 10, ${this.distance * 0.8})`; // Dark brown roof
                    this.ctx.beginPath();
                    this.ctx.moveTo(buildingX - 2, centerY - buildingHeight);
                    this.ctx.lineTo(buildingX + buildingWidth/2, centerY - buildingHeight - 6);
                    this.ctx.lineTo(buildingX + buildingWidth + 2, centerY - buildingHeight);
                    this.ctx.closePath();
                    this.ctx.fill();
                    
                    // Simple windows (warmer, fewer than city)
                    if (this.distance > 0.4 && Math.random() < 0.7) {
                        this.ctx.fillStyle = `rgba(255, 200, 100, ${this.distance * 0.6})`; // Warm light
                        this.ctx.fillRect(
                            buildingX + 2,
                            centerY - buildingHeight + 3,
                            3, 4
                        );
                    }
                    
                    // Chimney smoke (if close and not all buildings)
                    if (this.distance > 0.3 && Math.random() < 0.4) {
                        this.ctx.fillStyle = `rgba(180, 180, 180, ${this.distance * 0.3})`;
                        this.ctx.fillRect(buildingX + buildingWidth - 3, centerY - buildingHeight - 2, 2, 6);
                        
                        // Smoke particles
                        for (let s = 0; s < 3; s++) {
                            this.ctx.beginPath();
                            this.ctx.arc(
                                buildingX + buildingWidth - 2 + Math.random() * 4 - 2,
                                centerY - buildingHeight - 8 - s * 3,
                                1,
                                0, Math.PI * 2
                            );
                            this.ctx.fill();
                        }
                    }
                }
            }
        }

        // Ground Height System
        class GroundHeightMap {
            constructor() {
                this.points = [];
                this.generateHeightMap();
            }
            
            generateHeightMap() {
                const segments = Math.floor(canvas.width / 10); // More segments for smoother curves
                const baseHeight = canvas.height - 200; // Raised base ground level (for subway visibility)
                
                for (let i = 0; i <= segments; i++) {
                    const x = (i * canvas.width) / segments;
                    const normalizedX = i / segments; // 0 to 1
                    
                    // Create gentle rolling hills with multiple sine waves
                    const hillHeight = 
                        Math.sin(normalizedX * Math.PI * 3) * 8 +           // Main hills (3 across width)
                        Math.sin(normalizedX * Math.PI * 7) * 4 +           // Medium variations
                        Math.sin(normalizedX * Math.PI * 15) * 2 +          // Fine details
                        Math.sin(normalizedX * Math.PI * 1.5) * 6;          // Large gentle slope
                    
                    this.points.push({
                        x: x,
                        y: baseHeight + hillHeight
                    });
                }
            }
            
            getHeightAt(x) {
                // Clamp x to canvas bounds
                x = Math.max(0, Math.min(canvas.width, x));
                
                // Find the two points to interpolate between
                for (let i = 0; i < this.points.length - 1; i++) {
                    if (x >= this.points[i].x && x <= this.points[i + 1].x) {
                        const ratio = (x - this.points[i].x) / (this.points[i + 1].x - this.points[i].x);
                        return this.points[i].y + (this.points[i + 1].y - this.points[i].y) * ratio;
                    }
                }
                return canvas.height - 200; // Default ground level (raised for subway visibility)
            }
            
            render() {
                // Render base ground fill
                ctx.fillStyle = '#1a3a1a'; // Dark green base
                ctx.fillRect(0, canvas.height - 15, canvas.width, 15);
                
                // Render rolling terrain
                ctx.fillStyle = '#2a4a2a'; // Medium green hills
                ctx.beginPath();
                ctx.moveTo(0, canvas.height);
                
                // Start from ground level at left edge
                ctx.lineTo(0, this.points[0].y);
                
                // Draw smooth curve through all points
                for (let i = 1; i < this.points.length - 1; i++) {
                    const currentPoint = this.points[i];
                    const nextPoint = this.points[i + 1];
                    
                    // Use quadratic curves for smooth transitions
                    const controlX = currentPoint.x + (nextPoint.x - currentPoint.x) * 0.5;
                    const controlY = currentPoint.y;
                    
                    ctx.quadraticCurveTo(controlX, controlY, nextPoint.x, nextPoint.y);
                }
                
                // Close the shape to bottom of canvas
                ctx.lineTo(canvas.width, canvas.height);
                ctx.lineTo(0, canvas.height);
                ctx.closePath();
                ctx.fill();
                
                // Add subtle grass texture on hills
                ctx.fillStyle = '#3a5a3a'; // Lighter green highlight
                ctx.beginPath();
                ctx.moveTo(0, this.points[0].y);
                
                for (let i = 1; i < this.points.length; i++) {
                    ctx.lineTo(this.points[i].x, this.points[i].y - 1); // Slightly above for highlight
                }
                
                // Create grass highlight strip
                for (let i = this.points.length - 1; i >= 0; i--) {
                    ctx.lineTo(this.points[i].x, this.points[i].y + 2); // Slightly below
                }
                ctx.closePath();
                ctx.fill();
                
                // Add ground contour line
                ctx.strokeStyle = '#4a6a4a';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, this.points[0].y);
                
                for (let i = 1; i < this.points.length; i++) {
                    ctx.lineTo(this.points[i].x, this.points[i].y);
                }
                ctx.stroke();
            }
        }

        // Civilian Evacuation System
        class Civilian {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.targetX = x;
                this.speed = 0.4 + Math.random() * 1.2; // More varied speeds (some faster, some slower)
                this.width = 8;
                this.height = 8;
                this.panicRadius = 120 + Math.random() * 60; // Variable panic distances (120-180px)
                this.direction = Math.random() < 0.5 ? -1 : 1; // Random initial direction
                this.color = this.getRandomColor();
                this.animationFrame = 0;
                this.isRunning = false;
                this.safeDistance = 200; // Distance they try to maintain from threats
                this.personalityType = Math.random(); // 0-1 scale for behavior variety
                this.nervousness = Math.random(); // How easily they panic
                
                // Age and evacuation behavior
                this.age = this.getRandomAge();
                this.evacuationTarget = null; // Subway station to evacuate to
                this.isEvacuating = false; // Currently heading to subway bunker
                this.inBunker = false; // Safe in subway bunker
                this.evacuationSpeed = this.getEvacuationSpeed();
                this.bunkerExitTime = null; // Timer for leaving bunker when safe
                
                // Construction/rebuild behavior
                this.role = this.getRandomRole();
                this.constructionTarget = null; // Building to work on
                this.isWorking = false; // Currently working on construction
                this.workProgress = 0; // Individual work contribution
                this.workSpeed = this.getWorkSpeed();
                
                // Hacker behavior
                this.targetMissile = null; // Enemy missile to hack
                this.isHacking = false; // Currently hacking a missile
                this.hackProgress = 0; // Progress on current hack (0-100)
                this.hackRange = 150; // Range to detect and hack missiles
                this.hackSpeed = 2; // How fast they hack
                this.laserBeam = null; // Visual laser beam
            }
            
            getRandomAge() {
                const ageRoll = Math.random();
                if (ageRoll < 0.15) return 'child'; // 15% children
                else if (ageRoll < 0.25) return 'elder'; // 10% elderly
                else return 'adult'; // 75% adults
            }
            
            getRandomRole() {
                // Only adults can have special roles
                if (this.age === 'adult') {
                    const roleRoll = Math.random();
                    if (roleRoll < 0.2) return 'hacker'; // 20% are hackers
                    if (roleRoll < 0.5) return 'construction'; // 30% are construction workers
                }
                return 'civilian';
            }
            
            getWorkSpeed() {
                if (this.role === 'construction') {
                    return 0.1 + Math.random() * 0.1; // Construction workers build faster
                }
                return 0.05 + Math.random() * 0.05; // Regular civilians help slower
            }
            
            getEvacuationSpeed() {
                switch(this.age) {
                    case 'child': return this.speed * 0.7; // Children slower
                    case 'elder': return this.speed * 0.5; // Elderly much slower
                    case 'adult': return this.speed * 1.0; // Normal speed
                }
            }
            
            getRandomColor() {
                // Hackers wear dark/tech colors
                if (this.role === 'hacker') {
                    const hackerColors = ['#00ff00', '#00ffff', '#0080ff', '#8000ff', '#ff00ff'];
                    return hackerColors[Math.floor(Math.random() * hackerColors.length)];
                }
                
                // Color clothing based on age for visual distinction
                if (this.age === 'child') {
                    const childColors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#ffeaa7', '#fd79a8', '#55a3ff'];
                    return childColors[Math.floor(Math.random() * childColors.length)];
                } else if (this.age === 'elder') {
                    const elderColors = ['#636e72', '#2d3436', '#74b9ff', '#6c5ce7', '#a29bfe', '#dda0dd'];
                    return elderColors[Math.floor(Math.random() * elderColors.length)];
                } else {
                    const adultColors = [
                        '#e17055', '#74b9ff', '#fd79a8', '#fdcb6e',
                        '#96ceb4', '#98d8c8', '#f7dc6f', '#dda0dd'
                    ];
                    return adultColors[Math.floor(Math.random() * adultColors.length)];
                }
            }
            
            findNearestSubwayStation() {
                let nearestStation = null;
                let nearestDistance = Infinity;
                
                groundBuildings.forEach(building => {
                    if (building.type === 'subway' && !building.destroyed) {
                        const distance = Math.sqrt((this.x - building.x) ** 2 + (this.y - building.y) ** 2);
                        if (distance < nearestDistance) {
                            nearestDistance = distance;
                            nearestStation = building;
                        }
                    }
                });
                
                return nearestStation;
            }
            
            update() {
                this.animationFrame += 0.2;
                this.isRunning = false;
                
                // Check for nearby threats (enemies and explosions) - MOVED TO TOP
                let closestThreat = null;
                let closestDistance = Infinity;
                let threatDetected = false;
                
                // Check enemy missiles
                enemies.forEach(enemy => {
                    const dist = Math.sqrt((this.x - enemy.x) ** 2 + (this.y - enemy.y) ** 2);
                    const adjustedPanicRadius = this.panicRadius * (0.7 + this.nervousness * 0.6); // Nervous people detect threats from farther
                    if (dist < adjustedPanicRadius && dist < closestDistance) {
                        closestDistance = dist;
                        closestThreat = { x: enemy.x, y: enemy.y };
                        threatDetected = true;
                    }
                });
                
                // Check interceptor missiles (friendly but still scary for civilians)
                bullets.forEach(bullet => {
                    // Only check interceptor missiles (not regular bullets)
                    if (bullet.constructor.name === 'InterceptorMissile') {
                        const dist = Math.sqrt((this.x - bullet.x) ** 2 + (this.y - bullet.y) ** 2);
                        const adjustedPanicRadius = this.panicRadius * 0.7 * (0.8 + this.nervousness * 0.4); // Less panic from friendly missiles, but still varies by personality
                        if (dist < adjustedPanicRadius && dist < closestDistance) {
                            closestDistance = dist;
                            closestThreat = { x: bullet.x, y: bullet.y };
                            threatDetected = true;
                        }
                    }
                });
                
                // Check explosions
                explosions.forEach(explosion => {
                    const dist = Math.sqrt((this.x - explosion.x) ** 2 + (this.y - explosion.y) ** 2);
                    const adjustedPanicRadius = this.panicRadius * 1.5 * (0.9 + this.nervousness * 0.2); // Everyone panics from explosions, nervous people more so
                    if (dist < adjustedPanicRadius && dist < closestDistance) {
                        closestDistance = dist;
                        closestThreat = { x: explosion.x, y: explosion.y };
                        threatDetected = true;
                    }
                });
                
                // Check if already in bunker
                if (this.inBunker) {
                    // Check if safe to leave bunker (no threats detected)
                    if (!threatDetected) {
                        // Wait a bit before leaving to avoid oscillating
                        if (!this.bunkerExitTime) {
                            this.bunkerExitTime = Date.now();
                        } else if (Date.now() - this.bunkerExitTime > 5000) { // Wait 5 seconds
                            this.inBunker = false;
                            this.bunkerExitTime = null;
                            // Remove from evacuation target if it exists
                            if (this.evacuationTarget && this.evacuationTarget.removeEvacuee) {
                                this.evacuationTarget.removeEvacuee(this);
                            }
                            this.evacuationTarget = null;
                            console.log(`${this.age} civilian leaving subway bunker - area safe`);
                        }
                    } else {
                        // Reset exit timer if threat detected
                        this.bunkerExitTime = null;
                    }
                    return; // Stay in bunker while threat exists or during exit delay
                }
                
                // Subway evacuation logic for vulnerable populations
                if (threatDetected && (this.age === 'child' || this.age === 'elder') && !this.isEvacuating) {
                    // Find nearest subway station for evacuation
                    this.evacuationTarget = this.findNearestSubwayStation();
                    if (this.evacuationTarget) {
                        this.isEvacuating = true;
                        console.log(`${this.age} civilian evacuating to subway bunker`);
                    }
                }
                
                // Handle evacuation movement
                if (this.isEvacuating && this.evacuationTarget) {
                    this.isRunning = true;
                    const dx = this.evacuationTarget.x - this.x;
                    const dy = this.evacuationTarget.y - this.y;
                    const distanceToStation = Math.sqrt(dx ** 2 + dy ** 2);
                    
                    if (distanceToStation < 15) {
                        // Reached subway station - enter bunker
                        if (this.evacuationTarget.addEvacuee && this.evacuationTarget.addEvacuee(this)) {
                            this.inBunker = true;
                            this.isEvacuating = false;
                            console.log(`${this.age} civilian safely in subway bunker`);
                        } else {
                            // Bunker full, stay near station
                            this.inBunker = true;
                            this.isEvacuating = false;
                            console.log(`${this.age} civilian sheltering near full bunker`);
                        }
                        return;
                    }
                    
                    // Move toward subway station
                    const moveX = (dx / distanceToStation) * this.evacuationSpeed;
                    this.x += moveX;
                    this.x = Math.max(8, Math.min(canvas.width - 8, this.x));
                    
                } else if (closestThreat && !this.isEvacuating) {
                    // Normal panic behavior for adults or when no subway available
                    this.isRunning = true;
                    
                    // Run away from the threat
                    const threatDx = this.x - closestThreat.x;
                    const threatDy = this.y - closestThreat.y;
                    const threatDistance = Math.sqrt(threatDx ** 2 + threatDy ** 2);
                    
                    if (threatDistance > 0) {
                        // Normalize direction and run away
                        const panicSpeedMultiplier = 1.5 + this.nervousness; // Nervous people run faster (1.5x to 2.5x speed)
                        const runAwayX = (threatDx / threatDistance) * this.speed * panicSpeedMultiplier;
                        
                        this.x += runAwayX;
                        
                        // Keep civilians on screen
                        this.x = Math.max(8, Math.min(canvas.width - 8, this.x));
                    }
                } else if (!this.isEvacuating) {
                    // Hacker behavior - look for enemy missiles to convert
                    if (this.role === 'hacker') {
                        if (!this.targetMissile || this.targetMissile.converted || this.targetMissile.dead) {
                            // Find new missile to hack
                            this.targetMissile = this.findNearestEnemyMissile();
                            this.isHacking = false;
                            this.hackProgress = 0;
                        }
                        
                        if (this.targetMissile) {
                            // Move toward missile or hack it
                            const dx = this.targetMissile.x - this.x;
                            const dy = this.targetMissile.y - this.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < this.hackRange) {
                                // In range - start/continue hacking
                                this.isHacking = true;
                                this.hackMissile();
                            } else {
                                // Move closer
                                this.isHacking = false;
                                const moveSpeed = this.speed * 1.2; // Hackers move faster when chasing missiles
                                this.x += Math.sign(dx) * moveSpeed;
                            }
                        } else {
                            // No missiles - wander
                            const walkingSpeed = this.speed * (0.2 + this.personalityType * 0.2);
                            this.x += this.direction * walkingSpeed;
                        }
                    }
                    // Construction/rebuild behavior - only when safe (and not hacker)
                    else if (!this.constructionTarget && (this.role === 'construction' || Math.random() < 0.1)) {
                        // Look for destroyed buildings to rebuild or sites for new buildings
                        this.constructionTarget = this.findConstructionWork();
                    }
                    
                    if (this.constructionTarget) {
                        // Move toward construction site
                        const dx = this.constructionTarget.x - this.x;
                        const distanceToSite = Math.abs(dx);
                        
                        if (distanceToSite < 20) {
                            // At construction site - start working
                            this.isWorking = true;
                            this.contributeToConstruction();
                        } else {
                            // Travel to construction site
                            this.isWorking = false;
                            const moveSpeed = this.speed * 0.8;
                            this.x += Math.sign(dx) * moveSpeed;
                        }
                    } else {
                        // Normal wandering
                        const walkingSpeed = this.speed * (0.2 + this.personalityType * 0.2); // Some people walk faster
                        this.x += this.direction * walkingSpeed;
                    }
                    
                    // Bounce off screen edges
                    if (this.x <= 8 || this.x >= canvas.width - 8) {
                        this.direction *= -1;
                        this.x = Math.max(8, Math.min(canvas.width - 8, this.x));
                    }
                }
                
                // Update ground position
                if (groundHeightMap) {
                    this.y = groundHeightMap.getHeightAt(this.x) - 2; // Stand slightly above ground
                }
            }
            
            render() {
                // Skip rendering if civilian is in bunker
                if (this.inBunker) {
                    return;
                }
                
                // Civilian body (simple stick figure) - size varies by age
                ctx.fillStyle = this.color;
                
                // Body size based on age
                const bodySize = this.age === 'child' ? 3 : this.age === 'elder' ? 4 : 4;
                const headSize = this.age === 'child' ? 1.5 : 2;
                
                // Body
                ctx.fillRect(this.x - bodySize/2, this.y - this.height + 2, bodySize, bodySize);
                
                // Head
                ctx.fillStyle = '#ffdbac'; // Skin color
                ctx.fillRect(this.x - headSize/2, this.y - this.height, headSize, headSize);
                
                // Special indicators for evacuation
                if (this.isEvacuating) {
                    // Green arrow pointing to subway for evacuating civilians
                    ctx.fillStyle = '#00ff00';
                    ctx.fillRect(this.x - 1, this.y - this.height - 8, 2, 3);
                    ctx.fillRect(this.x - 2, this.y - this.height - 6, 4, 1);
                }
                
                // Running animation - simple leg movement
                if (this.isRunning) {
                    const legOffset = Math.sin(this.animationFrame * 3) * 1;
                    // Running legs
                    ctx.fillStyle = '#333333';
                    ctx.fillRect(this.x - 1 + legOffset, this.y - 2, 1, 2);
                    ctx.fillRect(this.x + legOffset, this.y - 2, 1, 2);
                    
                    // Arms pumping
                    const armOffset = Math.sin(this.animationFrame * 3) * 1;
                    ctx.fillRect(this.x - 3 + armOffset, this.y - 6, 1, 2);
                    ctx.fillRect(this.x + 2 - armOffset, this.y - 6, 1, 2);
                } else {
                    // Walking legs
                    ctx.fillStyle = '#333333';
                    ctx.fillRect(this.x - 1, this.y - 2, 1, 2);
                    ctx.fillRect(this.x, this.y - 2, 1, 2);
                    
                    // Relaxed arms
                    ctx.fillRect(this.x - 2, this.y - 6, 1, 2);
                    ctx.fillRect(this.x + 1, this.y - 6, 1, 2);
                }
                
                // Panic indicator (exclamation mark when running)
                if (this.isRunning) {
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(this.x - 1, this.y - this.height - 6, 2, 3);
                    ctx.fillRect(this.x - 1, this.y - this.height - 2, 2, 1);
                }
                
                // Working indicator (construction helmet and tools)
                if (this.isWorking) {
                    // Hard hat
                    ctx.fillStyle = '#ffa500';
                    ctx.fillRect(this.x - 2, this.y - this.height - 1, 4, 2);
                    // Tool (hammer/wrench)
                    ctx.fillStyle = '#808080';
                    ctx.fillRect(this.x + 2, this.y - 6, 1, 3);
                }
                
                // Hacking indicator (laptop and laser beam)
                if (this.isHacking && this.targetMissile) {
                    // Laptop
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(this.x - 3, this.y - 6, 6, 4);
                    ctx.fillStyle = '#00ff00';
                    ctx.fillRect(this.x - 2, this.y - 5, 4, 2);
                    
                    // Laser beam to missile
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 3]);
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y - 8);
                    ctx.lineTo(this.targetMissile.x, this.targetMissile.y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Hack progress indicator
                    ctx.fillStyle = '#00ff00';
                    ctx.fillRect(this.x - 5, this.y - this.height - 8, 10 * (this.hackProgress / 100), 2);
                }
            }
            
            findNearestEnemyMissile() {
                let nearest = null;
                let nearestDistance = Infinity;
                
                enemies.forEach(enemy => {
                    if (!enemy.converted && !enemy.dead) {
                        const dx = this.x - enemy.x;
                        const dy = this.y - enemy.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < nearestDistance && distance < this.hackRange * 2) {
                            nearestDistance = distance;
                            nearest = enemy;
                        }
                    }
                });
                
                return nearest;
            }
            
            hackMissile() {
                if (!this.targetMissile || this.targetMissile.converted || this.targetMissile.dead) {
                    this.isHacking = false;
                    return;
                }
                
                this.hackProgress += this.hackSpeed;
                
                if (this.hackProgress >= 100) {
                    // Successfully hacked the missile!
                    this.convertMissile();
                    this.hackProgress = 0;
                    this.isHacking = false;
                    this.targetMissile = null;
                }
            }
            
            convertMissile() {
                if (!this.targetMissile) return;
                
                // Mark missile as converted
                this.targetMissile.converted = true;
                this.targetMissile.isConverted = true;
                
                // Add to inventory
                if (!gameState.convertedMissiles) {
                    gameState.convertedMissiles = [];
                }
                
                gameState.convertedMissiles.push({
                    type: 'missile',
                    damage: this.targetMissile.damage || 1,
                    speed: this.targetMissile.speed || 3,
                    timestamp: Date.now()
                });
                
                // Remove from enemies array
                this.targetMissile.dead = true;
                
                playSound('collect');
                updateStatus(`üíª HACKER converted enemy missile! Stored in inventory! Total: ${gameState.convertedMissiles.length} üöÄ`);
                console.log('Missile converted by hacker!', gameState.convertedMissiles);
            }
            
            findConstructionWork() {
                let nearestWork = null;
                let nearestDistance = Infinity;
                
                groundBuildings.forEach(building => {
                    const distance = Math.abs(this.x - building.x);
                    
                    // Check for destroyed buildings to rebuild
                    if (building.destroyed && building.isRebuilding) {
                        if (distance < nearestDistance && distance < 400) {
                            nearestDistance = distance;
                            nearestWork = building;
                        }
                    }
                });
                
                // If no rebuild work, look for new construction sites
                if (!nearestWork && constructionSites) {
                    constructionSites.forEach(site => {
                        const distance = Math.abs(this.x - site.x);
                        if (!site.completed && distance < nearestDistance && distance < 400) {
                            nearestDistance = distance;
                            nearestWork = site;
                        }
                    });
                }
                
                return nearestWork;
            }
            
            contributeToConstruction() {
                if (!this.constructionTarget) return;
                
                // Add work progress to the building/site
                if (this.constructionTarget.addWorkProgress) {
                    this.constructionTarget.addWorkProgress(this.workSpeed);
                } else if (this.constructionTarget.rebuildProgress !== undefined) {
                    // Rebuilding destroyed building
                    this.constructionTarget.rebuildProgress += this.workSpeed;
                    
                    if (this.constructionTarget.rebuildProgress >= 100) {
                        this.constructionTarget.rebuild();
                        this.constructionTarget = null;
                        this.isWorking = false;
                    }
                }
            }
        }

        // Ground Infrastructure System
        class GroundBuilding {
            constructor(x, type, size = 'normal') {
                this.x = x;
                this.type = type; // 'house', 'hospital', 'office', 'factory', 'school', 'university', 'theatre', 'subway', 'trainstation', 'road'
                this.size = size; // 'small', 'normal', 'big'
                this.health = this.getMaxHealth();
                this.maxHealth = this.health;
                this.width = this.getWidth();
                this.height = this.getHeight();
                this.damaged = false;
                this.destroyed = false;
                this.smokeParticles = [];
                this.lastHitTime = 0;
                // Use height map for y position
                this.y = groundHeightMap ? groundHeightMap.getHeightAt(x) : canvas.height - 200;
                
                // Rebuild system
                this.isRebuilding = false;
                this.rebuildProgress = 0;
                this.workersPresent = 0;
                
                // Underground tunnel system for subway stations
                if (this.type === 'subway') {
                    this.tunnelWidth = 120;
                    this.tunnelHeight = 40;
                    this.tunnelDepth = 60;
                    this.evacuees = []; // Array to store evacuated civilians
                    this.maxCapacity = 25; // Maximum civilians that can shelter here
                }
            }
            
            getMaxHealth() {
                switch(this.type) {
                    case 'hospital': return 3; // Critical infrastructure
                    case 'school': return 3; // Critical public infrastructure
                    case 'university': return 4; // Large educational complex
                    case 'theatre': return 2; // Cultural building
                    case 'subway': return 3; // Critical transportation
                    case 'trainstation': return 4; // Major transportation hub
                    case 'office': return 2;
                    case 'factory': return 2;
                    case 'farm': return 1; // Rural buildings
                    case 'house': return 1;
                    case 'road': return 1;
                    default: return 1;
                }
            }
            
            getWidth() {
                switch(this.type) {
                    case 'hospital': return 50;
                    case 'school': return 55; // Large educational building
                    case 'university': return 80; // Very large campus building
                    case 'theatre': return 45; // Medium cultural building
                    case 'subway': return 25; // Narrow subway entrance
                    case 'trainstation': return 90; // Very wide transportation hub
                    case 'office': 
                        return this.size === 'big' ? 55 : 40; // Big offices are larger
                    case 'factory': return 60;
                    case 'farm': return 70; // Large rural buildings
                    case 'house': 
                        return this.size === 'small' ? 20 : 30; // Small houses are narrower
                    case 'road': return 20;
                    default: return 30;
                }
            }
            
            getHeight() {
                switch(this.type) {
                    case 'hospital': return 45;
                    case 'school': return 40; // Medium height educational building
                    case 'university': return 55; // Tall campus building
                    case 'theatre': return 35; // Medium cultural building
                    case 'subway': return 15; // Low subway entrance/pavilion
                    case 'trainstation': return 50; // Tall transportation hub
                    case 'office': 
                        return this.size === 'big' ? 60 : 50; // Big offices are taller
                    case 'factory': return 35;
                    case 'farm': return 30; // Lower rural buildings
                    case 'house': 
                        return this.size === 'small' ? 18 : 25; // Small houses are shorter
                    case 'road': return 5;
                    default: return 25;
                }
            }
            
            takeDamage() {
                if (this.destroyed) return;
                
                this.health--;
                this.damaged = true;
                this.lastHitTime = Date.now();
                
                // Initialize fire system on first damage
                if (!this.fireParticles) {
                    this.fireParticles = [];
                    this.burnIntensity = 0;
                    this.isBurning = true; // Mark building as burning permanently
                }
                
                // Increase burn intensity with each hit
                this.burnIntensity = Math.min(this.burnIntensity + 0.3, 1.0);
                
                // Buildings keep burning until destroyed (remove burnTime countdown)
                // this.burnTime = Math.max(this.burnTime || 0, 120 + (this.maxHealth - this.health) * 60);
                
                // Add progressive fire based on damage
                const fireCount = Math.floor(8 + (this.maxHealth - this.health) * 5); // More fire as health decreases
                for (let i = 0; i < fireCount; i++) {
                    this.fireParticles.push({
                        x: this.x + Math.random() * this.width,
                        y: this.y - Math.random() * this.height,
                        vx: (Math.random() - 0.5) * 1.5,
                        vy: -Math.random() * 2 - 0.8,
                        life: 40 + Math.random() * 60 + (this.maxHealth - this.health) * 20, // Longer fire as more damaged
                        size: 0.8 + Math.random() * 2 + this.burnIntensity,
                        heat: 0.6 + this.burnIntensity * 0.4,
                        flicker: Math.random() * Math.PI * 2
                    });
                }
                
                // Add smoke particles (more with greater damage)
                const smokeCount = 8 + (this.maxHealth - this.health) * 4;
                for (let i = 0; i < smokeCount; i++) {
                    this.smokeParticles.push({
                        x: this.x + Math.random() * this.width,
                        y: this.y - Math.random() * this.height,
                        vx: (Math.random() - 0.5) * 2,
                        vy: -Math.random() * 2 - 1,
                        life: 60 + (this.maxHealth - this.health) * 30,
                        maxLife: 60 + (this.maxHealth - this.health) * 30
                    });
                }
                
                if (this.health <= 0) {
                    this.destroyed = true;
                    this.burnIntensity = 1.0; // Maximum fire when destroyed
                    this.isBurning = true; // Ensure destroyed buildings keep burning
                    
                    // Massive fire explosion when building is destroyed
                    for (let i = 0; i < 25; i++) {
                        this.fireParticles.push({
                            x: this.x + Math.random() * this.width,
                            y: this.y - Math.random() * this.height,
                            vx: (Math.random() - 0.5) * 3,
                            vy: -Math.random() * 3 - 1,
                            life: 80 + Math.random() * 60,
                            size: 2 + Math.random() * 3,
                            heat: 0.8 + Math.random() * 0.2,
                            flicker: Math.random() * Math.PI * 2
                        });
                    }
                    
                    // Add destruction particles
                    for (let i = 0; i < 20; i++) {
                        this.smokeParticles.push({
                            x: this.x + Math.random() * this.width,
                            y: this.y - Math.random() * this.height,
                            vx: (Math.random() - 0.5) * 4,
                            vy: -Math.random() * 3 - 2,
                            life: 120,
                            maxLife: 120
                        });
                    }
                    
                    // Update status for critical buildings
                    if (this.type === 'hospital') {
                        updateStatus("üö® HOSPITAL DESTROYED! CIVILIAN CASUALTIES! üö®");
                        playSound('lose');
                    } else if (this.type === 'factory') {
                        updateStatus("‚ö†Ô∏è FACTORY DESTROYED! INFRASTRUCTURE DAMAGED! ‚ö†Ô∏è");
                        playSound('explosion');
                    }
                }
            }
            
            update() {
                // Update fire particles
                if (this.fireParticles) {
                    this.fireParticles.forEach(p => {
                        p.x += p.vx + Math.sin(p.flicker) * 0.3;
                        p.y += p.vy;
                        p.vx *= 0.98;
                        p.vy *= 0.98;
                        p.life--;
                        p.heat *= 0.995;
                        p.flicker += 0.2 + this.burnIntensity * 0.1;
                    });
                    
                    this.fireParticles = this.fireParticles.filter(p => p.life > 0);
                    
                    // Continuous fire generation - buildings keep burning until destroyed
                    if (this.damaged && !this.destroyed) {
                        // Buildings burn continuously once damaged until destroyed
                        const spawnChance = 0.15 + (this.maxHealth - this.health) * 0.2; // More fire as more damaged
                        
                        if (Math.random() < spawnChance) {
                            const fireIntensity = this.burnIntensity || (this.maxHealth - this.health) / this.maxHealth;
                            
                            this.fireParticles.push({
                                x: this.x + Math.random() * this.width,
                                y: this.y - Math.random() * this.height * 0.8,
                                vx: (Math.random() - 0.5) * 1,
                                vy: -Math.random() * 1.5 - 0.5 - fireIntensity * 0.5,
                                life: 30 + Math.random() * 40 + fireIntensity * 30,
                                size: 0.8 + Math.random() * 1.5 + fireIntensity * 0.5,
                                heat: 0.5 + fireIntensity * 0.4 + Math.random() * 0.2,
                                flicker: Math.random() * Math.PI * 2
                            });
                        }
                        
                        // Continuous smoke for burning buildings
                        if (Math.random() < 0.25 + (this.maxHealth - this.health) * 0.15) {
                            this.smokeParticles.push({
                                x: this.x + Math.random() * this.width,
                                y: this.y - Math.random() * this.height,
                                vx: (Math.random() - 0.5) * 1.5,
                                vy: -Math.random() * 1.5 - 1,
                                life: 90 + Math.random() * 60,
                                maxLife: 150
                            });
                        }
                    } else if (this.destroyed) {
                        // Destroyed buildings burn even more intensely
                        if (Math.random() < 0.7) { // 70% chance each frame
                            this.fireParticles.push({
                                x: this.x + Math.random() * this.width,
                                y: this.y - Math.random() * this.height,
                                vx: (Math.random() - 0.5) * 2,
                                vy: -Math.random() * 2.5 - 1,
                                life: 50 + Math.random() * 50,
                                size: 1.5 + Math.random() * 2.5,
                                heat: 0.8 + Math.random() * 0.2,
                                flicker: Math.random() * Math.PI * 2
                            });
                        }
                        
                        // Heavy smoke for destroyed buildings
                        if (Math.random() < 0.4) {
                            this.smokeParticles.push({
                                x: this.x + Math.random() * this.width,
                                y: this.y - Math.random() * this.height,
                                vx: (Math.random() - 0.5) * 2,
                                vy: -Math.random() * 2 - 1.5,
                                life: 120 + Math.random() * 80,
                                maxLife: 200
                            });
                        }
                    }
                }
                
                // Update smoke particles
                this.smokeParticles = this.smokeParticles.filter(particle => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.life--;
                    particle.vy += 0.1; // Gravity
                    return particle.life > 0;
                });
            }
            
            render() {
                ctx.save();
                
                // Apply damage tinting
                if (this.destroyed) {
                    ctx.globalAlpha = 0.4;
                } else if (this.damaged) {
                    const flashIntensity = Math.max(0, (500 - (Date.now() - this.lastHitTime)) / 500);
                    if (flashIntensity > 0) {
                        ctx.fillStyle = `rgba(255, 0, 0, ${flashIntensity * 0.3})`;
                        ctx.fillRect(this.x - 5, this.y - this.height - 5, this.width + 10, this.height + 10);
                    }
                }
                
                switch(this.type) {
                    case 'hospital':
                        this.renderHospital();
                        break;
                    case 'school':
                        this.renderSchool();
                        break;
                    case 'university':
                        this.renderUniversity();
                        break;
                    case 'theatre':
                        this.renderTheatre();
                        break;
                    case 'subway':
                        this.renderSubway();
                        break;
                    case 'trainstation':
                        this.renderTrainStation();
                        break;
                    case 'office':
                        this.renderOffice();
                        break;
                    case 'factory':
                        this.renderFactory();
                        break;
                    case 'farm':
                        this.renderFarm();
                        break;
                    case 'house':
                        this.renderHouse();
                        break;
                    case 'road':
                        this.renderRoad();
                        break;
                }
                
                // Render smoke particles
                this.smokeParticles.forEach(particle => {
                    const alpha = particle.life / particle.maxLife;
                    ctx.fillStyle = `rgba(100, 100, 100, ${alpha * 0.6})`;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, 3 * alpha, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // Render fire particles (building on fire)
                if (this.fireParticles && this.fireParticles.length > 0) {
                    this.fireParticles.forEach(p => {
                        const alpha = (p.life / 100) * p.heat;
                        const red = Math.floor(255 * p.heat);
                        const green = Math.floor(100 * p.heat + 100 * (1 - p.heat));
                        const blue = Math.floor(20 * (1 - p.heat));
                        
                        ctx.globalAlpha = alpha * 0.8;
                        ctx.fillStyle = `rgb(${red}, ${green}, ${blue})`;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    ctx.globalAlpha = 1;
                }
                
                // Health indicator for critical buildings
                if (this.type === 'hospital' || this.type === 'school' || this.type === 'university' || 
                    this.type === 'factory' || this.type === 'subway' || this.type === 'trainstation') {
                    this.renderHealthBar();
                }
                
                ctx.restore();
            }
            
            renderHospital() {
                const baseColor = this.destroyed ? '#333333' : '#ffffff';
                
                // Main building
                ctx.fillStyle = baseColor;
                ctx.fillRect(this.x, this.y - this.height, this.width, this.height);
                
                // Red cross
                if (!this.destroyed) {
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(this.x + this.width/2 - 3, this.y - this.height + 5, 6, 20);
                    ctx.fillRect(this.x + this.width/2 - 10, this.y - this.height + 12, 20, 6);
                }
                
                // Windows
                ctx.fillStyle = this.destroyed ? '#111111' : '#4a9eff';
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 2; j++) {
                        ctx.fillRect(this.x + 8 + i * 12, this.y - this.height + 25 + j * 10, 8, 6);
                    }
                }
                
                // Outline
                ctx.strokeStyle = '#cccccc';
                ctx.lineWidth = 1;
                ctx.strokeRect(this.x, this.y - this.height, this.width, this.height);
            }
            
            renderOffice() {
                const baseColor = this.destroyed ? '#333333' : '#666666';
                
                // Main building
                ctx.fillStyle = baseColor;
                ctx.fillRect(this.x, this.y - this.height, this.width, this.height);
                
                // Windows
                ctx.fillStyle = this.destroyed ? '#111111' : '#ffff88';
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 5; j++) {
                        ctx.fillRect(this.x + 4 + i * 8, this.y - this.height + 5 + j * 8, 6, 6);
                    }
                }
                
                // Outline
                ctx.strokeStyle = '#888888';
                ctx.lineWidth = 1;
                ctx.strokeRect(this.x, this.y - this.height, this.width, this.height);
            }
            
            renderFactory() {
                const baseColor = this.destroyed ? '#333333' : '#8B4513';
                
                // Main building
                ctx.fillStyle = baseColor;
                ctx.fillRect(this.x, this.y - this.height, this.width, this.height);
                
                // Smokestacks
                if (!this.destroyed) {
                    ctx.fillStyle = '#555555';
                    ctx.fillRect(this.x + 10, this.y - this.height - 15, 8, 15);
                    ctx.fillRect(this.x + 35, this.y - this.height - 12, 6, 12);
                }
                
                // Large doors
                ctx.fillStyle = this.destroyed ? '#111111' : '#444444';
                ctx.fillRect(this.x + 20, this.y - 25, 20, 25);
                
                // Outline
                ctx.strokeStyle = '#A0522D';
                ctx.lineWidth = 1;
                ctx.strokeRect(this.x, this.y - this.height, this.width, this.height);
            }
            
            renderFarm() {
                const baseColor = this.destroyed ? '#333333' : '#DEB887'; // Sandy brown for farm buildings
                
                // Main barn structure
                ctx.fillStyle = baseColor;
                ctx.fillRect(this.x, this.y - this.height, this.width * 0.6, this.height);
                
                // Barn roof
                if (!this.destroyed) {
                    ctx.fillStyle = '#8B0000'; // Dark red barn roof
                    ctx.beginPath();
                    ctx.moveTo(this.x - 2, this.y - this.height);
                    ctx.lineTo(this.x + this.width * 0.3, this.y - this.height - 8);
                    ctx.lineTo(this.x + this.width * 0.6 + 2, this.y - this.height);
                    ctx.closePath();
                    ctx.fill();
                }
                
                // Barn doors
                ctx.fillStyle = this.destroyed ? '#111111' : '#654321';
                ctx.fillRect(this.x + this.width * 0.2, this.y - this.height * 0.8, this.width * 0.2, this.height * 0.8);
                
                // Silo
                if (!this.destroyed) {
                    ctx.fillStyle = '#C0C0C0'; // Silver silo
                    ctx.fillRect(this.x + this.width * 0.7, this.y - this.height, this.width * 0.15, this.height);
                    
                    // Silo top
                    ctx.fillStyle = '#A0A0A0';
                    ctx.beginPath();
                    ctx.arc(this.x + this.width * 0.775, this.y - this.height, this.width * 0.075, 0, Math.PI, true);
                    ctx.fill();
                }
                
                // Farm fields (if not destroyed)
                if (!this.destroyed) {
                    ctx.fillStyle = '#228B22'; // Forest green for crops
                    const fieldCount = 3;
                    for (let i = 0; i < fieldCount; i++) {
                        const fieldX = this.x - 10 + i * 8;
                        const fieldY = this.y - 5;
                        ctx.fillRect(fieldX, fieldY, 6, 5);
                    }
                }
                
                // Outline
                ctx.strokeStyle = '#D2691E';
                ctx.lineWidth = 1;
                ctx.strokeRect(this.x, this.y - this.height, this.width * 0.6, this.height);
            }
            
            renderHouse() {
                const baseColor = this.destroyed ? '#333333' : '#8B4513';
                
                // Main structure
                ctx.fillStyle = baseColor;
                ctx.fillRect(this.x, this.y - this.height, this.width, this.height);
                
                // Roof
                if (!this.destroyed) {
                    ctx.fillStyle = '#654321';
                    ctx.beginPath();
                    ctx.moveTo(this.x - 3, this.y - this.height);
                    ctx.lineTo(this.x + this.width/2, this.y - this.height - 8);
                    ctx.lineTo(this.x + this.width + 3, this.y - this.height);
                    ctx.closePath();
                    ctx.fill();
                }
                
                // Door
                ctx.fillStyle = this.destroyed ? '#111111' : '#8B4513';
                ctx.fillRect(this.x + this.width/2 - 4, this.y - 15, 8, 15);
                
                // Windows
                ctx.fillStyle = this.destroyed ? '#111111' : '#87CEEB';
                ctx.fillRect(this.x + 5, this.y - 18, 6, 6);
                ctx.fillRect(this.x + this.width - 11, this.y - 18, 6, 6);
            }
            
            renderRoad() {
                const baseColor = this.destroyed ? '#222222' : '#444444';
                
                // Road surface
                ctx.fillStyle = baseColor;
                ctx.fillRect(this.x, this.y - this.height, this.width, this.height);
                
                // Road markings
                if (!this.destroyed) {
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(this.x + this.width/2 - 1, this.y - this.height/2, 2, 1);
                }
            }
            
            renderSchool() {
                const baseColor = this.destroyed ? '#333333' : '#f4f4f4';
                
                // Main building
                ctx.fillStyle = baseColor;
                ctx.fillRect(this.x, this.y - this.height, this.width, this.height);
                
                // School sign
                if (!this.destroyed) {
                    ctx.fillStyle = '#ff4444';
                    ctx.fillRect(this.x + 5, this.y - this.height + 5, this.width - 10, 8);
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '8px Arial';
                    ctx.fillText('SCHOOL', this.x + this.width/2 - 15, this.y - this.height + 11);
                }
                
                // Windows in rows
                ctx.fillStyle = this.destroyed ? '#111111' : '#87ceeb';
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 2; j++) {
                        ctx.fillRect(this.x + 8 + i * 10, this.y - this.height + 18 + j * 12, 6, 8);
                    }
                }
                
                // Main entrance
                ctx.fillStyle = this.destroyed ? '#111111' : '#8b4513';
                ctx.fillRect(this.x + this.width/2 - 6, this.y - 18, 12, 18);
                
                // Outline
                ctx.strokeStyle = '#cccccc';
                ctx.lineWidth = 1;
                ctx.strokeRect(this.x, this.y - this.height, this.width, this.height);
            }
            
            renderUniversity() {
                const baseColor = this.destroyed ? '#333333' : '#e6d7a8';
                
                // Main building complex
                ctx.fillStyle = baseColor;
                ctx.fillRect(this.x, this.y - this.height, this.width, this.height);
                
                // Classical columns
                if (!this.destroyed) {
                    ctx.fillStyle = '#ffffff';
                    for (let i = 0; i < 4; i++) {
                        ctx.fillRect(this.x + 10 + i * 15, this.y - this.height + 10, 4, this.height - 20);
                    }
                }
                
                // University banner
                if (!this.destroyed) {
                    ctx.fillStyle = '#2c5aa0';
                    ctx.fillRect(this.x + 5, this.y - this.height + 5, this.width - 10, 10);
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '8px Arial';
                    ctx.fillText('UNIVERSITY', this.x + this.width/2 - 20, this.y - this.height + 12);
                }
                
                // Academic windows
                ctx.fillStyle = this.destroyed ? '#111111' : '#ffffcc';
                for (let i = 0; i < 5; i++) {
                    for (let j = 0; j < 3; j++) {
                        ctx.fillRect(this.x + 8 + i * 13, this.y - this.height + 20 + j * 10, 8, 6);
                    }
                }
                
                // Grand entrance
                ctx.fillStyle = this.destroyed ? '#111111' : '#8b4513';
                ctx.fillRect(this.x + this.width/2 - 8, this.y - 20, 16, 20);
                
                // Outline
                ctx.strokeStyle = '#cccccc';
                ctx.lineWidth = 1;
                ctx.strokeRect(this.x, this.y - this.height, this.width, this.height);
            }
            
            renderTheatre() {
                const baseColor = this.destroyed ? '#333333' : '#8B0000';
                
                // Main building
                ctx.fillStyle = baseColor;
                ctx.fillRect(this.x, this.y - this.height, this.width, this.height);
                
                // Theatre marquee
                if (!this.destroyed) {
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(this.x + 5, this.y - this.height + 8, this.width - 10, 12);
                    ctx.fillStyle = '#000000';
                    ctx.font = '8px Arial';
                    ctx.fillText('THEATRE', this.x + this.width/2 - 18, this.y - this.height + 17);
                }
                
                // Decorative elements
                if (!this.destroyed) {
                    ctx.fillStyle = '#FFD700';
                    // Theatre masks (comedy/tragedy symbols)
                    ctx.beginPath();
                    ctx.arc(this.x + this.width/3, this.y - this.height/2, 4, 0, Math.PI * 2);
                    ctx.arc(this.x + 2*this.width/3, this.y - this.height/2, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Entrance doors
                ctx.fillStyle = this.destroyed ? '#111111' : '#8b4513';
                ctx.fillRect(this.x + this.width/2 - 8, this.y - 18, 16, 18);
                
                // Windows
                ctx.fillStyle = this.destroyed ? '#111111' : '#ffffaa';
                for (let i = 0; i < 3; i++) {
                    ctx.fillRect(this.x + 8 + i * 12, this.y - this.height + 25, 6, 8);
                }
                
                // Outline
                ctx.strokeStyle = '#cccccc';
                ctx.lineWidth = 1;
                ctx.strokeRect(this.x, this.y - this.height, this.width, this.height);
            }
            
            renderSubway() {
                const baseColor = this.destroyed ? '#333333' : '#2c2c54';
                
                // Subway entrance pavilion
                ctx.fillStyle = baseColor;
                ctx.fillRect(this.x, this.y - this.height, this.width, this.height);
                
                // Subway sign
                if (!this.destroyed) {
                    ctx.fillStyle = '#ff6b6b';
                    ctx.fillRect(this.x + 2, this.y - this.height + 2, this.width - 4, 8);
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '6px Arial';
                    ctx.fillText('METRO', this.x + this.width/2 - 10, this.y - this.height + 8);
                }
                
                // Entrance stairs indication
                if (!this.destroyed) {
                    ctx.fillStyle = '#555555';
                    for (let i = 0; i < 3; i++) {
                        ctx.fillRect(this.x + 3 + i * 6, this.y - 5 - i * 2, this.width - 6, 2);
                    }
                }
                
                // Safety glass panels
                ctx.fillStyle = this.destroyed ? '#111111' : '#a8e6cf';
                ctx.fillRect(this.x + 3, this.y - this.height + 10, this.width - 6, 3);
                
                // Outline
                ctx.strokeStyle = '#cccccc';
                ctx.lineWidth = 1;
                ctx.strokeRect(this.x, this.y - this.height, this.width, this.height);
            }
            
            renderTrainStation() {
                const baseColor = this.destroyed ? '#333333' : '#5d6d7e';
                
                // Main station building
                ctx.fillStyle = baseColor;
                ctx.fillRect(this.x, this.y - this.height, this.width, this.height);
                
                // Station roof/canopy
                if (!this.destroyed) {
                    ctx.fillStyle = '#34495e';
                    ctx.fillRect(this.x - 5, this.y - this.height - 5, this.width + 10, 8);
                }
                
                // Station sign
                if (!this.destroyed) {
                    ctx.fillStyle = '#e74c3c';
                    ctx.fillRect(this.x + 10, this.y - this.height + 5, this.width - 20, 12);
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '8px Arial';
                    ctx.fillText('TRAIN STATION', this.x + this.width/2 - 25, this.y - this.height + 13);
                }
                
                // Large windows
                ctx.fillStyle = this.destroyed ? '#111111' : '#85c1e9';
                for (let i = 0; i < 6; i++) {
                    for (let j = 0; j < 2; j++) {
                        ctx.fillRect(this.x + 8 + i * 12, this.y - this.height + 20 + j * 12, 8, 8);
                    }
                }
                
                // Platform entrance
                ctx.fillStyle = this.destroyed ? '#111111' : '#8b4513';
                ctx.fillRect(this.x + this.width/2 - 10, this.y - 20, 20, 20);
                
                // Railway tracks indication
                if (!this.destroyed) {
                    ctx.fillStyle = '#7f8c8d';
                    ctx.fillRect(this.x - 10, this.y + 2, this.width + 20, 2);
                    ctx.fillRect(this.x - 10, this.y + 6, this.width + 20, 2);
                }
                
                // Outline
                ctx.strokeStyle = '#cccccc';
                ctx.lineWidth = 1;
                ctx.strokeRect(this.x, this.y - this.height, this.width, this.height);
            }
            
            renderHealthBar() {
                const barWidth = this.width;
                const barHeight = 4;
                const healthPercent = this.health / this.maxHealth;
                
                // Background
                ctx.fillStyle = '#333333';
                ctx.fillRect(this.x, this.y - this.height - 8, barWidth, barHeight);
                
                // Health bar
                ctx.fillStyle = healthPercent > 0.6 ? '#00ff00' : healthPercent > 0.3 ? '#ffff00' : '#ff0000';
                ctx.fillRect(this.x, this.y - this.height - 8, barWidth * healthPercent, barHeight);
                
                // Border
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1;
                ctx.strokeRect(this.x, this.y - this.height - 8, barWidth, barHeight);
            }
            
            // Add evacuee to underground tunnel system
            addEvacuee(civilian) {
                if (this.type === 'subway' && this.evacuees && this.evacuees.length < this.maxCapacity) {
                    this.evacuees.push({
                        civilian: civilian,
                        tunnelX: this.x + Math.random() * this.tunnelWidth,
                        tunnelY: this.y + this.tunnelDepth + Math.random() * this.tunnelHeight,
                        enterTime: Date.now()
                    });
                    return true;
                }
                return false;
            }
            
            // Remove evacuee when threat is over
            removeEvacuee(civilian) {
                if (this.evacuees) {
                    this.evacuees = this.evacuees.filter(e => e.civilian !== civilian);
                }
            }
            
            // Rebuild destroyed building
            rebuild() {
                if (!this.destroyed) return;
                
                console.log(`Rebuilding ${this.type} at x=${this.x}`);
                this.destroyed = false;
                this.damaged = false;
                this.health = this.maxHealth;
                this.isRebuilding = false;
                this.rebuildProgress = 0;
                this.fireParticles = [];
                this.smokeParticles = [];
                this.burnIntensity = 0;
                this.isBurning = false;
                this.workersPresent = 0;
                
                playSound('collect'); // Positive sound for rebuilding
                updateStatus(`üèóÔ∏è ${this.type.toUpperCase()} REBUILT! INFRASTRUCTURE RESTORED! üèóÔ∏è`);
            }
            
            // Add work progress from civilians
            addWorkProgress(amount) {
                if (!this.destroyed) return;
                
                if (!this.isRebuilding) {
                    this.isRebuilding = true;
                    this.rebuildProgress = 0;
                }
                
                this.rebuildProgress += amount;
                
                if (this.rebuildProgress >= 100) {
                    this.rebuild();
                }
            }
            
            // Render underground subway station with tubes
            renderTunnels() {
                if (this.type === 'subway' && this.tunnelWidth) {
                    const tunnelStartY = this.y + this.tunnelDepth;
                    const stationDepth = this.tunnelHeight + 20; // Extra depth for full station
                    
                    // === SURFACE ENTRANCE ===
                    // Main entrance structure
                    ctx.fillStyle = '#2C2C2C'; // Dark concrete
                    ctx.fillRect(this.x + this.width * 0.2, this.y + 5, this.width * 0.6, 20);
                    
                    // Entrance doors
                    ctx.fillStyle = '#1A1A1A';
                    ctx.fillRect(this.x + this.width * 0.35, this.y + 5, this.width * 0.1, 15);
                    ctx.fillRect(this.x + this.width * 0.55, this.y + 5, this.width * 0.1, 15);
                    
                    // Entrance stairs
                    ctx.strokeStyle = '#555555';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 8; i++) {
                        const stairY = this.y + 25 + i * 3;
                        ctx.beginPath();
                        ctx.moveTo(this.x + this.width * 0.3, stairY);
                        ctx.lineTo(this.x + this.width * 0.7, stairY);
                        ctx.stroke();
                    }
                    
                    // === UNDERGROUND STATION CHAMBER ===
                    // Main station hall
                    ctx.fillStyle = '#0F0F0F'; // Deep underground darkness
                    ctx.fillRect(this.x - 20, tunnelStartY, this.tunnelWidth + 40, stationDepth);
                    
                    // Station walls with reinforcement
                    ctx.strokeStyle = '#333333';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(this.x - 20, tunnelStartY, this.tunnelWidth + 40, stationDepth);
                    
                    // Platform area
                    ctx.fillStyle = '#222222'; // Platform surface
                    const platformY = tunnelStartY + stationDepth - 25;
                    ctx.fillRect(this.x - 15, platformY, this.tunnelWidth + 30, 20);
                    
                    // Platform edge (yellow safety line)
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(this.x - 15, platformY + 18, this.tunnelWidth + 30, 2);
                    
                    // === SUBWAY TUBES ===
                    // Left tunnel tube
                    const tubeHeight = 15;
                    const leftTubeY = platformY + 20;
                    ctx.fillStyle = '#050505'; // Very dark tunnel
                    ctx.fillRect(0, leftTubeY, this.x + this.tunnelWidth/2, tubeHeight);
                    
                    // Left tube walls
                    ctx.strokeStyle = '#444444';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, leftTubeY);
                    ctx.lineTo(this.x + this.tunnelWidth/2, leftTubeY);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, leftTubeY + tubeHeight);
                    ctx.lineTo(this.x + this.tunnelWidth/2, leftTubeY + tubeHeight);
                    ctx.stroke();
                    
                    // Right tunnel tube
                    ctx.fillStyle = '#050505';
                    ctx.fillRect(this.x + this.tunnelWidth/2, leftTubeY, canvas.width - (this.x + this.tunnelWidth/2), tubeHeight);
                    
                    // Right tube walls
                    ctx.strokeStyle = '#444444';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.x + this.tunnelWidth/2, leftTubeY);
                    ctx.lineTo(canvas.width, leftTubeY);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(this.x + this.tunnelWidth/2, leftTubeY + tubeHeight);
                    ctx.lineTo(canvas.width, leftTubeY + tubeHeight);
                    ctx.stroke();
                    
                    // === SUBWAY TRACKS ===
                    // Rails in both tubes
                    ctx.strokeStyle = '#666666';
                    ctx.lineWidth = 1;
                    // Left rails
                    for (let rail = 0; rail < 2; rail++) {
                        const railY = leftTubeY + tubeHeight - 3 + rail * 1.5;
                        ctx.beginPath();
                        ctx.moveTo(0, railY);
                        ctx.lineTo(this.x + this.tunnelWidth/2, railY);
                        ctx.stroke();
                    }
                    // Right rails  
                    for (let rail = 0; rail < 2; rail++) {
                        const railY = leftTubeY + tubeHeight - 3 + rail * 1.5;
                        ctx.beginPath();
                        ctx.moveTo(this.x + this.tunnelWidth/2, railY);
                        ctx.lineTo(canvas.width, railY);
                        ctx.stroke();
                    }
                    
                    // === STATION LIGHTING ===
                    ctx.fillStyle = '#FFD700'; // Emergency lighting
                    const lightSpacing = 25;
                    for (let i = 0; i < Math.floor(this.tunnelWidth / lightSpacing); i++) {
                        const lightX = this.x - 15 + i * lightSpacing;
                        // Ceiling lights
                        ctx.fillRect(lightX, tunnelStartY + 3, 6, 3);
                        // Platform lights
                        ctx.fillRect(lightX, platformY - 5, 4, 2);
                        
                        // Light glow effects
                        ctx.fillStyle = 'rgba(255, 215, 0, 0.2)';
                        ctx.fillRect(lightX - 8, tunnelStartY + 6, 22, 15);
                        ctx.fillRect(lightX - 6, platformY - 3, 16, 12);
                        ctx.fillStyle = '#FFD700';
                    }
                    
                    // === TUBE LIGHTING ===
                    // Tunnel lights extending into tubes
                    ctx.fillStyle = '#FF6600'; // Orange tunnel lighting
                    for (let x = 0; x < canvas.width; x += 40) {
                        ctx.fillRect(x, leftTubeY + 2, 3, 2);
                        // Dim glow in tubes
                        ctx.fillStyle = 'rgba(255, 102, 0, 0.1)';
                        ctx.fillRect(x - 5, leftTubeY + 4, 13, 8);
                        ctx.fillStyle = '#FF6600';
                    }
                    
                    // === STATION INFRASTRUCTURE ===
                    // Support pillars
                    ctx.fillStyle = '#333333';
                    const pillarWidth = 4;
                    for (let i = 1; i < 4; i++) {
                        const pillarX = this.x + i * (this.tunnelWidth / 4);
                        ctx.fillRect(pillarX, tunnelStartY, pillarWidth, stationDepth - 25);
                    }
                    
                    // Ventilation grates
                    ctx.strokeStyle = '#555555';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 3; i++) {
                        const grateX = this.x + 10 + i * 30;
                        for (let j = 0; j < 5; j++) {
                            ctx.beginPath();
                            ctx.moveTo(grateX, tunnelStartY + 8 + j * 2);
                            ctx.lineTo(grateX + 8, tunnelStartY + 8 + j * 2);
                            ctx.stroke();
                        }
                    }
                    
                    // === EVACUATED CIVILIANS ===
                    // Render civilians on platform and in waiting areas
                    this.evacuees.forEach((evacuee, index) => {
                        const civilian = evacuee.civilian;
                        const glowTime = (Date.now() - evacuee.enterTime) / 1000;
                        
                        // Position civilians on platform and in alcoves
                        let civilianX, civilianY;
                        if (index < 15) {
                            // Main platform area
                            civilianX = this.x - 10 + (index * 8) % (this.tunnelWidth + 20);
                            civilianY = platformY + 5;
                        } else {
                            // Waiting areas along walls
                            civilianX = this.x - 15 + Math.random() * (this.tunnelWidth + 30);
                            civilianY = tunnelStartY + 15 + Math.random() * 20;
                        }
                        
                        // Civilian body with emergency lighting
                        const size = civilian.age === 'child' ? 3 : civilian.age === 'elder' ? 4 : 5;
                        ctx.fillStyle = '#FFB366'; // Warm emergency light on skin
                        ctx.fillRect(civilianX, civilianY, size, size);
                        
                        // Safety indicator (green glow showing they're protected)
                        ctx.fillStyle = `rgba(0, 255, 0, ${0.15 + Math.sin(glowTime * 1.5) * 0.1})`;
                        ctx.fillRect(civilianX - 1, civilianY - 1, size + 2, size + 2);
                        
                        // Age-specific indicators
                        if (civilian.age === 'child') {
                            ctx.fillStyle = '#87CEEB'; // Light blue for children
                            ctx.fillRect(civilianX + 1, civilianY - 2, 1, 1);
                        } else if (civilian.age === 'elder') {
                            ctx.fillStyle = '#D3D3D3'; // Light gray for elderly
                            ctx.fillRect(civilianX + 1, civilianY - 2, 1, 1);
                        }
                    });
                    
                    // === STATUS DISPLAYS ===
                    // Capacity indicator with better visibility
                    if (this.evacuees && this.evacuees.length > 0) {
                        ctx.fillStyle = '#00FF00';
                        ctx.font = 'bold 10px Arial';
                        ctx.fillText(`SHELTER: ${this.evacuees.length}/${this.maxCapacity}`, 
                                   this.x - 15, tunnelStartY - 5);
                        
                        // Capacity bar
                        const barWidth = 40;
                        const fillWidth = (this.evacuees.length / this.maxCapacity) * barWidth;
                        ctx.fillStyle = '#333333';
                        ctx.fillRect(this.x + 50, tunnelStartY - 10, barWidth, 6);
                        ctx.fillStyle = this.evacuees.length < this.maxCapacity ? '#00FF00' : '#FF0000';
                        ctx.fillRect(this.x + 50, tunnelStartY - 10, fillWidth, 6);
                    }
                    
                    // Emergency status light
                    const statusLight = this.evacuees && this.evacuees.length > 0;
                    ctx.fillStyle = statusLight ? '#00FF00' : '#333333';
                    ctx.fillRect(this.x + this.width * 0.1, this.y + 2, 4, 4);
                }
            }
        }

        // Mobile SAM Command Intercept HQ
        class Tank {
            constructor() {
                this.x = canvas.width / 2;
                this.y = canvas.height - 215; // Adjusted for new ground level
                this.width = 60;
                this.height = 40;
                this.speed = 4; // Slightly slower, more realistic for heavy vehicle
                this.cannon = { angle: -Math.PI/2, length: 35 };
                this.color = '#1a4a1a';
                this.radarAngle = 0;
                this.radarSweep = 0.05;
                this.targetLocked = false;
                this.lockTarget = null;
                
                // Upgrade system properties
                this.maxBullets = 6; // Can be upgraded
                this.radarRange = 200; // Can be upgraded
                this.fireRate = 0.3; // Can be upgraded (lower = faster)
                this.lastShot = 0;
            }
            
            update() {
                // Movement
                if (keys['ArrowLeft'] && this.x > this.width/2) {
                    this.x -= this.speed;
                }
                if (keys['ArrowRight'] && this.x < canvas.width - this.width/2) {
                    this.x += this.speed;
                }
                
                // Update position to follow ground contours
                if (groundHeightMap) {
                    this.y = groundHeightMap.getHeightAt(this.x) - this.height/2;
                }
                
                // Radar sweep
                this.radarAngle += this.radarSweep;
                
                // Advanced targeting system - lock onto nearest threat
                if (enemies.length > 0) {
                    const nearestEnemy = enemies.reduce((closest, enemy) => {
                        const distToCurrent = Math.abs(enemy.x - this.x) + Math.abs(enemy.y - this.y);
                        const distToClosest = Math.abs(closest.x - this.x) + Math.abs(closest.y - this.y);
                        return distToCurrent < distToClosest ? enemy : closest;
                    });
                    
                    // Target tracking with lead calculation
                    const dx = nearestEnemy.x - this.x;
                    const dy = nearestEnemy.y - this.y;
                    
                    // Lead the target based on its movement
                    const leadX = dx + (nearestEnemy.targetX - nearestEnemy.x) * 2;
                    const leadY = dy + nearestEnemy.speed * 10;
                    
                    this.cannon.angle = Math.atan2(leadY, leadX);
                    this.targetLocked = true;
                    this.lockTarget = nearestEnemy;
                } else {
                    this.targetLocked = false;
                    this.lockTarget = null;
                }
            }
            
            shoot() {
                // Check fire rate limit
                const now = Date.now();
                if (now - this.lastShot < this.fireRate * 1000) {
                    return; // Too soon to fire again
                }
                
                // Check maximum bullets limit
                if (bullets.length >= this.maxBullets) {
                    return; // Too many bullets on screen
                }
                
                const cannonTipX = this.x + Math.cos(this.cannon.angle) * this.cannon.length;
                const cannonTipY = this.y + Math.sin(this.cannon.angle) * this.cannon.length;
                
                // Fire advanced interceptor missile instead of bullet
                bullets.push(new InterceptorMissile(cannonTipX, cannonTipY, this.cannon.angle, this.lockTarget));
                this.lastShot = now;
                playSound('shoot');
            }
            
            render() {
                // Main vehicle body (armored command center)
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - this.width/2, this.y - this.height/2, this.width, this.height);
                
                // Command module (upper section)
                ctx.fillStyle = '#2a5a2a';
                ctx.fillRect(this.x - 25, this.y - this.height/2 - 8, 50, 8);
                
                // Radar dish
                ctx.save();
                ctx.translate(this.x - 15, this.y - this.height/2 - 12);
                ctx.rotate(this.radarAngle);
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, 8, 0, Math.PI);
                ctx.stroke();
                ctx.restore();
                
                // Missile launcher system
                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                const cannonEndX = this.x + Math.cos(this.cannon.angle) * this.cannon.length;
                const cannonEndY = this.y + Math.sin(this.cannon.angle) * this.cannon.length;
                ctx.lineTo(cannonEndX, cannonEndY);
                ctx.stroke();
                
                // Launcher tip
                ctx.fillStyle = '#666666';
                ctx.beginPath();
                ctx.arc(cannonEndX, cannonEndY, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Vehicle outline
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x - this.width/2, this.y - this.height/2, this.width, this.height);
                
                // Track systems
                ctx.fillStyle = '#333333';
                ctx.fillRect(this.x - this.width/2 - 2, this.y + this.height/2 - 5, this.width + 4, 8);
                
                // Communication antennas
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(this.x + 20, this.y - this.height/2);
                ctx.lineTo(this.x + 20, this.y - this.height/2 - 15);
                ctx.moveTo(this.x + 25, this.y - this.height/2);
                ctx.lineTo(this.x + 25, this.y - this.height/2 - 10);
                ctx.stroke();
                
                // Target lock indicator
                if (this.targetLocked && this.lockTarget) {
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(this.lockTarget.x, this.lockTarget.y, 30, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Lock text
                    ctx.fillStyle = '#ff0000';
                    ctx.font = '12px Arial';
                    ctx.fillText('TARGET LOCKED', this.lockTarget.x - 40, this.lockTarget.y - 40);
                }
            }
        }

        // Construction Site System
        class ConstructionSite {
            constructor(x, buildingType = 'house') {
                this.x = x;
                this.y = groundHeightMap ? groundHeightMap.getHeightAt(x) : canvas.height - 200;
                this.buildingType = buildingType;
                this.progress = 0;
                this.maxProgress = 100;
                this.workersPresent = [];
                this.completed = false;
                this.width = 40;
                this.height = 30;
            }
            
            addWorkProgress(amount) {
                if (this.completed) return;
                
                this.progress += amount;
                
                if (this.progress >= this.maxProgress) {
                    this.complete();
                }
            }
            
            complete() {
                if (this.completed) return;
                
                this.completed = true;
                // Create new building at this location
                const newBuilding = new GroundBuilding(this.x, this.buildingType, 'normal');
                groundBuildings.push(newBuilding);
                
                playSound('collect');
                updateStatus(`üèóÔ∏è NEW ${this.buildingType.toUpperCase()} COMPLETED! CITY EXPANDING! üèóÔ∏è`);
            }
            
            render() {
                if (this.completed) return;
                
                const progressRatio = this.progress / this.maxProgress;
                
                // Construction scaffolding
                ctx.strokeStyle = '#ff8800';
                ctx.lineWidth = 2;
                
                // Vertical poles
                ctx.beginPath();
                ctx.moveTo(this.x - 15, this.y);
                ctx.lineTo(this.x - 15, this.y - this.height);
                ctx.moveTo(this.x + 15, this.y);
                ctx.lineTo(this.x + 15, this.y - this.height);
                ctx.stroke();
                
                // Horizontal beams
                for (let i = 0; i < 3; i++) {
                    const beamY = this.y - (this.height / 3) * (i + 1);
                    ctx.beginPath();
                    ctx.moveTo(this.x - 15, beamY);
                    ctx.lineTo(this.x + 15, beamY);
                    ctx.stroke();
                }
                
                // Building under construction
                const builtHeight = this.height * progressRatio;
                ctx.fillStyle = '#666666';
                ctx.fillRect(this.x - 12, this.y - builtHeight, 24, builtHeight);
                
                // Progress bar
                ctx.fillStyle = '#333333';
                ctx.fillRect(this.x - 20, this.y + 5, 40, 8);
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(this.x - 20, this.y + 5, 40 * progressRatio, 8);
                
                // Progress text
                ctx.fillStyle = '#ffffff';
                ctx.font = '8px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(Math.floor(progressRatio * 100) + '%', this.x, this.y + 20);
                
                // Construction sign
                ctx.fillStyle = '#ffa500';
                ctx.fillRect(this.x - 18, this.y + 25, 36, 12);
                ctx.fillStyle = '#000000';
                ctx.font = '7px Arial';
                ctx.fillText('UNDER CONSTRUCTION', this.x, this.y + 33);
            }
        }

        // Fire Brigade Emergency Response System
        class FireTruck {
            constructor() {
                this.x = -80; // Start off-screen
                this.y = canvas.height - 50;
                this.width = 60;
                this.height = 30;
                this.speed = 3;
                this.targetBuilding = null;
                this.isDeployed = false;
                this.waterSupply = 100;
                this.maxWaterSupply = 100;
                this.extinguishingRange = 80;
                this.activeFirefighters = [];
                this.sirens = true;
                this.sirenTime = 0;
                this.isExtinguishing = false;
                this.arrivalTime = null;
            }
            
            findBurningBuilding() {
                let closestFire = null;
                let closestDistance = Infinity;
                
                groundBuildings.forEach(building => {
                    if (building.isBurning && !building.destroyed) {
                        const distance = Math.abs(building.x - this.x);
                        if (distance < closestDistance) {
                            closestDistance = distance;
                            closestFire = building;
                        }
                    }
                });
                
                return closestFire;
            }
            
            update() {
                this.sirenTime += 0.1;
                
                // Update ground position using height map
                if (groundHeightMap) {
                    this.y = groundHeightMap.getHeightAt(this.x) - 15; // Position on ground surface
                } else {
                    this.y = canvas.height - 50; // Fallback position
                }
                
                // Always find the closest fire if not currently extinguishing
                if (!this.targetBuilding || !this.targetBuilding.isBurning || this.targetBuilding.destroyed) {
                    this.targetBuilding = this.findBurningBuilding();
                    this.isDeployed = false;
                    this.recallFirefighters();
                }
                
                if (this.targetBuilding) {
                    // Move toward target building
                    const dx = this.targetBuilding.x - this.x;
                    const distanceToFire = Math.abs(dx);
                    
                    if (distanceToFire > this.extinguishingRange) {
                        // Drive to building on ground
                        this.x += dx > 0 ? this.speed : -this.speed;
                        this.x = Math.max(40, Math.min(canvas.width - 40, this.x));
                        this.isDeployed = false;
                        this.isExtinguishing = false;
                    } else {
                        // Deploy firefighting operations
                        if (!this.isDeployed) {
                            this.isDeployed = true;
                            this.arrivalTime = Date.now();
                            this.deployFirefighters();
                        }
                        
                        // Actively extinguish fire with water - STAY UNTIL COMPLETE
                        if (this.waterSupply > 0 && this.targetBuilding.isBurning) {
                            this.extinguishFire();
                        } else if (!this.targetBuilding.isBurning) {
                            // Fire is OUT - move to next fire
                            console.log('Fire extinguished! Moving to next fire...');
                            this.targetBuilding = null;
                            this.isDeployed = false;
                            this.isExtinguishing = false;
                            this.recallFirefighters();
                        } else if (this.waterSupply <= 0) {
                            // Out of water - need to refill
                            console.log('Fire truck out of water!');
                            this.waterSupply = this.maxWaterSupply;
                        }
                    }
                } else {
                    // No fires - return to station
                    if (this.x > 50) {
                        this.x -= this.speed * 0.5; // Return to left side
                    } else if (this.x < -80) {
                        // Off screen left - remove truck
                    }
                }
                
                // Update firefighters
                this.activeFirefighters.forEach(firefighter => firefighter.update());
                this.activeFirefighters = this.activeFirefighters.filter(ff => ff.active);
            }
            
            deployFirefighters() {
                // Deploy 3 firefighters
                for (let i = 0; i < 3; i++) {
                    const firefighter = new Firefighter(
                        this.x + (i - 1) * 15,
                        this.y,
                        this.targetBuilding
                    );
                    this.activeFirefighters.push(firefighter);
                }
            }
            
            recallFirefighters() {
                this.activeFirefighters.forEach(ff => ff.recall());
            }
            
            extinguishFire() {
                if (this.targetBuilding && this.waterSupply > 0) {
                    this.isExtinguishing = true;
                    this.waterSupply -= 1.2; // Use water aggressively
                    
                    // Very effective fire suppression - FOCUS ON COMPLETE EXTINGUISHMENT
                    if (this.targetBuilding.burnIntensity > 0) {
                        this.targetBuilding.burnIntensity -= 0.08; // Much faster intensity reduction
                        
                        // Remove most fire particles immediately when truck is actively spraying
                        if (this.targetBuilding.fireParticles) {
                            // Remove 70% of fire particles each frame for rapid suppression
                            const removeCount = Math.floor(this.targetBuilding.fireParticles.length * 0.7);
                            for (let i = 0; i < removeCount; i++) {
                                this.targetBuilding.fireParticles.pop();
                            }
                        }
                        
                        // Also reduce smoke when extinguishing
                        if (this.targetBuilding.smokeParticles) {
                            const smokeRemoveCount = Math.floor(this.targetBuilding.smokeParticles.length * 0.5);
                            for (let i = 0; i < smokeRemoveCount; i++) {
                                this.targetBuilding.smokeParticles.pop();
                            }
                        }
                    }
                    
                    // If fire intensity drops to zero OR no fire particles left, fire is OUT
                    if (this.targetBuilding.burnIntensity <= 0 || 
                        !this.targetBuilding.fireParticles || 
                        this.targetBuilding.fireParticles.length === 0) {
                        this.targetBuilding.isBurning = false;
                        this.targetBuilding.burnIntensity = 0;
                        this.targetBuilding.fireParticles = [];
                        console.log('üöí Fire completely extinguished by fire truck!');
                        updateStatus(`üöí FIRE EXTINGUISHED! Fire brigade saved ${this.targetBuilding.type}!`);
                    }
                } else {
                    this.isExtinguishing = false;
                }
            }
            
            render() {
                // Fire truck body
                ctx.fillStyle = '#CC0000'; // Fire engine red
                ctx.fillRect(this.x - this.width/2, this.y - this.height/2, this.width, this.height);
                
                // Cabin
                ctx.fillStyle = '#990000';
                ctx.fillRect(this.x - this.width/2, this.y - this.height/2, 20, this.height);
                
                // Equipment compartments
                ctx.fillStyle = '#FF3333';
                ctx.fillRect(this.x - this.width/2 + 20, this.y - this.height/2 + 5, 35, 8);
                ctx.fillRect(this.x - this.width/2 + 20, this.y - this.height/2 + 17, 35, 8);
                
                // Ladder on top
                ctx.strokeStyle = '#FFFF00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.x - 20, this.y - this.height/2 - 5);
                ctx.lineTo(this.x + 20, this.y - this.height/2 - 5);
                ctx.stroke();
                
                // Wheels
                ctx.fillStyle = '#333333';
                ctx.beginPath();
                ctx.arc(this.x - 15, this.y + this.height/2 - 5, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(this.x + 15, this.y + this.height/2 - 5, 6, 0, Math.PI * 2);
                ctx.fill();
                
                // Emergency lights (flashing)
                if (this.sirens && Math.floor(this.sirenTime * 4) % 2 === 0) {
                    ctx.fillStyle = '#0000FF';
                    ctx.fillRect(this.x - 25, this.y - this.height/2 - 3, 4, 4);
                    ctx.fillStyle = '#FF0000';
                    ctx.fillRect(this.x + 21, this.y - this.height/2 - 3, 4, 4);
                }
                
                // Water stream if extinguishing
                if (this.isExtinguishing && this.targetBuilding) {
                    ctx.strokeStyle = '#4169E1'; // Royal blue water
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(this.x + 25, this.y - 5);
                    ctx.lineTo(this.targetBuilding.x, this.targetBuilding.y - this.targetBuilding.height/2);
                    ctx.stroke();
                    
                    // Water splash effect
                    ctx.fillStyle = 'rgba(65, 105, 225, 0.3)';
                    ctx.beginPath();
                    ctx.arc(this.targetBuilding.x, this.targetBuilding.y - this.targetBuilding.height/2, 15, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Water supply indicator
                if (this.isDeployed) {
                    const barWidth = 30;
                    const barHeight = 4;
                    const waterPercent = this.waterSupply / this.maxWaterSupply;
                    
                    ctx.fillStyle = '#333333';
                    ctx.fillRect(this.x - barWidth/2, this.y - this.height/2 - 15, barWidth, barHeight);
                    ctx.fillStyle = waterPercent > 0.5 ? '#0066CC' : waterPercent > 0.2 ? '#FFAA00' : '#CC0000';
                    ctx.fillRect(this.x - barWidth/2, this.y - this.height/2 - 15, barWidth * waterPercent, barHeight);
                }
                
                // Render firefighters
                this.activeFirefighters.forEach(firefighter => firefighter.render());
            }
        }

        class Firefighter {
            constructor(x, y, targetBuilding) {
                this.x = x;
                this.y = y;
                this.targetBuilding = targetBuilding;
                this.speed = 1.5;
                this.active = true;
                this.isExtinguishing = false;
                this.hoseRange = 60;
                this.position = 'moving'; // 'moving', 'fighting', 'returning'
                this.equipmentType = Math.random() > 0.5 ? 'hose' : 'axe';
            }
            
            update() {
                // Update ground position
                if (groundHeightMap) {
                    this.y = groundHeightMap.getHeightAt(this.x) - 5; // Position on ground
                }
                
                if (!this.targetBuilding || this.targetBuilding.destroyed) {
                    this.recall();
                    return;
                }
                
                if (this.position === 'moving') {
                    // Move toward building
                    const dx = this.targetBuilding.x - this.x;
                    const distance = Math.abs(dx);
                    
                    if (distance > this.hoseRange) {
                        this.x += dx > 0 ? this.speed : -this.speed;
                    } else {
                        this.position = 'fighting';
                    }
                } else if (this.position === 'fighting') {
                    // Fight fire actively
                    this.isExtinguishing = true;
                    
                    if (this.equipmentType === 'hose' && this.targetBuilding.isBurning) {
                        // Hose firefighter - water suppression
                        if (Math.random() < 0.2) { // 20% chance per frame - more effective
                            if (this.targetBuilding.fireParticles && this.targetBuilding.fireParticles.length > 0) {
                                // Remove multiple fire particles for water effectiveness
                                for (let i = 0; i < 3 && this.targetBuilding.fireParticles.length > 0; i++) {
                                    this.targetBuilding.fireParticles.pop();
                                }
                                
                                // Also reduce burn intensity
                                this.targetBuilding.burnIntensity = Math.max(0, this.targetBuilding.burnIntensity - 0.01);
                            }
                        }
                    } else if (this.equipmentType === 'axe' && this.targetBuilding.isBurning) {
                        // Axe firefighter - structural support and debris removal
                        if (Math.random() < 0.05) { // 5% chance per frame
                            if (this.targetBuilding.smokeParticles && this.targetBuilding.smokeParticles.length > 0) {
                                this.targetBuilding.smokeParticles.pop(); // Clear smoke/debris
                            }
                        }
                    }
                    
                    // Check if fire is out
                    if (!this.targetBuilding.isBurning) {
                        this.position = 'returning';
                        this.isExtinguishing = false;
                    }
                }
            }
            
            recall() {
                this.position = 'returning';
                this.isExtinguishing = false;
                this.active = false;
            }
            
            render() {
                if (!this.active) return;
                
                // Firefighter body
                ctx.fillStyle = '#FFD700'; // Yellow firefighter gear
                ctx.fillRect(this.x - 3, this.y - 8, 6, 8);
                
                // Helmet
                ctx.fillStyle = '#CC0000';
                ctx.fillRect(this.x - 2, this.y - 10, 4, 3);
                
                // Equipment
                if (this.equipmentType === 'hose' && this.isExtinguishing && this.targetBuilding) {
                    // Water hose stream - thicker and more visible
                    ctx.strokeStyle = '#4169E1';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y - 5);
                    ctx.lineTo(this.targetBuilding.x, this.targetBuilding.y - this.targetBuilding.height + 10);
                    ctx.stroke();
                    
                    // Water spray effect at impact
                    ctx.fillStyle = 'rgba(65, 105, 225, 0.5)';
                    ctx.beginPath();
                    ctx.arc(this.targetBuilding.x, this.targetBuilding.y - this.targetBuilding.height + 10, 12, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Water droplets
                    for (let i = 0; i < 5; i++) {
                        const dropX = this.targetBuilding.x + (Math.random() - 0.5) * 20;
                        const dropY = this.targetBuilding.y - this.targetBuilding.height + 10 + (Math.random() - 0.5) * 15;
                        ctx.fillStyle = 'rgba(65, 105, 225, 0.7)';
                        ctx.beginPath();
                        ctx.arc(dropX, dropY, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                } else if (this.equipmentType === 'hose') {
                    // Show hose when not actively spraying
                    ctx.strokeStyle = '#333333';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y - 5);
                    ctx.lineTo(this.x + 8, this.y - 3);
                    ctx.stroke();
                    
                } else if (this.equipmentType === 'axe') {
                    // Fire axe
                    ctx.strokeStyle = '#8B4513';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.x + 3, this.y - 8);
                    ctx.lineTo(this.x + 3, this.y - 2);
                    ctx.stroke();
                    
                    ctx.fillStyle = '#C0C0C0';
                    ctx.fillRect(this.x + 2, this.y - 9, 3, 2);
                }
                
                // Action indicator
                if (this.isExtinguishing) {
                    ctx.fillStyle = 'rgba(0, 0, 255, 0.3)';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y - 5, 8, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // Fire Brigade Management System
        class FireBrigade {
            constructor() {
                this.fireTrucks = [];
                this.responseTime = 0;
                this.isActive = false;
                this.emergencyLevel = 0;
            }
            
            update() {
                // Check for fires that need response
                let activeFires = 0;
                groundBuildings.forEach(building => {
                    if (building.isBurning && !building.destroyed) {
                        activeFires++;
                    }
                });
                
                this.emergencyLevel = activeFires;
                
                // Deploy fire trucks based on emergency level
                if (activeFires > 0 && this.fireTrucks.length === 0) {
                    this.deployTrucks(Math.min(activeFires, 2)); // Max 2 trucks
                }
                
                // Update all fire trucks
                this.fireTrucks.forEach(truck => truck.update());
                
                // Remove trucks that have completed their mission
                this.fireTrucks = this.fireTrucks.filter(truck => {
                    return truck.x > -100 && truck.x < canvas.width + 100;
                });
                
                this.responseTime++;
            }
            
            deployTrucks(count) {
                for (let i = 0; i < count; i++) {
                    const truck = new FireTruck();
                    truck.y = canvas.height - 50 - (i * 40); // Stagger positions
                    this.fireTrucks.push(truck);
                }
                this.isActive = true;
            }
            
            render() {
                this.fireTrucks.forEach(truck => truck.render());
                
                // Emergency status indicator
                if (this.emergencyLevel > 0) {
                    ctx.fillStyle = '#FF0000';
                    ctx.font = 'bold 12px Arial';
                    ctx.fillText(`üöí FIRE RESPONSE: ${this.emergencyLevel} ACTIVE`, 10, canvas.height - 10);
                }
            }
        }

        // Defense Upgrade System using Picomino Points
        class DefenseUpgradeSystem {
            constructor() {
                this.upgrades = {
                    extraTank: { cost: 15, owned: 0, maxLevel: 3, name: 'Extra SAM Tank' },
                    rocketCapacity: { cost: 10, owned: 0, maxLevel: 5, name: 'Rocket Capacity' },
                    shieldGenerator: { cost: 20, owned: 0, maxLevel: 2, name: 'Shield Generator' },
                    counterMissiles: { cost: 12, owned: 0, maxLevel: 4, name: 'Counter-Missiles' },
                    radarUpgrade: { cost: 8, owned: 0, maxLevel: 3, name: 'Radar Enhancement' },
                    fireSupport: { cost: 18, owned: 0, maxLevel: 2, name: 'Fire Support' },
                    bunkerArmor: { cost: 14, owned: 0, maxLevel: 3, name: 'Bunker Armor' },
                    rapidFire: { cost: 16, owned: 0, maxLevel: 4, name: 'Rapid Fire System' }
                };
                
                this.extraTanks = []; // Additional tanks purchased
                this.shieldActive = false;
                this.shieldEnergy = 0;
                this.maxShieldEnergy = 100;
                this.counterMissileReloads = 0;
                this.showUpgradeMenu = false;
                this.menuTransition = 0;
            }
            
            // Award points when player scores in picomino game
            awardPoints(points) {
                gameState.defensePoints += points;
                gameState.totalPointsEarned += points;
                console.log(`Defense points awarded: ${points}. Total: ${gameState.defensePoints}`);
            }
            
            // Check if upgrade is affordable
            canAfford(upgradeKey) {
                const upgrade = this.upgrades[upgradeKey];
                return gameState.defensePoints >= upgrade.cost && upgrade.owned < upgrade.maxLevel;
            }
            
            // Purchase upgrade
            purchaseUpgrade(upgradeKey) {
                if (this.canAfford(upgradeKey)) {
                    const upgrade = this.upgrades[upgradeKey];
                    gameState.defensePoints -= upgrade.cost;
                    upgrade.owned++;
                    
                    this.applyUpgrade(upgradeKey);
                    console.log(`Purchased ${upgrade.name}. Level: ${upgrade.owned}`);
                    return true;
                }
                return false;
            }
            
            // Apply upgrade effects
            applyUpgrade(upgradeKey) {
                switch(upgradeKey) {
                    case 'extraTank':
                        this.deployExtraTank();
                        break;
                    case 'rocketCapacity':
                        // Increase bullet capacity
                        tank.maxBullets = 6 + this.upgrades.rocketCapacity.owned * 2;
                        break;
                    case 'shieldGenerator':
                        this.maxShieldEnergy = 100 + this.upgrades.shieldGenerator.owned * 50;
                        this.shieldEnergy = this.maxShieldEnergy;
                        break;
                    case 'counterMissiles':
                        this.counterMissileReloads += 3;
                        break;
                    case 'radarUpgrade':
                        tank.radarRange = 200 + this.upgrades.radarUpgrade.owned * 50;
                        break;
                    case 'fireSupport':
                        // Enhanced firefighting
                        if (fireBrigade) {
                            fireBrigade.responseEfficiency = 1 + this.upgrades.fireSupport.owned * 0.5;
                        }
                        break;
                    case 'bunkerArmor':
                        // Increase building health
                        groundBuildings.forEach(building => {
                            if (building.type === 'subway') {
                                building.maxHealth += 2;
                                building.health = building.maxHealth;
                            }
                        });
                        break;
                    case 'rapidFire':
                        tank.fireRate = Math.max(0.1, 0.3 - this.upgrades.rapidFire.owned * 0.05);
                        break;
                }
            }
            
            deployExtraTank() {
                const newTank = new Tank();
                newTank.x = 150 + this.extraTanks.length * 200;
                newTank.y = canvas.height - 215;
                newTank.color = '#2a5a2a'; // Darker green for extra tanks
                newTank.isExtraTank = true;
                newTank.ai = new TankAI(newTank);
                this.extraTanks.push(newTank);
            }
            
            update() {
                // Update shield energy
                if (this.upgrades.shieldGenerator.owned > 0) {
                    if (this.shieldEnergy < this.maxShieldEnergy) {
                        this.shieldEnergy += 0.5; // Regenerate shield
                    }
                }
                
                // Update extra tanks
                this.extraTanks.forEach(tank => {
                    tank.update();
                    if (tank.ai) tank.ai.update();
                });
                
                // Menu animation
                if (this.showUpgradeMenu) {
                    this.menuTransition = Math.min(1, this.menuTransition + 0.05);
                } else {
                    this.menuTransition = Math.max(0, this.menuTransition - 0.05);
                }
            }
            
            toggleUpgradeMenu() {
                this.showUpgradeMenu = !this.showUpgradeMenu;
            }
            
            render() {
                // Render extra tanks
                this.extraTanks.forEach(tank => tank.render());
                
                // Render shield if active
                if (this.upgrades.shieldGenerator.owned > 0 && this.shieldEnergy > 0) {
                    this.renderShield();
                }
                
                // Render upgrade menu if visible
                if (this.menuTransition > 0) {
                    this.renderUpgradeMenu();
                }
                
                // Render defense points display
                this.renderPointsDisplay();
            }
            
            renderShield() {
                const alpha = this.shieldEnergy / this.maxShieldEnergy * 0.3;
                ctx.fillStyle = `rgba(0, 255, 255, ${alpha})`;
                ctx.beginPath();
                ctx.arc(tank.x, tank.y, 80, 0, Math.PI * 2);
                ctx.fill();
                
                // Shield edge effect
                ctx.strokeStyle = `rgba(0, 255, 255, ${alpha * 2})`;
                ctx.lineWidth = 3;
                ctx.stroke();
            }
            
            renderUpgradeMenu() {
                const menuWidth = 400;
                const menuHeight = 500;
                const menuX = canvas.width - menuWidth - 20;
                const menuY = 50;
                
                // Slide animation
                const slideX = menuX + (1 - this.menuTransition) * menuWidth;
                
                // Menu background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(slideX, menuY, menuWidth, menuHeight);
                
                // Menu border
                ctx.strokeStyle = '#00FFFF';
                ctx.lineWidth = 2;
                ctx.strokeRect(slideX, menuY, menuWidth, menuHeight);
                
                // Title
                ctx.fillStyle = '#00FFFF';
                ctx.font = 'bold 18px Arial';
                ctx.fillText('DEFENSE UPGRADES', slideX + 10, menuY + 30);
                
                // Points display
                ctx.fillStyle = '#FFD700';
                ctx.font = '14px Arial';
                ctx.fillText(`Defense Points: ${gameState.defensePoints}`, slideX + 10, menuY + 55);
                
                // Upgrade list
                let yOffset = 80;
                Object.entries(this.upgrades).forEach(([key, upgrade]) => {
                    const canBuy = this.canAfford(key);
                    const maxed = upgrade.owned >= upgrade.maxLevel;
                    
                    // Upgrade item background
                    ctx.fillStyle = maxed ? 'rgba(100, 100, 100, 0.3)' : 
                                   canBuy ? 'rgba(0, 255, 0, 0.1)' : 'rgba(255, 0, 0, 0.1)';
                    ctx.fillRect(slideX + 10, menuY + yOffset - 15, menuWidth - 20, 45);
                    
                    // Upgrade name
                    ctx.fillStyle = maxed ? '#888888' : canBuy ? '#00FF00' : '#FFFFFF';
                    ctx.font = '12px Arial';
                    ctx.fillText(upgrade.name, slideX + 15, menuY + yOffset);
                    
                    // Level and cost
                    ctx.fillStyle = '#CCCCCC';
                    ctx.font = '10px Arial';
                    ctx.fillText(`Level: ${upgrade.owned}/${upgrade.maxLevel}`, slideX + 15, menuY + yOffset + 15);
                    
                    if (!maxed) {
                        ctx.fillText(`Cost: ${upgrade.cost} pts`, slideX + 200, menuY + yOffset + 15);
                        
                        // Buy button
                        ctx.fillStyle = canBuy ? '#00AA00' : '#AA0000';
                        ctx.fillRect(slideX + 320, menuY + yOffset - 10, 60, 20);
                        ctx.fillStyle = '#FFFFFF';
                        ctx.font = '10px Arial';
                        ctx.fillText('BUY', slideX + 340, menuY + yOffset + 5);
                    } else {
                        ctx.fillStyle = '#888888';
                        ctx.fillText('MAXED', slideX + 320, menuY + yOffset + 5);
                    }
                    
                    yOffset += 55;
                });
                
                // Controls
                ctx.fillStyle = '#FFFF00';
                ctx.font = '12px Arial';
                ctx.fillText('Press U to toggle menu', slideX + 10, menuY + menuHeight - 20);
                ctx.fillText('Click BUY to purchase upgrades', slideX + 10, menuY + menuHeight - 5);
            }
            
            renderPointsDisplay() {
                // Top-right corner display
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(canvas.width - 150, 10, 140, 40);
                
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 1;
                ctx.strokeRect(canvas.width - 150, 10, 140, 40);
                
                ctx.fillStyle = '#FFD700';
                ctx.font = 'bold 12px Arial';
                ctx.fillText('Defense Points:', canvas.width - 145, 25);
                ctx.fillText(`${gameState.defensePoints}`, canvas.width - 145, 40);
                
                ctx.fillStyle = '#CCCCCC';
                ctx.font = '10px Arial';
                ctx.fillText('Press U for upgrades', canvas.width - 145, 50);
            }
        }

        // AI for Extra Tanks
        class TankAI {
            constructor(tank) {
                this.tank = tank;
                this.target = null;
                this.lastShot = 0;
            }
            
            update() {
                // Find nearest enemy
                let nearestEnemy = null;
                let nearestDistance = Infinity;
                
                enemies.forEach(enemy => {
                    const distance = Math.sqrt((enemy.x - this.tank.x) ** 2 + (enemy.y - this.tank.y) ** 2);
                    if (distance < nearestDistance) {
                        nearestDistance = distance;
                        nearestEnemy = enemy;
                    }
                });
                
                if (nearestEnemy) {
                    // Aim at enemy
                    const angle = Math.atan2(nearestEnemy.y - this.tank.y, nearestEnemy.x - this.tank.x);
                    this.tank.cannon.angle = angle - Math.PI/2;
                    
                    // Shoot if ready
                    const now = Date.now();
                    if (now - this.lastShot > 1000) { // 1 second cooldown
                        this.shoot();
                        this.lastShot = now;
                    }
                }
            }
            
            shoot() {
                const bulletX = this.tank.x + Math.sin(this.tank.cannon.angle + Math.PI/2) * this.tank.cannon.length;
                const bulletY = this.tank.y + Math.cos(this.tank.cannon.angle + Math.PI/2) * this.tank.cannon.length;
                
                bullets.push(new InterceptorMissile(
                    bulletX, bulletY, 
                    this.tank.cannon.angle + Math.PI/2, 
                    this.target
                ));
            }
        }

        // Advanced Interceptor Missile System
        class InterceptorMissile {
            constructor(x, y, angle, target) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.speed = 12;
                this.width = 6;
                this.height = 12;
                this.active = true;
                this.target = target;
                this.guidanceSystem = true;
                this.thrustTrail = [];
                this.homingRange = 150;
            }
            
            update() {
                // Advanced guidance system - home in on target if within range
                if (this.target && this.target.active && this.guidanceSystem) {
                    const dx = this.target.x - this.x;
                    const dy = this.target.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < this.homingRange) {
                        // Course correction toward target
                        const targetAngle = Math.atan2(dy, dx);
                        const angleDiff = targetAngle - this.angle;
                        
                        // Smooth turning (realistic missile guidance)
                        if (Math.abs(angleDiff) > 0.1) {
                            this.angle += Math.sign(angleDiff) * 0.08;
                        }
                    }
                }
                
                // Movement
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
                
                // Add thrust trail effect
                this.thrustTrail.push({x: this.x, y: this.y, life: 15});
                this.thrustTrail = this.thrustTrail.filter(trail => trail.life-- > 0);
                
                // Remove if off screen
                if (this.y < -50 || this.x < -50 || this.x > canvas.width + 50 || this.y > canvas.height + 50) {
                    this.active = false;
                }
            }
            
            render() {
                // Render thrust trail
                this.thrustTrail.forEach((trail, index) => {
                    const alpha = trail.life / 15;
                    ctx.fillStyle = `rgba(255, 100, 0, ${alpha * 0.8})`;
                    ctx.beginPath();
                    ctx.arc(trail.x, trail.y, 2 * alpha, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // Missile body
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(this.x - this.width/2, this.y - this.height/2, this.width, this.height);
                
                // Missile nose cone
                ctx.fillStyle = '#ff4444';
                const noseX = this.x + Math.cos(this.angle) * (this.height/2);
                const noseY = this.y + Math.sin(this.angle) * (this.height/2);
                ctx.beginPath();
                ctx.arc(noseX, noseY, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Guidance fins
                ctx.strokeStyle = '#cccccc';
                ctx.lineWidth = 1;
                const finLength = 4;
                const perpAngle1 = this.angle + Math.PI/2;
                const perpAngle2 = this.angle - Math.PI/2;
                
                ctx.beginPath();
                ctx.moveTo(this.x + Math.cos(perpAngle1) * finLength, this.y + Math.sin(perpAngle1) * finLength);
                ctx.lineTo(this.x + Math.cos(perpAngle2) * finLength, this.y + Math.sin(perpAngle2) * finLength);
                ctx.stroke();
                
                // Target lock beam (if homing)
                if (this.target && this.guidanceSystem) {
                    const dx = this.target.x - this.x;
                    const dy = this.target.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < this.homingRange) {
                        ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
                        ctx.lineWidth = 1;
                        ctx.setLineDash([2, 2]);
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y);
                        ctx.lineTo(this.target.x, this.target.y);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                }
            }
        }

        // Legacy Bullet Object (kept for compatibility)
        class Bullet {
            constructor(x, y, angle) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.speed = 8;
                this.width = 4;
                this.height = 8;
                this.active = true;
            }
            
            update() {
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
                
                // Remove if off screen
                if (this.y < 0 || this.y > canvas.height || this.x < 0 || this.x > canvas.width) {
                    this.active = false;
                }
            }
            
            render() {
                ctx.fillStyle = '#ffff00';
                ctx.fillRect(this.x - this.width/2, this.y - this.height/2, this.width, this.height);
                
                // Glow effect
                ctx.shadowColor = '#ffff00';
                ctx.shadowBlur = 10;
                ctx.fillRect(this.x - this.width/2, this.y - this.height/2, this.width, this.height);
                ctx.shadowBlur = 0;
            }
        }

        // Enemy Object
        class Enemy {
            constructor() {
                this.x = Math.random() * (canvas.width - 40) + 20;
                this.y = -30;
                this.width = 30;
                this.height = 30;
                this.speed = 1 + Math.random() * 2;
                this.health = 1;
                // 60% Shahed-136 (smaller, faster), 40% Geran-2 (larger, more cargo)
                this.type = Math.random() < 0.6 ? 'shahed' : 'geran';
                this.rotation = 0; // Start level
                this.rotSpeed = 0; // No tumbling - drones fly stable
                this.active = true;
                
                // Realistic drone flight characteristics
                this.targetX = this.x; // Target position for smooth movement
                this.driftSpeed = 0.5; // Slight drift/adjustment speed
                this.stabilized = true; // Drones maintain stable flight
                
                // Adjust size and speed based on drone type
                if (this.type === 'shahed') {
                    this.width = 25;
                    this.height = 25;
                    this.speed = 1.5 + Math.random() * 2.5; // Faster, smaller
                    // Shahed drones have slight course corrections
                    this.courseCorrection = (Math.random() - 0.5) * 0.3;
                } else {
                    this.width = 35;
                    this.height = 35;
                    this.speed = 0.8 + Math.random() * 1.5; // Slower, larger
                    // Geran drones fly more directly
                    this.courseCorrection = (Math.random() - 0.5) * 0.1;
                }
                
                // Shooting properties for Geran drones (more advanced)
                this.shootTimer = Math.random() * 120;
                this.shootInterval = 180 + Math.random() * 120;
            }
            
            update() {
                // Realistic drone flight - steady descent with slight course adjustments
                this.y += this.speed;
                
                // Smooth lateral movement (course corrections)
                this.targetX += this.courseCorrection;
                
                // Keep drones within screen bounds
                if (this.targetX < 30) {
                    this.targetX = 30;
                    this.courseCorrection = Math.abs(this.courseCorrection);
                } else if (this.targetX > canvas.width - 30) {
                    this.targetX = canvas.width - 30;
                    this.courseCorrection = -Math.abs(this.courseCorrection);
                }
                
                // Smooth movement toward target X position
                const xDiff = this.targetX - this.x;
                this.x += xDiff * this.driftSpeed;
                
                // Very subtle banking/turning angle based on lateral movement
                const bankAngle = xDiff * 0.02; // Slight bank when turning
                this.rotation = Math.max(-0.2, Math.min(0.2, bankAngle));
                
                // Geran drones try to track the player slightly
                if (this.type === 'geran' && this.y > 100) {
                    const playerDiff = tank.x - this.x;
                    this.targetX += playerDiff * 0.001; // Very subtle tracking
                }
                
                // Shoot at player (Geran drones only - more advanced)
                if (this.type === 'geran') {
                    this.shootTimer--;
                    if (this.shootTimer <= 0) {
                        this.shootAtPlayer();
                        this.shootTimer = this.shootInterval;
                    }
                }
                
                // Remove if off screen
                if (this.y > canvas.height + 50) {
                    this.active = false;
                }
            }
            
            shootAtPlayer() {
                const dx = tank.x - this.x;
                const dy = tank.y - this.y;
                const angle = Math.atan2(dy, dx);
                
                // Create enemy bullet (you can add this class later)
                // For now, just visual effect
                particles.push(new Particle(this.x, this.y, '#ff0000', 1));
            }
            
            takeDamage() {
                this.health--;
                if (this.health <= 0) {
                    this.destroy();
                }
            }
            
            destroy() {
                this.active = false;
                
                // Create explosion
                explosions.push(new Explosion(this.x, this.y));
                
                // Create dice
                const roll = Math.floor(Math.random() * 6) + 1;
                const value = roll === 6 ? 'worm' : roll;
                const newDicePickup = new DicePickup(this.x, this.y, value);
                dice.push(newDicePickup);
                
                // Add money for intercepted cargo
                const cargoValue = getMaterialValue(value);
                gameState.money += cargoValue;
                updateMoneyDisplay();
                
                gameState.enemiesKilled++;
                console.log('=== ENEMY DESTROYED ===');
                console.log('Enemy position:', this.x, this.y);
                console.log('Dice created with value:', value);
                console.log('Cargo value added: $' + cargoValue);
                console.log('Total money: $' + gameState.money);
                console.log('Dice pickup object:', newDicePickup);
                console.log('Total dice objects in array:', dice.length);
                console.log('Enemies killed:', gameState.enemiesKilled, 'of', gameState.enemiesNeeded, 'needed');
                console.log('========================');
                playSound('explosion');
                
                // Check if enough enemies killed - transition to dice selection
                if (gameState.enemiesKilled >= gameState.enemiesNeeded) {
                    console.log(`${gameState.enemiesNeeded} enemies killed! Preparing dice selection phase...`);
                    setTimeout(() => {
                        startDiceSelectionPhase();
                    }, 2000); // Give time for last dice to be collected
                }
            }
            
            render() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation + Math.PI/2); // Rotate 90 degrees clockwise
                
                if (this.type === 'shahed') {
                    // Draw Shahed-136 style drone (triangular delta wing design)
                    ctx.fillStyle = '#2a2a2a'; // Dark military color
                    
                    // Main body (fuselage)
                    ctx.fillRect(-25, -3, 50, 6);
                    
                    // Delta wings
                    ctx.beginPath();
                    ctx.moveTo(-20, 0);
                    ctx.lineTo(-35, -12);
                    ctx.lineTo(-25, -2);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.moveTo(-20, 0);
                    ctx.lineTo(-35, 12);
                    ctx.lineTo(-25, 2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Nose cone
                    ctx.fillStyle = '#333333';
                    ctx.beginPath();
                    ctx.moveTo(25, 0);
                    ctx.lineTo(30, -2);
                    ctx.lineTo(30, 2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Russian markings
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(-5, -1, 8, 2);
                    
                    // Propeller (at back)
                    ctx.strokeStyle = '#666666';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(-25, -8);
                    ctx.lineTo(-25, 8);
                    ctx.moveTo(-28, -5);
                    ctx.lineTo(-22, 5);
                    ctx.stroke();
                    
                } else {
                    // Draw Geran-2 style drone (larger, more advanced)
                    ctx.fillStyle = '#1a4a1a'; // Dark olive green
                    
                    // Main fuselage
                    ctx.fillRect(-30, -4, 60, 8);
                    
                    // Wings (straight, military style)
                    ctx.fillStyle = '#1a3a1a';
                    ctx.fillRect(-35, -15, 25, 6);
                    ctx.fillRect(-35, 9, 25, 6);
                    
                    // Tail fins
                    ctx.fillRect(-32, -20, 8, 8);
                    ctx.fillRect(-32, 12, 8, 8);
                    
                    // Nose (warhead section)
                    ctx.fillStyle = '#ff6600';
                    ctx.beginPath();
                    ctx.moveTo(30, 0);
                    ctx.lineTo(35, -3);
                    ctx.lineTo(35, 3);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Iranian/Russian markings
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(-8, -2, 12, 4);
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(-6, -1, 8, 2);
                    
                    // Engine exhaust
                    ctx.fillStyle = '#444444';
                    ctx.fillRect(-35, -2, 5, 4);
                    
                    // Landing gear indicators
                    ctx.fillStyle = '#333333';
                    ctx.fillRect(-15, 4, 2, 3);
                    ctx.fillRect(5, 4, 2, 3);
                }
                
                // Add damage effects if health is low
                if (this.health <= 1) {
                    ctx.fillStyle = '#ff8800';
                    ctx.fillRect(Math.random() * 10 - 5, Math.random() * 6 - 3, 2, 2);
                }
                
                ctx.restore();
            }
        }

        // Dice Pickup Object
        class DicePickup {
            constructor(x, y, value) {
                this.x = x;
                this.y = y;
                this.value = value;
                this.size = 20;
                this.collected = false;
                this.floatOffset = Math.random() * Math.PI * 2;
                this.pullSpeed = 0.1;
                this.lifeTime = 0;
                this.maxLifeTime = 300; // 5 seconds at 60fps - auto-collect after this time
                console.log('DicePickup created at:', x, y, 'with value:', value);
            }
            
            update() {
                this.lifeTime++;
                
                // Float animation
                this.floatOffset += 0.05;
                
                // Pull towards tank
                const dx = tank.x - this.x;
                const dy = tank.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 150) { // Increased pull distance
                    this.x += dx * this.pullSpeed;
                    this.y += dy * this.pullSpeed;
                    this.pullSpeed += 0.02;
                }
                
                // Auto-collect if lifetime exceeded or close to tank
                if ((distance < 50 && !this.collected) || (this.lifeTime > this.maxLifeTime && !this.collected)) {
                    // Check if we've already collected enough dice for this round
                    const currentRoundDice = gameState.allTurnDice.filter(die => !die.used).length;
                    const maxDiceThisRound = gameState.enemiesNeeded || 8;
                    
                    if (currentRoundDice >= maxDiceThisRound) {
                        console.log(`DICE COLLECTION LIMIT REACHED: ${currentRoundDice}/${maxDiceThisRound} - skipping collection`);
                        this.collected = true; // Mark as collected to prevent further attempts
                        return;
                    }
                    
                    this.collected = true;
                    const newDie = { value: this.value, selected: false, used: false, id: Date.now() + Math.random() };
                    gameState.availableDice.push(newDie);
                    gameState.allTurnDice.push(newDie);
                    gameState.diceCollected = gameState.availableDice.filter(die => !die.used).length;
                    console.log('=== DICE COLLECTED ===');
                    console.log('Dice value:', this.value);
                    console.log('Dice position when collected:', this.x, this.y);
                    console.log('Tank position:', tank.x, tank.y);
                    console.log('Distance:', distance);
                    console.log('Collection reason:', this.lifeTime > this.maxLifeTime ? 'AUTO (timeout)' : 'PROXIMITY');
                    console.log('Current round dice collected:', currentRoundDice + 1, 'of max:', maxDiceThisRound);
                    console.log('Total dice now in allTurnDice:', gameState.allTurnDice.length);
                    console.log('Total dice now in availableDice:', gameState.availableDice.length);
                    console.log('New die object:', newDie);
                    console.log('======================');
                    playSound('collect');
                    
                    // Show collection notification
                    showDiceCollectionNotification(this.value);
                    
                    updateDisplay();
                    updatePhase();
                    
                    // Show immediate feedback
                    updateStatus(`MATERIAL COLLECTED: ${getMaterialDisplay(this.value)} ${getMaterialName(this.value)}! Total: ${gameState.availableDice.length} üì¶`);
                }
            }
            
            render() {
                if (this.collected) return;
                
                const floatY = this.y + Math.sin(this.floatOffset) * 5;
                
                // Pulsing effect when close to auto-collect
                const timeRatio = this.lifeTime / this.maxLifeTime;
                let alpha = 1;
                if (timeRatio > 0.8) {
                    alpha = 0.5 + 0.5 * Math.sin(this.lifeTime * 0.3);
                }
                
                ctx.globalAlpha = alpha;
                
                // Get material color and style
                const materialStyle = this.getMaterialStyle();
                
                // Glow effect - red if about to auto-collect
                ctx.shadowColor = timeRatio > 0.8 ? '#ff0000' : materialStyle.glow;
                ctx.shadowBlur = 15;
                
                // Dice body with gradient to look like material
                const gradient = ctx.createLinearGradient(
                    this.x - this.size/2, floatY - this.size/2,
                    this.x + this.size/2, floatY + this.size/2
                );
                gradient.addColorStop(0, materialStyle.color1);
                gradient.addColorStop(1, materialStyle.color2);
                
                ctx.fillStyle = gradient;
                ctx.fillRect(this.x - this.size/2, floatY - this.size/2, this.size, this.size);
                
                ctx.shadowBlur = 0;
                
                // Dice border with material color
                ctx.strokeStyle = materialStyle.border;
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x - this.size/2, floatY - this.size/2, this.size, this.size);
                
                // Material icon/symbol
                ctx.fillStyle = materialStyle.textColor;
                ctx.font = 'bold 14px Courier New';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const displayValue = this.getMaterialDisplay();
                ctx.fillText(displayValue, this.x, floatY - 3);
                
                // Show money value
                ctx.fillStyle = '#ffffff';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.font = 'bold 8px Courier New';
                const moneyValue = '$' + getMaterialValue(this.value);
                ctx.strokeText(moneyValue, this.x, floatY + 8);
                ctx.fillText(moneyValue, this.x, floatY + 8);
                
                ctx.globalAlpha = 1;
            }
            
            getMaterialStyle() {
                switch(this.value) {
                    case 1: // Aluminium - silver/grey
                        return {
                            color1: '#c0c0c0',
                            color2: '#808080',
                            border: '#e0e0e0',
                            glow: '#c0c0c0',
                            textColor: '#000000'
                        };
                    case 2: // Steel - dark grey/blue
                        return {
                            color1: '#708090',
                            color2: '#404040',
                            border: '#a0a0a0',
                            glow: '#708090',
                            textColor: '#ffffff'
                        };
                    case 3: // Chips - blue/green circuit
                        return {
                            color1: '#00ff00',
                            color2: '#008800',
                            border: '#00ff00',
                            glow: '#00ff00',
                            textColor: '#000000'
                        };
                    case 4: // Copper - orange/brown
                        return {
                            color1: '#ff8844',
                            color2: '#cc5500',
                            border: '#ffaa66',
                            glow: '#ff8844',
                            textColor: '#000000'
                        };
                    case 5: // Gold - yellow/gold
                        return {
                            color1: '#ffd700',
                            color2: '#ffaa00',
                            border: '#ffee88',
                            glow: '#ffd700',
                            textColor: '#000000'
                        };
                    case 'worm': // Worm - pink/red
                        return {
                            color1: '#ff00ff',
                            color2: '#aa00aa',
                            border: '#ff88ff',
                            glow: '#ff00ff',
                            textColor: '#ffffff'
                        };
                    default:
                        return {
                            color1: '#ffff00',
                            color2: '#ffaa00',
                            border: '#ffffff',
                            glow: '#ffff00',
                            textColor: '#000000'
                        };
                }
            }
            
            getMaterialDisplay() {
                switch(this.value) {
                    case 1: return 'üî©Al'; // Aluminium
                    case 2: return 'üõ†Ô∏èSt'; // Steel  
                    case 3: return 'üíæCh'; // Chips
                    case 4: return '‚ö°Cu'; // Copper
                    case 5: return 'üèÜAu'; // Gold
                    case 'worm': return 'üêõ'; // Worm
                    default: return this.value;
                }
            }
            
            getMaterialName() {
                switch(this.value) {
                    case 1: return 'Aluminium';
                    case 2: return 'Steel';
                    case 3: return 'Chips';
                    case 4: return 'Copper';
                    case 5: return 'Gold';
                    case 'worm': return 'Worm';
                    default: return this.value;
                }
            }
        }

        // Explosion Object
        class Explosion {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.particles = [];
                this.life = 30;
                
                // Create explosion particles
                for (let i = 0; i < 15; i++) {
                    const angle = (i / 15) * Math.PI * 2;
                    const speed = 2 + Math.random() * 4;
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 30,
                        color: Math.random() < 0.5 ? '#ff4444' : '#ffff44'
                    });
                }
            }
            
            update() {
                this.life--;
                this.particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vx *= 0.95;
                    p.vy *= 0.95;
                    p.life--;
                });
                
                this.particles = this.particles.filter(p => p.life > 0);
                return this.life > 0 && this.particles.length > 0;
            }
            
            render() {
                this.particles.forEach(p => {
                    const alpha = p.life / 30;
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
                });
                ctx.globalAlpha = 1;
            }
        }

        // Enhanced Ground Explosion with Fire and Smoke
        class GroundExplosion {
            constructor(x, y, type = 'ground') {
                this.x = x;
                this.y = y;
                this.type = type; // 'building' or 'ground'
                this.particles = [];
                this.fireParticles = [];
                this.smokeParticles = [];
                this.life = 90; // Longer lasting
                this.shockwave = { radius: 0, maxRadius: type === 'building' ? 60 : 40 };
                
                // Create initial explosion particles (more intense)
                const particleCount = type === 'building' ? 25 : 20;
                for (let i = 0; i < particleCount; i++) {
                    const angle = (i / particleCount) * Math.PI * 2;
                    const speed = 3 + Math.random() * 6;
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed - Math.random() * 2, // Slight upward bias
                        life: 40 + Math.random() * 20,
                        size: 2 + Math.random() * 3,
                        color: Math.random() < 0.7 ? '#ff4444' : '#ffff44'
                    });
                }
                
                // Create fire particles (persistent)
                const fireCount = type === 'building' ? 15 : 8;
                for (let i = 0; i < fireCount; i++) {
                    this.fireParticles.push({
                        x: x + (Math.random() - 0.5) * 30,
                        y: y + Math.random() * 10,
                        vx: (Math.random() - 0.5) * 1,
                        vy: -Math.random() * 2 - 1, // Always upward
                        life: 60 + Math.random() * 30,
                        size: 1 + Math.random() * 2,
                        heat: 1.0,
                        flicker: Math.random() * Math.PI * 2
                    });
                }
                
                // Create smoke particles (long lasting)
                const smokeCount = type === 'building' ? 12 : 6;
                for (let i = 0; i < smokeCount; i++) {
                    this.smokeParticles.push({
                        x: x + (Math.random() - 0.5) * 20,
                        y: y,
                        vx: (Math.random() - 0.5) * 1.5,
                        vy: -Math.random() * 1.5 - 0.5, // Drift upward
                        life: 120 + Math.random() * 60, // Very long lasting
                        size: 3 + Math.random() * 4,
                        opacity: 0.8 + Math.random() * 0.2
                    });
                }
            }
            
            update() {
                this.life--;
                
                // Update shockwave
                if (this.shockwave.radius < this.shockwave.maxRadius) {
                    this.shockwave.radius += 2;
                }
                
                // Update explosion particles
                this.particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vx *= 0.95;
                    p.vy += 0.1; // Gravity
                    p.life--;
                    p.size *= 0.98;
                });
                
                // Update fire particles
                this.fireParticles.forEach(p => {
                    p.x += p.vx + Math.sin(p.flicker) * 0.3;
                    p.y += p.vy;
                    p.vx *= 0.98;
                    p.vy *= 0.98;
                    p.life--;
                    p.heat *= 0.99;
                    p.flicker += 0.3;
                });
                
                // Update smoke particles
                this.smokeParticles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vx *= 0.99;
                    p.vy *= 0.995;
                    p.life--;
                    p.size += 0.02; // Smoke expands
                    p.opacity *= 0.998;
                });
                
                // Filter dead particles
                this.particles = this.particles.filter(p => p.life > 0 && p.size > 0.1);
                this.fireParticles = this.fireParticles.filter(p => p.life > 0);
                this.smokeParticles = this.smokeParticles.filter(p => p.life > 0 && p.opacity > 0.1);
                
                // Continue explosion while any particles remain
                return this.life > 0 || this.particles.length > 0 || this.fireParticles.length > 0 || this.smokeParticles.length > 0;
            }
            
            render() {
                // Render shockwave
                if (this.shockwave.radius < this.shockwave.maxRadius) {
                    const alpha = 1 - (this.shockwave.radius / this.shockwave.maxRadius);
                    ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.8})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.shockwave.radius, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Render explosion particles
                this.particles.forEach(p => {
                    const alpha = p.life / 60;
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
                });
                
                // Render fire particles
                this.fireParticles.forEach(p => {
                    const alpha = (p.life / 90) * p.heat;
                    const red = Math.floor(255 * p.heat);
                    const green = Math.floor(100 * p.heat + 100 * (1 - p.heat));
                    const blue = Math.floor(20 * (1 - p.heat));
                    
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = `rgb(${red}, ${green}, ${blue})`;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // Render smoke particles
                this.smokeParticles.forEach(p => {
                    const alpha = (p.life / 180) * p.opacity;
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = '#666666';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                ctx.globalAlpha = 1;
            }
        }

        // Particle Object
        class Particle {
            constructor(x, y, color, life) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = (Math.random() - 0.5) * 4;
                this.color = color;
                this.life = life;
                this.maxLife = life;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
                return this.life > 0;
            }
            
            render() {
                const alpha = this.life / this.maxLife;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - 1, this.y - 1, 2, 2);
                ctx.globalAlpha = 1;
            }
        }

        // Star Object for background
        class Star {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.speed = 0.5 + Math.random() * 2;
                this.brightness = Math.random();
            }
            
            update() {
                this.y += this.speed;
                if (this.y > canvas.height) {
                    this.y = 0;
                    this.x = Math.random() * canvas.width;
                }
            }
            
            render() {
                ctx.globalAlpha = this.brightness;
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(this.x, this.y, 1, 1);
                ctx.globalAlpha = 1;
            }
        }

        // Initialize Canvas and Game
        function initializeCanvas() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight - 35;
            
            // Input handling
            document.addEventListener('keydown', (e) => {
                // Initialize audio on first user interaction
                if (!audioInitialized) {
                    initializeAudio();
                }
                
                keys[e.code] = true;
                if (e.code === 'Space') {
                    e.preventDefault();
                    if (gameState.phase === 'shooting') {
                        tank.shoot();
                    }
                } else if (e.code === 'KeyU') {
                    // Toggle upgrade menu
                    upgradeSystem.toggleUpgradeMenu();
                }
            });
            
            document.addEventListener('keyup', (e) => {
                keys[e.code] = false;
            });
            
            // Mouse click handling for upgrade menu
            canvas.addEventListener('click', (e) => {
                if (upgradeSystem.showUpgradeMenu) {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // Check if click is on upgrade menu
                    const menuWidth = 400;
                    const menuHeight = 500;
                    const menuX = canvas.width - menuWidth - 20;
                    const menuY = 50;
                    
                    if (x >= menuX && x <= menuX + menuWidth && y >= menuY && y <= menuY + menuHeight) {
                        // Check which upgrade was clicked
                        let yOffset = 80;
                        Object.entries(upgradeSystem.upgrades).forEach(([key, upgrade]) => {
                            const buyButtonX = menuX + 320;
                            const buyButtonY = menuY + yOffset - 10;
                            
                            if (x >= buyButtonX && x <= buyButtonX + 60 && 
                                y >= buyButtonY && y <= buyButtonY + 20 && 
                                upgrade.owned < upgrade.maxLevel) {
                                
                                upgradeSystem.purchaseUpgrade(key);
                            }
                            
                            yOffset += 55;
                        });
                    }
                }
            });
            
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight - 35;
                if (tank) tank.y = canvas.height - 60;
            });
            
            // Initialize audio on first click
            document.addEventListener('click', () => {
                if (!audioInitialized) {
                    initializeAudio();
                }
            }, { once: true });
        }

        // Initialize Game Objects
        function initializeGame() {
            // Create game objects
            tank = new Tank();
            bullets = [];
            enemies = [];
            explosions = [];
            dice = [];
            particles = [];
            stars = [];
            civilians = [];
            groundBuildings = [];
            backgroundElements = [];
            constructionSites = [];
            fireBrigade = new FireBrigade();
            upgradeSystem = new DefenseUpgradeSystem();
            
            // Create ground height map
            groundHeightMap = new GroundHeightMap();
            
            // Create background scenery
            initializeBackgroundScenery();
            
            // Create ground infrastructure
            initializeGroundBuildings();
            
            // Create construction sites
            initializeConstructionSites();
            
            // Create civilians
            initializeCivilians();
            
            // Create stars
            for (let i = 0; i < 100; i++) {
                stars.push(new Star());
            }
            
            // Reset game state - SINGLE PLAYER MODE
            gameState.phase = 'shooting'; // Start by shooting enemies for dice
            gameState.tiles = [];
            gameState.playerStack = [];
            gameState.computerStack = []; // Remove computer - not used in single player
            gameState.selectedDice = [];
            gameState.availableDice = [];
            gameState.allTurnDice = [];
            gameState.selectedGroups = [];
            gameState.usedSymbols = [];
            gameState.turnScore = 0;
            gameState.hasWorm = false;
            gameState.currentPlayer = 'human';
            gameState.gameOver = false;
            gameState.enemiesNeeded = 8; // Player must shoot 8 enemies for dice
            gameState.enemiesKilled = 0;
            gameState.diceCollected = 0;
            gameState.money = 0; // Reset money counter
            
            // Create tiles (21-36) for single player
            for (let i = 21; i <= 36; i++) {
                const worms = Math.floor((i - 21) / 4) + 1;
                gameState.tiles.push({
                    number: i,
                    worms: worms,
                    available: true
                });
            }
            
            updateDisplay();
            updatePhase();
            updateStatus("üöÄ SINGLE PLAYER REGENWORMEN! SCHIET 8 VIJANDEN NEER OM 8 DOBBELSTENEN TE KRIJGEN! ÔøΩ");
        }

        // Initialize Ground Buildings
        function initializeGroundBuildings() {
            const totalBuildings = 25; // More buildings for realistic city
            const cityCenter = canvas.width * 0.6; // City center at 60% width
            const cityRadius = canvas.width * 0.25; // City spans 50% of width
            
            // Create city districts with specific building counts
            const urbanBuildings = [];
            const ruralBuildings = [];
            
            // Define exact building requirements
            const buildingPlan = [
                { type: 'theatre', count: 1 },
                { type: 'university', count: 1 },
                { type: 'school', count: 2 },
                { type: 'farm', count: 1 },
                { type: 'factory', count: 2 },
                { type: 'trainstation', count: 1 },
                { type: 'subway', count: 2 },
                { type: 'house', count: 10, size: 'small' },
                { type: 'office', count: 8, size: 'big' } // Using office as "big houses"
            ];
            
            // Generate buildings according to plan
            let buildingIndex = 0;
            let subwayIndex = 0; // Track subway placement separately
            
            buildingPlan.forEach(plan => {
                for (let i = 0; i < plan.count; i++) {
                    let x;
                    
                    // Special positioning for subway stations - place on opposite sides
                    if (plan.type === 'subway') {
                        if (subwayIndex === 0) {
                            x = 80; // First subway on left side
                        } else {
                            x = canvas.width - 120; // Second subway on right side
                        }
                        subwayIndex++;
                    } else {
                        // Distribute other buildings across the width with some spacing
                        const totalBuildings = buildingPlan.reduce((sum, p) => sum + p.count, 0);
                        const xPosition = 50 + (buildingIndex / (totalBuildings - 1)) * (canvas.width - 100);
                        
                        // Add some variation to avoid perfect alignment
                        x = xPosition + (Math.random() - 0.5) * 30;
                    }
                    
                    // Determine if building should be in urban or rural area
                    const building = new GroundBuilding(x, plan.type, plan.size);
                    
                    if (plan.type === 'farm') {
                        ruralBuildings.push(building);
                    } else {
                        urbanBuildings.push(building);
                    }
                    
                    buildingIndex++;
                }
            });
            
            // Add some connecting roads between major buildings
            const roadPositions = [
                150, 300, 450, 600 // Strategic road positions
            ];
            
            roadPositions.forEach(x => {
                if (x > 0 && x < canvas.width) {
                    urbanBuildings.push(new GroundBuilding(x, 'road', 'normal'));
                }
            });
            
            // Combine all buildings
            groundBuildings = [...urbanBuildings, ...ruralBuildings];
            
            // Log building counts for verification
            const buildingCounts = {};
            groundBuildings.forEach(building => {
                buildingCounts[building.type] = (buildingCounts[building.type] || 0) + 1;
            });
            
            console.log(`Initialized ${groundBuildings.length} buildings:`, buildingCounts);
        }

        // Initialize Civilian Population
        function initializeCivilians() {
            const civilianCount = 45; // Increased number of civilians on the battlefield
            
            // Create base civilian distribution
            for (let i = 0; i < civilianCount; i++) {
                // Distribute civilians across the battlefield
                const x = 50 + (i / (civilianCount - 1)) * (canvas.width - 100);
                // Add some randomness to X position
                const civilianX = x + (Math.random() - 0.5) * 60;
                
                // Place civilians near buildings for realism
                let civilianY = canvas.height - 200;
                if (groundHeightMap) {
                    civilianY = groundHeightMap.getHeightAt(civilianX);
                }
                
                // Ensure civilians are on screen
                const clampedX = Math.max(20, Math.min(canvas.width - 20, civilianX));
                
                civilians.push(new Civilian(clampedX, civilianY));
            }
            
            // Add extra civilians clustered around buildings for realism
            groundBuildings.forEach(building => {
                // Skip roads
                if (building.type !== 'road') {
                    // Add 1-3 civilians near each important building
                    const nearbyCount = building.type === 'school' || building.type === 'university' || 
                                      building.type === 'hospital' || building.type === 'trainstation' ? 3 : 
                                      building.type === 'house' || building.type === 'office' ? 2 : 1;
                    
                    for (let i = 0; i < nearbyCount; i++) {
                        // Place civilians around the building
                        const angle = (i / nearbyCount) * Math.PI * 2;
                        const distance = 30 + Math.random() * 40; // 30-70 pixels from building
                        const civilianX = building.x + Math.cos(angle) * distance;
                        
                        // Ensure on screen
                        if (civilianX > 20 && civilianX < canvas.width - 20) {
                            let civilianY = canvas.height - 200;
                            if (groundHeightMap) {
                                civilianY = groundHeightMap.getHeightAt(civilianX);
                            }
                            
                            civilians.push(new Civilian(civilianX, civilianY));
                        }
                    }
                }
            });
            
            console.log(`Initialized ${civilians.length} civilians on the battlefield`);
        }

        // Initialize Construction Sites
        function initializeConstructionSites() {
            // Create a few construction sites across the map
            const siteCount = 3;
            const buildingTypes = ['house', 'office', 'factory', 'school'];
            
            for (let i = 0; i < siteCount; i++) {
                const x = 100 + (i / (siteCount - 1)) * (canvas.width - 200);
                const buildingType = buildingTypes[Math.floor(Math.random() * buildingTypes.length)];
                constructionSites.push(new ConstructionSite(x, buildingType));
            }
        }

        // Initialize Background Scenery
        function initializeBackgroundScenery() {
            // Far background - distant villages (fewer, smaller)
            for (let i = 0; i < 3; i++) {
                const x = i * (canvas.width * 0.8) - canvas.width * 0.2; // Spread across horizon
                const size = 0.3 + Math.random() * 0.2; // Smaller than cities
                const distance = 0.05 + Math.random() * 0.15; // Very distant and faded
                backgroundElements.push(new BackgroundElement('village', x, size, distance));
            }
            
            // Middle background - continuous hills (overlapping for seamless coverage)
            for (let i = 0; i < 4; i++) {
                const x = i * (canvas.width * 0.6) - canvas.width * 0.3; // Overlap edges
                const size = 0.6 + Math.random() * 0.4;
                const distance = 0.25 + Math.random() * 0.25; // Darker, more atmospheric
                backgroundElements.push(new BackgroundElement('hill', x, size, distance));
            }
            
            // Add extra wide hills for complete coverage
            backgroundElements.push(new BackgroundElement('hill', -canvas.width * 0.2, 0.8, 0.3));
            backgroundElements.push(new BackgroundElement('hill', canvas.width * 0.8, 0.7, 0.4));
            
            // Closer background - darker forests (wider spacing, larger)
            for (let i = 0; i < 3; i++) {
                const x = i * (canvas.width * 0.8) - canvas.width * 0.2; // Overlap edges
                const size = 0.7 + Math.random() * 0.3;
                const distance = 0.5 + Math.random() * 0.3; // Closer but darker
                backgroundElements.push(new BackgroundElement('forest', x, size, distance));
            }
            
            // Sort by distance (farthest first for proper layering)
            backgroundElements.sort((a, b) => a.distance - b.distance);
            
            console.log('Initialized', backgroundElements.length, 'background elements with darker atmosphere');
        }

        // Spawn enemies
        function spawnEnemies() {
            if (gameState.phase === 'shooting' && enemies.length < 3 && gameState.enemiesKilled < gameState.enemiesNeeded) {
                if (Math.random() < 0.02) { // 2% chance per frame
                    enemies.push(new Enemy());
                }
            }
        }

        // Main game loop
        function gameLoop() {
            // Clear canvas
            ctx.fillStyle = '#000011';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Update and render stars
            stars.forEach(star => {
                star.update();
                star.render();
            });
            
            // Render background scenery (hills, forests, distant cities)
            backgroundElements.forEach(element => {
                element.render();
            });
            
            // Render ground terrain with hills
            if (groundHeightMap) {
                groundHeightMap.render();
            }
            
            if (gameState.phase === 'shooting') {
                // Spawn enemies
                spawnEnemies();
                
                // Update tank
                tank.update();
                
                // Update bullets
                bullets = bullets.filter(bullet => {
                    bullet.update();
                    
                    // Check bullet-enemy collisions
                    enemies.forEach(enemy => {
                        if (enemy.active && 
                            bullet.x > enemy.x - enemy.width/2 && bullet.x < enemy.x + enemy.width/2 &&
                            bullet.y > enemy.y - enemy.height/2 && bullet.y < enemy.y + enemy.height/2) {
                            bullet.active = false;
                            enemy.takeDamage();
                        }
                    });
                    
                    return bullet.active;
                });
                
                // Update enemies
                enemies = enemies.filter(enemy => {
                    enemy.update();
                    
                    // Check if enemy hits ground buildings or terrain
                    const groundHeight = groundHeightMap ? groundHeightMap.getHeightAt(enemy.x) : canvas.height - 200;
                    if (enemy.y > groundHeight - 15) { // Near ground level
                        groundBuildings.forEach(building => {
                            if (!building.destroyed &&
                                enemy.x >= building.x - 10 && 
                                enemy.x <= building.x + building.width + 10 &&
                                enemy.y >= building.y - building.height - 10) {
                                
                                // Building takes damage
                                building.takeDamage();
                                
                                // Enemy is destroyed on impact
                                enemy.active = false;
                                
                                // Create large ground explosion with fire and smoke
                                explosions.push(new GroundExplosion(enemy.x, enemy.y, 'building'));
                                
                                playSound('explosion');
                                
                                console.log(`Enemy hit ${building.type} building! Health: ${building.health}/${building.maxHealth}`);
                            }
                        });
                        
                        // Check if enemy hits ground (but no building)
                        if (enemy.active) { // Still active means it didn't hit a building
                            enemy.active = false;
                            
                            // Create ground crater explosion
                            explosions.push(new GroundExplosion(enemy.x, enemy.y, 'ground'));
                            playSound('explosion');
                            
                            console.log(`Enemy hit ground at ${enemy.x}, ${enemy.y}`);
                        }
                    }
                    
                    return enemy.active;
                });
                
                // Update dice pickups
                dice = dice.filter(die => {
                    die.update();
                    return !die.collected;
                });
                
                // Update civilians (running from threats)
                civilians.forEach(civilian => {
                    civilian.update();
                });
                
                // Update fire brigade emergency response
                fireBrigade.update();
                
                // Update defense upgrade system
                upgradeSystem.update();
            }
            
            // Update explosions
            explosions = explosions.filter(explosion => explosion.update());
            
            // Update particles
            particles = particles.filter(particle => particle.update());
            
            // Update and render ground buildings
            groundBuildings.forEach(building => {
                building.update();
                building.render();
                // Render underground tunnel systems
                building.renderTunnels();
            });
            
            // Update and render construction sites
            constructionSites.forEach(site => {
                site.render();
            });
            
            // Remove completed construction sites
            constructionSites = constructionSites.filter(site => !site.completed);
            
            // Render everything
            if (gameState.phase === 'shooting') {
                tank.render();
                bullets.forEach(bullet => bullet.render());
                enemies.forEach(enemy => enemy.render());
                dice.forEach(die => die.render());
            }
            
            // Render civilians (always visible during shooting phase)
            if (gameState.phase === 'shooting') {
                civilians.forEach(civilian => civilian.render());
            }
            
            // Render fire brigade emergency response
            fireBrigade.render();
            
            // Render defense upgrade system
            upgradeSystem.render();
            
            explosions.forEach(explosion => explosion.render());
            particles.forEach(particle => particle.render());
            
            animationId = requestAnimationFrame(gameLoop);
        }

        // Start dice selection phase
        function startDiceSelectionPhase() {
            console.log('=== STARTING DICE SELECTION PHASE ===');
            console.log('Collected dice:', gameState.allTurnDice.length);
            
            // Transition to selection phase
            gameState.phase = 'selecting';
            gameState.enemiesNeeded = 0; // No more enemies needed
            
            // Auto-collect any remaining dice on screen (with limit check)
            let autoCollectedCount = 0;
            const currentRoundDice = gameState.allTurnDice.filter(die => !die.used).length;
            const maxDiceThisRound = gameState.enemiesKilled; // Should match enemies killed
            
            dice.forEach(dicePickup => {
                if (!dicePickup.collected && currentRoundDice + autoCollectedCount < maxDiceThisRound) {
                    console.log('Auto-collecting remaining dice with value:', dicePickup.value);
                    dicePickup.collected = true;
                    const newDie = { 
                        value: dicePickup.value, 
                        selected: false, 
                        used: false, 
                        id: 'auto_' + Date.now() + Math.random() 
                    };
                    gameState.availableDice.push(newDie);
                    gameState.allTurnDice.push(newDie);
                    autoCollectedCount++;
                } else if (!dicePickup.collected) {
                    console.log('Skipping auto-collection - dice limit reached');
                    dicePickup.collected = true; // Mark to prevent further processing
                }
            });
            
            console.log(`Auto-collected: ${autoCollectedCount}, Total round dice: ${currentRoundDice + autoCollectedCount}`);
            
            gameState.diceCollected = gameState.allTurnDice.length;
            
            updateDisplay();
            updatePhase();
            
            // Show success message and open inventory
            updateStatus(`üéâ GEFELICITEERD! ${gameState.allTurnDice.length} DOBBELSTENEN VERZAMELD! OPEN INVENTARIS OM ZE TE SELECTEREN! ÔøΩ`);
            
            // Auto-open inventory after a short delay
            setTimeout(() => {
                showInventoryDialog();
            }, 1500);
            
            console.log('Dice selection phase ready. Total dice:', gameState.allTurnDice.length);
        }

        // Show inventory dialog
        function showInventoryDialog() {
            console.log('=== OPENING INVENTORY DIALOG ===');
            console.log('All turn dice:', gameState.allTurnDice);
            
            const dialog = document.getElementById('inventoryDialog');
            dialog.style.display = 'block';
            
            populateInventoryGrid();
            updateInventorySummary();
            
            console.log('Inventory dialog opened');
        }

        // Hide inventory dialog
        function hideInventoryDialog() {
            document.getElementById('inventoryDialog').style.display = 'none';
        }

        // Populate inventory grid
        function populateInventoryGrid() {
            const grid = document.getElementById('inventoryGrid');
            grid.innerHTML = '';
            
            console.log('Populating grid with ALL turn dice count:', gameState.allTurnDice.length);
            console.log('All turn dice array:', gameState.allTurnDice);
            
            if (gameState.allTurnDice.length === 0) {
                const noDiceMsg = document.createElement('div');
                noDiceMsg.style.gridColumn = '1 / -1';
                noDiceMsg.style.textAlign = 'center';
                noDiceMsg.style.color = '#ffff00';
                noDiceMsg.style.padding = '20px';
                noDiceMsg.style.fontSize = '16px';
                noDiceMsg.innerHTML = 'üé≤ Geen dobbelstenen verzameld!<br>Schiet meer vijanden neer!';
                grid.appendChild(noDiceMsg);
                console.log('No dice message added to grid');
                return;
            }
            
            // Add ALL dice collected this turn to grid
            gameState.allTurnDice.forEach((die, index) => {
                console.log(`Creating dice element ${index}: value=${die.value}, selected=${die.selected}, used=${die.used}`);
                
                const diceEl = document.createElement('div');
                diceEl.className = 'inventory-dice';
                diceEl.id = `inventory-dice-${index}`;
                diceEl.setAttribute('data-index', index);
                
                // Add material-specific class
                const materialClass = getMaterialClass(die.value);
                diceEl.classList.add(materialClass);
                
                // Create icon element
                const iconEl = document.createElement('div');
                iconEl.className = 'dice-icon';
                iconEl.textContent = getMaterialDisplay(die.value);
                diceEl.appendChild(iconEl);
                
                // Create value element
                const valueEl = document.createElement('div');
                valueEl.className = 'dice-value';
                valueEl.textContent = '$' + getMaterialValue(die.value);
                diceEl.appendChild(valueEl);
                
                const symbol = die.value === 'worm' ? 'worm' : die.value.toString();
                const symbolAlreadyUsed = gameState.usedSymbols.includes(symbol);
                
                if (die.used) {
                    diceEl.classList.add('used');
                    diceEl.title = `Material: ${getMaterialName(die.value)} - $${getMaterialValue(die.value)} (Already traded)`;
                } else if (symbolAlreadyUsed) {
                    diceEl.classList.add('used-symbol');
                    diceEl.title = `Material: ${getMaterialName(die.value)} - $${getMaterialValue(die.value)} (Type already used this mission)`;
                } else {
                    diceEl.classList.add('available');
                    diceEl.title = `Material: ${getMaterialName(die.value)} - $${getMaterialValue(die.value)} (Click to select)`;
                    
                    if (die.selected) {
                        diceEl.classList.add('selected');
                    }
                    
                    // Direct onclick handler
                    diceEl.onclick = function() {
                        console.log(`DICE ${index} CLICKED DIRECTLY!`);
                        toggleDiceSelectionInInventory(index);
                    };
                }
                
                grid.appendChild(diceEl);
                console.log(`Added dice element ${index} to grid`);
            });
            
            console.log('Grid population complete. Total elements:', grid.children.length);
        }

        // Toggle dice selection in inventory
        function toggleDiceSelectionInInventory(index) {
            console.log('=== DICE SELECTION TOGGLE CALLED ===');
            console.log('Toggling dice selection for index:', index);
            
            if (!gameState.allTurnDice[index]) {
                console.log('No dice at index:', index);
                return;
            }
            
            const die = gameState.allTurnDice[index];
            
            // Can't select used dice
            if (die.used) {
                console.log('Cannot select used dice at index:', index);
                updateStatus("THIS CARGO IS ALREADY TRADED! ‚ö†Ô∏è");
                return;
            }
            
            const symbol = die.value === 'worm' ? 'worm' : die.value.toString();
            
            console.log('Die before toggle:', die, 'Symbol:', symbol);
            
            // Check if this symbol is already used in current turn
            if (gameState.usedSymbols.includes(symbol)) {
                updateStatus("THIS CARGO TYPE ALREADY USED THIS MISSION! ‚ö†Ô∏è");
                return;
            }

            // Toggle selection - but select ALL available dice with same symbol (Regenwormen rule)
            const wasSelected = die.selected;
            
            // Find all available dice with same symbol and toggle them together
            gameState.allTurnDice.forEach((d, i) => {
                if (!d.used) { // Only toggle available dice
                    const dSymbol = d.value === 'worm' ? 'worm' : d.value.toString();
                    if (dSymbol === symbol) {
                        d.selected = !wasSelected;
                        
                        // Update visual immediately
                        const diceEl = document.getElementById(`inventory-dice-${i}`);
                        if (diceEl) {
                            if (d.selected) {
                                diceEl.classList.add('selected');
                                console.log(`Added selected class to dice ${i}`);
                            } else {
                                diceEl.classList.remove('selected');
                                console.log(`Removed selected class from dice ${i}`);
                            }
                        } else {
                            console.log(`Could not find dice element for index ${i}`);
                        }
                    }
                }
            });
            
            console.log('Dice selection updated. Selected dice:', gameState.allTurnDice.filter(d => d.selected && !d.used));
            updateInventorySummary();
        }

        // Update inventory summary
        function updateInventorySummary() {
            console.log('Updating inventory summary...');
            
            const selectedDice = gameState.allTurnDice.filter(die => die.selected && !die.used);
            console.log('Selected dice for summary:', selectedDice);
            
            // Calculate points for selected dice
            let tempScore = 0;
            let tempHasWorm = false;
            const tempGroups = {};
            
            selectedDice.forEach(die => {
                const symbol = die.value === 'worm' ? 'worm' : die.value.toString();
                if (!tempGroups[symbol]) {
                    tempGroups[symbol] = 0;
                }
                tempGroups[symbol]++;
                
                if (symbol === 'worm') {
                    tempHasWorm = true;
                }
            });
            
            Object.keys(tempGroups).forEach(symbol => {
                const count = tempGroups[symbol];
                const points = symbol === 'worm' ? count * 5 : count * parseInt(symbol);
                tempScore += points;
            });
            
            console.log('Calculated temp score:', tempScore, 'Has worm:', tempHasWorm);
            
            // Update display elements
            const currentScoreEl = document.getElementById('currentTurnScore');
            const wormIndicatorEl = document.getElementById('hasWormIndicator');
            const groupsTextEl = document.getElementById('selectedGroupsText');
            
            if (currentScoreEl) currentScoreEl.textContent = gameState.turnScore + tempScore;
            
            // Better worm indicator with count
            const totalHasWorm = gameState.hasWorm || tempHasWorm;
            const wormCount = gameState.selectedGroups.reduce((count, group) => {
                return count + (group.symbol === 'worm' ? group.count || group.dice.length : 0);
            }, 0) + (tempGroups['worm'] || 0);
            
            if (wormIndicatorEl) {
                if (totalHasWorm) {
                    wormIndicatorEl.textContent = `‚úÖ (${wormCount} wormen)`;
                } else {
                    wormIndicatorEl.textContent = '‚ùå (geen wormen)';
                }
            }
            
            // Update selected groups text
            const groupTexts = Object.keys(tempGroups).map(symbol => {
                const count = tempGroups[symbol];
                const points = symbol === 'worm' ? count * 5 : count * parseInt(symbol);
                const symbolDisplay = symbol === 'worm' ? 'üêõ' : symbol;
                return `${count}x${symbolDisplay} (${points}pts)`;
            });
            
            if (groupsTextEl) {
                groupsTextEl.textContent = groupTexts.length > 0 ? groupTexts.join(', ') : 'Geen';
            }
            
            // Enable/disable buttons
            const confirmBtn = document.getElementById('confirmButton');
            const endTurnBtn = document.getElementById('endTurnButton');
            const skipBtn = document.getElementById('skipRoundButton');
            
            console.log('Button elements found:', {confirmBtn, endTurnBtn, skipBtn});
            console.log('Selected dice count:', selectedDice.length);
            
            if (confirmBtn) {
                const shouldDisable = selectedDice.length === 0;
                confirmBtn.disabled = shouldDisable;
                confirmBtn.style.opacity = shouldDisable ? '0.5' : '1';
                confirmBtn.style.cursor = shouldDisable ? 'not-allowed' : 'pointer';
                console.log('Confirm button disabled:', confirmBtn.disabled, 'Should disable:', shouldDisable);
            } else {
                console.log('ERROR: Confirm button not found!');
            }
            
            if (endTurnBtn) {
                const canEndTurn = (gameState.hasWorm || tempHasWorm) && (gameState.turnScore + tempScore > 0);
                endTurnBtn.disabled = !canEndTurn;
                endTurnBtn.style.opacity = canEndTurn ? '1' : '0.5';
                endTurnBtn.style.cursor = canEndTurn ? 'pointer' : 'not-allowed';
                console.log('End turn button disabled:', endTurnBtn.disabled, 'Can end turn:', canEndTurn);
                console.log('Turn score:', gameState.turnScore, 'Temp score:', tempScore, 'Has worm:', gameState.hasWorm, 'Temp has worm:', tempHasWorm);
            } else {
                console.log('ERROR: End turn button not found!');
            }
            
            // Show skip button if no worm available and no valid selections
            if (skipBtn) {
                const noWormAvailable = !gameState.hasWorm && !tempHasWorm;
                const noValidSelections = selectedDice.length === 0 || (gameState.turnScore + tempScore === 0);
                const shouldShowSkip = noWormAvailable && gameState.allTurnDice.length > 0; // Only if we have dice but can't use them
                
                skipBtn.style.display = shouldShowSkip ? 'block' : 'none';
                console.log('Skip button visibility:', shouldShowSkip, 'No worm:', noWormAvailable, 'No valid selections:', noValidSelections);
            }
            
            // Re-attach button event handlers to ensure they work
            setTimeout(() => {
                const confirmBtn = document.getElementById('confirmButton');
                const endTurnBtn = document.getElementById('endTurnButton');
                const continueBtn = document.querySelector('button[onclick="continueGame()"]');
                
                if (confirmBtn) {
                    confirmBtn.onclick = function() {
                        console.log('Confirm button clicked via onclick!');
                        confirmDiceSelection();
                    };
                }
                
                if (continueBtn) {
                    continueBtn.onclick = function() {
                        console.log('Continue button clicked via onclick!');
                        continueGame();
                    };
                }
                
                if (endTurnBtn) {
                    endTurnBtn.onclick = function() {
                        console.log('End turn button clicked via onclick!');
                        endTurnFromInventory();
                    };
                }
                
                console.log('Button event handlers re-attached');
            }, 200);
        }

        // Confirm dice selection
        function confirmDiceSelection() {
            console.log('=== CONFIRM DICE SELECTION FUNCTION CALLED ===');
            
            const selectedDice = gameState.allTurnDice.filter(die => die.selected && !die.used);
            console.log('Selected dice to confirm:', selectedDice);
            
            if (selectedDice.length === 0) {
                updateStatus("SELECT AT LEAST ONE CARGO TYPE! ‚ö†Ô∏è");
                return;
            }
            
            // Group selected dice by symbol
            const symbolGroups = {};
            selectedDice.forEach(die => {
                const symbol = die.value === 'worm' ? 'worm' : die.value.toString();
                if (!symbolGroups[symbol]) {
                    symbolGroups[symbol] = [];
                }
                symbolGroups[symbol].push(die);
            });
            
            // Check if symbol already used this turn
            for (let symbol of Object.keys(symbolGroups)) {
                if (gameState.usedSymbols.includes(symbol)) {
                    updateStatus(`SYMBOOL ${symbol === 'worm' ? 'üêõ' : symbol} IS AL GEBRUIKT DEZE BEURT! ‚ö†Ô∏è`);
                    return;
                }
            }
            
            // Calculate points and add to turn
            let points = 0;
            let hasWorm = false;
            
            Object.keys(symbolGroups).forEach(symbol => {
                const count = symbolGroups[symbol].length;
                const groupPoints = symbol === 'worm' ? count * 5 : count * parseInt(symbol);
                points += groupPoints;
                
                if (symbol === 'worm') {
                    hasWorm = true;
                }
                
                gameState.selectedGroups.push({
                    symbol: symbol,
                    dice: symbolGroups[symbol],
                    points: groupPoints,
                    count: count
                });
                
                gameState.usedSymbols.push(symbol);
                console.log(`Added group: ${count}x ${symbol} = ${groupPoints} points`);
            });
            
            gameState.turnScore += points;
            gameState.hasWorm = gameState.hasWorm || hasWorm;
            
            // Hide inventory dialog
            hideInventoryDialog();
            
            // Calculate remaining dice needed
            const usedDiceCount = gameState.allTurnDice.filter(die => die.used).length;
            const remainingDice = 8 - usedDiceCount;
            
            console.log('Confirm dice - used dice count:', usedDiceCount, 'remaining:', remainingDice);
            console.log('All turn dice status:', gameState.allTurnDice.map(d => ({value: d.value, used: d.used})));
            
            if (remainingDice > 0) {
                // Automatically continue to next shooting round
                console.log('Auto-continuing to next shooting round');
                
                // Clear all dice from screen and inventory for fresh start
                dice = [];
                gameState.availableDice = [];
                gameState.allTurnDice = [];
                gameState.diceCollected = 0;
                
                // Start shooting phase for remaining dice
                gameState.phase = 'shooting';
                gameState.enemiesKilled = 0;
                gameState.enemiesNeeded = remainingDice;
                
                updatePhase();
                updateDisplay();
                updateStatus(`GOED! +${points} PUNTEN! TOTAAL: ${gameState.turnScore}. SCHIET ${remainingDice} VIJANDEN! üöÄ`);
                
                console.log(`Auto-starting next round: need ${remainingDice} dice (${usedDiceCount}/8 used)`);
            } else {
                // All dice used - must end turn
                gameState.phase = 'game';
                updatePhase();
                updateDisplay();
                updateStatus(`ALLE DOBBELSTENEN GEBRUIKT! +${points} PUNTEN! TOTAAL: ${gameState.turnScore}. NEEM EEN TEGEL! üéØ`);
                console.log('All dice used, must end turn');
            }
        }

        // Continue game - shoot for more dice (traditional Regenwormen "continue rolling")
        function continueGame() {
            console.log('=== CONTINUE GAME FUNCTION CALLED ===');
            hideInventoryDialog();
            
            // Clear only the screen dice and available dice, but keep used dice in allTurnDice
            dice = [];
            gameState.availableDice = [];
            gameState.diceCollected = 0;
            
            // Keep track of used dice, don't clear allTurnDice completely
            const usedDiceCount = gameState.allTurnDice.filter(die => die.used).length;
            const maxDicePerTurn = 8;
            const diceNeeded = maxDicePerTurn - usedDiceCount;
            
            console.log('Current allTurnDice before continue:', gameState.allTurnDice.length);
            console.log('Used dice count:', usedDiceCount, 'Dice needed:', diceNeeded);
            console.log('All turn dice:', gameState.allTurnDice.map(d => ({value: d.value, used: d.used})));
            
            if (diceNeeded <= 0) {
                updateStatus("ALL 8 CARGO UNITS ALREADY USED! SECURE PERIMETER! ‚ö†Ô∏è");
                gameState.phase = 'game';
                updatePhase();
                return;
            }
            
            // Start shooting phase for remaining dice
            gameState.phase = 'shooting';
            gameState.enemiesKilled = 0;
            gameState.enemiesNeeded = diceNeeded; // Shoot exactly the number of enemies for remaining dice
            
            updatePhase();
            updateDisplay();
            updateStatus(`CONTINUE MISSION! INTERCEPT ${diceNeeded} MORE DRONES! (${usedDiceCount}/8 CARGO USED) üöÄ`);
            
            console.log(`Continuing turn: need ${diceNeeded} more dice (${usedDiceCount}/8 already used)`);
            console.log('Used groups:', gameState.selectedGroups);
        }

        // Skip round when no worm is available
        function skipRoundNoWorm() {
            console.log('=== SKIPPING ROUND - NO WORM AVAILABLE ===');
            
            // Mark all dice as used so they don't carry over
            gameState.allTurnDice.forEach(die => die.used = true);
            gameState.availableDice.forEach(die => die.used = true);
            
            // Reset turn state
            gameState.turnScore = 0;
            gameState.hasWorm = false;
            gameState.selectedGroups = {};
            
            // Hide inventory dialog
            hideInventoryDialog();
            
            // Check if game should end (all 8 dice used)
            const usedDiceCount = gameState.allTurnDice.filter(die => die.used).length;
            console.log('Used dice after skip:', usedDiceCount);
            
            if (usedDiceCount >= 8) {
                // Game over
                updateStatus("üèÅ MISSIE VOLTOOID! ALLE CARGO VERWERKT! üèÜ");
                gameState.phase = 'gameOver';
                updatePhase();
            } else {
                // Continue to next round
                const remainingDice = 8 - usedDiceCount;
                updateStatus(`‚è≠Ô∏è RONDE OVERGESLAGEN - GEEN REGENWORM! NOG ${remainingDice} CARGO NODIG! üéØ`);
                
                setTimeout(() => {
                    console.log(`Starting next round: need ${remainingDice} dice (${usedDiceCount}/8 used)`);
                    startNextRound();
                }, 2000);
            }
        }

        // End turn from inventory
        function endTurnFromInventory() {
            console.log('=== END TURN FROM INVENTORY FUNCTION CALLED ===');
            // First confirm any selected dice
            const selectedDice = gameState.availableDice.filter(die => die.selected);
            if (selectedDice.length > 0) {
                confirmDiceSelection();
            }
            
            // Then end the turn
            setTimeout(() => {
                endTurn();
            }, 100);
        }

        // End turn and take tile
        function endTurn() {
            if (!gameState.hasWorm) {
                updateStatus("GEEN REGENWORM GESELECTEERD! KAN GEEN TEGEL PAKKEN! üêõ");
                return;
            }

            if (gameState.turnScore === 0) {
                updateStatus("GEEN PUNTEN! SELECTEER EERST DOBBELSTENEN! ‚ö†Ô∏è");
                return;
            }

            hideInventoryDialog();
            takeTileForPlayer();
        }

        // Take tile for player (same logic as before)
        function takeTileForPlayer() {
            const availableTiles = gameState.tiles.filter(tile => tile.available);
            
            const exactMatch = availableTiles.find(tile => tile.number === gameState.turnScore);
            
            let tileToTake;
            if (exactMatch) {
                tileToTake = exactMatch;
            } else {
                const eligibleTiles = availableTiles.filter(tile => tile.number <= gameState.turnScore);
                if (eligibleTiles.length === 0) {
                    updateStatus(`SCORE ${gameState.turnScore} TE LAAG! GEEN TEGELS BESCHIKBAAR! üíÄ`);
                    loseTurn();
                    return;
                }
                tileToTake = eligibleTiles.reduce((max, tile) => tile.number > max.number ? tile : max);
            }

            tileToTake.available = false;
            gameState.playerStack.push(tileToTake);
            
            // Award defense points based on tile value and worms
            const defensePointsAwarded = Math.floor(tileToTake.number / 3) + (tileToTake.worms * 2);
            upgradeSystem.awardPoints(defensePointsAwarded);
            
            playSound('victory');
            const message = tileToTake === exactMatch ? 
                `EXACT! TEGEL ${tileToTake.number} GEPAKT! +${tileToTake.worms} REGENWORMEN! üéØ\n+${defensePointsAwarded} DEFENSE POINTS! üõ°Ô∏è` :
                `TEGEL ${tileToTake.number} GEPAKT! +${tileToTake.worms} REGENWORMEN! üèÜ\n+${defensePointsAwarded} DEFENSE POINTS! üõ°Ô∏è`;
            updateStatus(message);

            resetTurn();
            checkGameEnd();
        }

        function loseTurn() {
            if (gameState.playerStack.length > 0) {
                const lostTile = gameState.playerStack.pop();
                const tileObj = gameState.tiles.find(t => t.number === lostTile.number);
                if (tileObj) tileObj.available = true;
                
                playSound('lose');
                updateStatus(`VERLOREN! TEGEL ${lostTile.number} TERUGGEGEVEN! üíÄ`);
            }
            
            resetTurn();
        }

        function resetTurn() {
            gameState.selectedGroups = [];
            gameState.usedSymbols = [];
            gameState.turnScore = 0;
            gameState.hasWorm = false;
            gameState.availableDice = [];
            gameState.allTurnDice = [];
            gameState.diceCollected = 0;
            gameState.enemiesKilled = 0;
            gameState.phase = 'shooting'; // Always start new turn with shooting
            gameState.enemiesNeeded = 8; // Need to shoot 8 enemies for dice
            
            // Clear any existing dice pickups
            dice = [];
            
            updateDisplay();
            updatePhase();
            updateStatus("NEW MISSION! INTERCEPT 8 ENEMY DRONES TO SECURE THEIR CARGO! üöÄ");
        }

        function checkGameEnd() {
            const availableTiles = gameState.tiles.filter(tile => tile.available);
            if (availableTiles.length === 0) {
                gameState.gameOver = true;
                
                const playerWorms = gameState.playerStack.reduce((sum, tile) => sum + tile.worms, 0);
                const playerTiles = gameState.playerStack.length;
                
                playSound('gameWin');
                updateStatus(`üèÜ SPEL VOLTOOID! ${playerTiles} TEGELS VERZAMELD MET ${playerWorms} REGENWORMEN! üèÜ`);
            } else if (gameState.playerStack.length >= 4) {
                gameState.gameOver = true;
                
                const playerWorms = gameState.playerStack.reduce((sum, tile) => sum + tile.worms, 0);
                
                playSound('gameWin');
                updateStatus(`üèÜ GEWELDIG! 4 TEGELS BEHAALD MET ${playerWorms} REGENWORMEN! üèÜ`);
            }
        }

        function updateDisplay() {
            const playerWorms = gameState.playerStack.reduce((sum, tile) => sum + tile.worms, 0);
            const totalScore = gameState.playerStack.reduce((sum, tile) => sum + tile.number, 0);
            
            document.getElementById('playerScore').textContent = `${playerWorms} üêõ`;
            document.getElementById('totalScore').textContent = totalScore;
            document.getElementById('turnScore').textContent = gameState.turnScore;
            
            document.getElementById('enemiesLeft').textContent = Math.max(0, gameState.enemiesNeeded - gameState.enemiesKilled);
            document.getElementById('diceCollected').textContent = gameState.availableDice.filter(die => !die.used).length;
            
            // Update money display
            updateMoneyDisplay();
            
            // Update converted missiles display
            updateMissileDisplay();
            
            // Update dice count in inventory button
            const diceCountEl = document.getElementById('diceCount');
            if (diceCountEl) {
                diceCountEl.textContent = gameState.availableDice.filter(die => !die.used).length;
            }
            
            // Update dice display
            updateDiceDisplay();
        }
        
        function updateDiceDisplay() {
            const container = document.getElementById('diceDisplayContainer');
            const noDiceMessage = document.getElementById('noDiceMessage');
            
            if (!container) return;
            
            // Clear existing dice display (but keep the no-dice message)
            const diceItems = container.querySelectorAll('.dice-display-item');
            diceItems.forEach(item => item.remove());
            
            if (gameState.allTurnDice.length === 0) {
                noDiceMessage.style.display = 'block';
                return;
            }
            
            noDiceMessage.style.display = 'none';
            
            // Add all dice to display
            gameState.allTurnDice.forEach((die, index) => {
                const diceItem = document.createElement('div');
                diceItem.className = `dice-display-item ${die.used ? 'used' : ''}`;
                diceItem.textContent = die.value === 'worm' ? 'üêõ' : die.value.toString();
                diceItem.title = `Dobbelsteen: ${die.value}${die.used ? ' (gebruikt)' : ''} - Klik om inventaris te openen`;
                diceItem.id = `dice-display-${index}`;
                diceItem.style.cursor = 'pointer';
                
                // Add click handler to open inventory
                diceItem.addEventListener('click', () => {
                    showInventoryDialog();
                });
                
                container.appendChild(diceItem);
            });
            
            console.log('Dice display updated with', gameState.allTurnDice.length, 'dice');
        }
        
        function showDiceCollectionNotification(diceValue) {
            const notification = document.createElement('div');
            notification.className = 'dice-collection-notification';
            notification.textContent = `+${diceValue === 'worm' ? 'üêõ' : diceValue}`;
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(45deg, #ffff00, #ff8800);
                color: #000;
                padding: 10px 20px;
                border-radius: 10px;
                font-size: 24px;
                font-weight: bold;
                z-index: 1000;
                animation: diceNotification 1.5s ease-out forwards;
                pointer-events: none;
                border: 3px solid #fff;
                box-shadow: 0 0 20px #ffff00;
            `;
            
            document.body.appendChild(notification);
            
            // Remove notification after animation
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 1500);
        }

        function updatePhase() {
            const phasePanel = document.getElementById('phasePanel');
            const phaseTitle = document.getElementById('phaseTitle');
            const phaseInstructions = document.getElementById('phaseInstructions');
            const inventoryBtn = document.getElementById('inventoryBtn');
            
            phasePanel.className = 'ui-panel phase-panel';
            
            // Always show inventory button if we have dice
            if (gameState.availableDice.length > 0) {
                inventoryBtn.style.display = 'block';
                console.log('Showing inventory button, dice count:', gameState.availableDice.length);
            } else {
                inventoryBtn.style.display = 'none';
            }
            
            switch (gameState.phase) {
                case 'shooting':
                    phasePanel.classList.add('phase-shooting');
                    phaseTitle.textContent = 'INTERCEPT DRONES!';
                    if (gameState.availableDice.length > 0) {
                        phaseInstructions.textContent = `Dobbelstenen: ${gameState.availableDice.length} - Klik INVENTARIS!`;
                    } else {
                        phaseInstructions.textContent = 'Defend base with ‚Üê ‚Üí movement, SPACE to fire!';
                    }
                    break;
                case 'selecting':
                    phasePanel.classList.add('phase-selecting');
                    phaseTitle.textContent = 'SELECTEER DOBBELSTENEN!';
                    phaseInstructions.textContent = 'Gebruik inventaris om dobbelstenen te selecteren';
                    break;
            }
        }

        function updateStatus(message) {
            document.getElementById('gameStatus').textContent = message;
        }

        function updateMoneyDisplay() {
            document.getElementById('moneyCounter').textContent = '$' + gameState.money.toLocaleString();
        }

        function updateMissileDisplay() {
            const count = gameState.convertedMissiles ? gameState.convertedMissiles.length : 0;
            document.getElementById('missileCounter').textContent = count;
        }

        function newGame() {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            hideInventoryDialog();
            initializeGame();
            gameLoop();
            playSound('start');
        }

        // Sound System (improved with user gesture handling)
        let audioContext = null;
        let audioInitialized = false;
        
        function initializeAudio() {
            if (!audioInitialized && gameState.soundEnabled) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    audioInitialized = true;
                    console.log('Audio context initialized');
                } catch (error) {
                    console.warn('Audio initialization failed:', error);
                    gameState.soundEnabled = false;
                }
            }
        }
        
        function playSound(type) {
            if (!gameState.soundEnabled) return;
            
            // Initialize audio on first sound request
            if (!audioInitialized) {
                initializeAudio();
                if (!audioInitialized) return;
            }
            
            try {
                switch(type) {
                    case 'shoot':
                        createBeep(audioContext, 800, 0.1, 0.2);
                        break;
                    case 'explosion':
                        createBeep(audioContext, 200, 0.3, 0.4);
                        setTimeout(() => createBeep(audioContext, 100, 0.2, 0.3), 100);
                        break;
                    case 'collect':
                        createBeep(audioContext, 1200, 0.1, 0.3);
                        setTimeout(() => createBeep(audioContext, 1600, 0.1, 0.2), 100);
                        break;
                    case 'victory':
                        createBeep(audioContext, 523, 0.2, 0.5);
                        setTimeout(() => createBeep(audioContext, 659, 0.2, 0.5), 150);
                        setTimeout(() => createBeep(audioContext, 784, 0.3, 0.5), 300);
                        break;
                    case 'lose':
                        createBeep(audioContext, 200, 0.5, 0.3);
                        break;
                    case 'start':
                        createBeep(audioContext, 440, 0.2, 0.4);
                        break;
                    case 'gameWin':
                        const notes = [523, 659, 784, 1047];
                        notes.forEach((freq, i) => {
                            setTimeout(() => createBeep(audioContext, freq, 0.3, 0.6), i * 150);
                        });
                        break;
                }
            } catch (error) {
                console.warn('Sound playback failed:', error);
            }
        }

        function createBeep(audioContext, frequency, duration, volume) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            oscillator.type = 'square';
            
            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        function toggleSound() {
            gameState.soundEnabled = !gameState.soundEnabled;
            document.getElementById('soundToggle').textContent = gameState.soundEnabled ? 'üîä' : 'üîá';
        }

        // Test function to add dice for debugging
        function addTestDice() {
            console.log('=== ADDING TEST DICE ===');
            
            // Clear existing dice first
            gameState.availableDice = [];
            gameState.allTurnDice = [];
            
            const testDice = [
                { value: 1, selected: false, used: false, id: 'test1' },
                { value: 2, selected: false, used: false, id: 'test2' },
                { value: 'worm', selected: false, used: false, id: 'test3' },
                { value: 4, selected: false, used: false, id: 'test4' },
                { value: 1, selected: false, used: false, id: 'test5' },
                { value: 3, selected: false, used: false, id: 'test6' },
                { value: 5, selected: false, used: false, id: 'test7' },
                { value: 'worm', selected: false, used: false, id: 'test8' }
            ];
            
            gameState.availableDice.push(...testDice);
            gameState.allTurnDice.push(...testDice);
            gameState.diceCollected = gameState.allTurnDice.length;
            gameState.phase = 'selecting'; // Set to selection phase
            
            updateDisplay();
            updatePhase();
            console.log('Test dice added to availableDice:', gameState.availableDice);
            console.log('Test dice added to allTurnDice:', gameState.allTurnDice);
            console.log('Current phase:', gameState.phase);
            updateStatus("CARGO SUPPLIES ADDED TO BAY! CHECK INTERCEPTED RESOURCES! ÔøΩ");
            
            // Auto-open inventory for testing
            setTimeout(() => {
                showInventoryDialog();
            }, 500);
        }

        // Initialize game
        window.onload = function() {
            initializeCanvas();
            initializeGame();
            gameLoop();
            
            // Enable audio on first interaction
            document.addEventListener('click', function enableAudio() {
                playSound('start');
                document.removeEventListener('click', enableAudio);
            }, { once: true });
        };
    </script>
</body>
</html>