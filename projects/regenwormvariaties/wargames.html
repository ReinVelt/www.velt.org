<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚öîÔ∏è WARGAMES - Good vs Evil üòà</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #00ff00;
            overflow: hidden;
            height: 100vh;
        }

        #gameCanvas {
            display: block;
            background: linear-gradient(180deg, #000011, #000033, #000011);
        }

        /* UI Overlay */
        .ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .ui-panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ff00;
            border-radius: 10px;
            padding: 10px;
            font-size: 14px;
            pointer-events: auto;
            backdrop-filter: blur(5px);
        }

        .good-panel {
            border-color: #00BFFF;
            color: #FFD700;
        }

        .evil-panel {
            border-color: #8B0000;
            color: #ff6666;
        }

        .title-panel {
            top: 10px;
            left: 10px;
            width: 300px;
            z-index: 110;
            text-align: center;
        }

        .score-panel {
            top: 100px;
            left: 10px;
            width: 250px;
        }

        .phase-panel {
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
        }

        .inventory-panel {
            top: 10px;
            right: 10px;
            width: 250px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 3px;
            background: rgba(0, 255, 0, 0.1);
            border-radius: 3px;
        }

        .stat-label {
            font-weight: bold;
        }

        .arcade-button {
            background: linear-gradient(180deg, #00ff00, #00aa00);
            color: #000;
            border: 3px solid #00ff00;
            padding: 10px 20px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 8px;
            box-shadow: 0 5px 0 #005500, 0 8px 15px rgba(0, 255, 0, 0.3);
            transition: all 0.1s;
            margin: 5px;
            width: 100%;
        }

        .arcade-button:hover {
            background: linear-gradient(180deg, #00ff44, #00cc00);
            box-shadow: 0 5px 0 #005500, 0 8px 20px rgba(0, 255, 0, 0.5);
        }

        .arcade-button:active {
            transform: translateY(3px);
            box-shadow: 0 2px 0 #005500, 0 3px 8px rgba(0, 255, 0, 0.3);
        }

        .arcade-button.good {
            background: linear-gradient(180deg, #00BFFF, #0099CC);
            border-color: #FFD700;
            box-shadow: 0 5px 0 #004466, 0 8px 15px rgba(0, 191, 255, 0.3);
            color: #FFD700;
        }

        .arcade-button.evil {
            background: linear-gradient(180deg, #8B0000, #660000);
            border-color: #ff6666;
            box-shadow: 0 5px 0 #330000, 0 8px 15px rgba(139, 0, 0, 0.3);
            color: #fff;
        }

        /* Modal Dialog */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
        }

        .modal-dialog {
            background: #000;
            border: 3px solid #00ff00;
            border-radius: 15px;
            padding: 30px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 0 50px rgba(0, 255, 0, 0.5);
            pointer-events: auto;
        }

        .modal-title {
            font-size: 24px;
            text-align: center;
            margin-bottom: 20px;
            color: #00ff00;
        }

        .conversion-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin: 20px 0;
        }

        .conversion-option {
            background: rgba(0, 255, 0, 0.1);
            border: 2px solid #00ff00;
            border-radius: 10px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.2s;
            pointer-events: auto;
        }

        .conversion-option:hover {
            background: rgba(0, 255, 0, 0.2);
            transform: scale(1.05);
            border-color: #00ff00;
        }

        .conversion-option.disabled {
            opacity: 0.3;
            cursor: not-allowed;
            pointer-events: none;
        }

        .conversion-option.disabled:hover {
            transform: none;
            background: rgba(0, 255, 0, 0.1);
        }

        .weapon-name {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .weapon-cost {
            color: #FFD700;
            margin: 5px 0;
        }

        .weapon-stats {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }

        .status-message {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #00ff00;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 16px;
            z-index: 200;
            text-align: center;
            min-width: 300px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div class="ui-overlay">
        <!-- Title Panel -->
        <div class="ui-panel title-panel" id="titlePanel">
            <div style="font-size: 20px; font-weight: bold;">üòá WARGAMES üòà</div>
            <div style="font-size: 12px; margin-top: 5px;">Good vs Evil</div>
        </div>

        <!-- Phase Panel -->
        <div class="ui-panel phase-panel" id="phasePanel">
            <div id="phaseText">DEFENSE PHASE</div>
            <div id="roundText" style="font-size: 12px; margin-top: 5px;">Round 1</div>
        </div>

        <!-- Score Panel -->
        <div class="ui-panel score-panel" id="scorePanel">
            <div class="stat-row">
                <span class="stat-label">Side:</span>
                <span id="currentSide">üòá GOOD</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Phase:</span>
                <span id="currentPhase">DEFENSE</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">üí∞ Bank:</span>
                <span id="bankMoney" style="color: #FFD700; font-weight: bold;">$10000</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Resources:</span>
                <span id="resources">$0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">üí≥ Debt:</span>
                <span id="playerDebt" style="color: #ff4444; font-weight: bold;">$0</span>
            </div>
            <div class="stat-row">
                <button class="arcade-button" onclick="takeLoan()" style="width: 100%; font-size: 12px;">üè¶ LOAN $1000 (10% interest)</button>
            </div>
            
            <!-- Weapons Factory Section -->
            <div style="border-top: 2px solid #00ff00; margin-top: 8px; padding-top: 8px;">
                <div class="stat-row" style="margin-bottom: 8px;">
                    <span class="stat-label">üè≠ WEAPONS FACTORY</span>
                </div>
                <div class="stat-row">
                    <button class="arcade-button" onclick="manufactureWeapon('missile')" style="width: 100%; font-size: 11px; padding: 4px;">üöÄ Make Missile ($400, 5s)</button>
                </div>
                <div class="stat-row">
                    <button class="arcade-button" onclick="manufactureWeapon('drone')" style="width: 100%; font-size: 11px; padding: 4px;">üöÅ Make Drone ($250, 3s)</button>
                </div>
                <div class="stat-row">
                    <span class="stat-label" style="font-size: 10px;">‚öôÔ∏è In Production:</span>
                    <span id="factoryQueue" style="font-size: 10px; color: #FFD700;">None</span>
                </div>
            </div>
            
            <div class="stat-row">
                <span class="stat-label">Enemies Left:</span>
                <span id="enemiesLeft">8</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Materials:</span>
                <span id="materialsCount">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">üí• Damage:</span>
                <span id="damageValue">$0</span>
            </div>
            <button class="arcade-button" id="soundToggle" onclick="toggleSound()">üîä</button>
        </div>

        <!-- Inventory Panel -->
        <div class="ui-panel inventory-panel" id="inventoryPanel">
            <div style="font-size: 16px; font-weight: bold; margin-bottom: 10px; text-align: center;">ARSENAL</div>
            
            <!-- Header row -->
            <div style="display: grid; grid-template-columns: 1fr 60px 60px; gap: 5px; font-weight: bold; border-bottom: 2px solid #FFD700; padding-bottom: 5px; margin-bottom: 5px;">
                <span>Weapon</span>
                <span style="text-align: center;">You</span>
                <span style="text-align: center;">Enemy</span>
            </div>
            
            <!-- Drones -->
            <div style="display: grid; grid-template-columns: 1fr 60px 60px; gap: 5px; margin-bottom: 3px;">
                <span class="stat-label">ÔøΩ Drones:</span>
                <span id="dronesCount" style="text-align: center;">0</span>
                <span id="enemyDronesCount" style="text-align: center; color: #ff6666;">0</span>
            </div>
            
            <!-- Interceptors -->
            <div style="display: grid; grid-template-columns: 1fr 60px 60px; gap: 5px; margin-bottom: 3px;">
                <span class="stat-label">üõ°Ô∏è Interceptors:</span>
                <span id="interceptorsCount" style="text-align: center;">0</span>
                <span id="enemyInterceptorsCount" style="text-align: center; color: #ff6666;">0</span>
            </div>
            
            <!-- Soldiers -->
            <div style="display: grid; grid-template-columns: 1fr 60px 60px; gap: 5px; margin-bottom: 3px;">
                <span class="stat-label">üë®‚ÄçÔøΩ Soldiers:</span>
                <span id="soldiersCount" style="text-align: center;">0</span>
                <span id="enemySoldiersCount" style="text-align: center; color: #ff6666;">0</span>
            </div>
            
            <!-- Missiles -->
            <div style="display: grid; grid-template-columns: 1fr 60px 60px; gap: 5px; margin-bottom: 3px;">
                <span class="stat-label">üöÄ Missiles:</span>
                <span id="missilesCount" style="text-align: center;">0</span>
                <span id="enemyMissilesCount" style="text-align: center; color: #ff6666;">0</span>
            </div>
            
            <!-- Tanks -->
            <div style="display: grid; grid-template-columns: 1fr 60px 60px; gap: 5px; margin-bottom: 3px;">
                <span class="stat-label">üõ°Ô∏è Tanks:</span>
                <span id="tanksCount" style="text-align: center;">0</span>
                <span id="enemyTanksCount" style="text-align: center; color: #ff6666;">0</span>
            </div>
            
            <!-- Heavy -->
            <div style="display: grid; grid-template-columns: 1fr 60px 60px; gap: 5px; margin-bottom: 3px;">
                <span class="stat-label">‚ö° Heavy:</span>
                <span id="heavyCount" style="text-align: center;">0</span>
                <span id="enemyHeavyCount" style="text-align: center; color: #ff6666;">0</span>
            </div>
            
            <!-- Influencers -->
            <div style="display: grid; grid-template-columns: 1fr 60px 60px; gap: 5px; margin-bottom: 10px;">
                <span class="stat-label">ÔøΩ Influencers:</span>
                <span id="influencersCount" style="text-align: center;">0</span>
                <span id="enemyInfluencersCount" style="text-align: center; color: #ff6666;">0</span>
            </div>
            
            <!-- Enemy Resources -->
            <div style="display: grid; grid-template-columns: 1fr 60px 60px; gap: 5px; margin-bottom: 10px; border-top: 2px solid #FFD700; padding-top: 5px;">
                <span class="stat-label">ÔøΩ Money:</span>
                <span id="arsenalPlayerMoney" style="text-align: center; color: #FFD700; font-weight: bold;">$0</span>
                <span id="enemyResources" style="text-align: center; color: #FFD700; font-weight: bold;">$0</span>
            </div>
            
            <!-- Statistics Section -->
            <div style="display: grid; grid-template-columns: 1fr 60px 60px; gap: 5px; margin-bottom: 10px; border-top: 2px solid #00ff00; padding-top: 5px;">
                <span class="stat-label">üë• Civilians:</span>
                <span id="arsenalPlayerCivilians" style="text-align: center; color: #00ff00; font-weight: bold;">0</span>
                <span id="enemyCivilians" style="text-align: center; color: #00ff00; font-weight: bold;">0</span>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 60px 60px; gap: 5px; margin-bottom: 5px;">
                <span class="stat-label">üçû Food Supply:</span>
                <span id="arsenalPlayerFood" style="text-align: center; color: #FFA500; font-weight: bold;">0</span>
                <span id="enemyFood" style="text-align: center; color: #FFA500; font-weight: bold;">0</span>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 60px 60px; gap: 5px; margin-bottom: 5px;">
                <span class="stat-label">‚ù§Ô∏è Health %:</span>
                <span id="arsenalPlayerHealth" style="text-align: center; color: #ff69b4; font-weight: bold;">0%</span>
                <span id="enemyHealth" style="text-align: center; color: #ff69b4; font-weight: bold;">0%</span>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 60px 60px; gap: 5px; margin-bottom: 5px;">
                <span class="stat-label">üò∞ Hungry:</span>
                <span id="arsenalPlayerHungry" style="text-align: center; color: #ff9999; font-weight: bold;">0</span>
                <span id="enemyHungry" style="text-align: center; color: #ff9999; font-weight: bold;">0</span>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 60px 60px; gap: 5px; margin-bottom: 5px;">
                <span class="stat-label">ü§í Ill:</span>
                <span id="arsenalPlayerIll" style="text-align: center; color: #9370DB; font-weight: bold;">0</span>
                <span id="enemyIll" style="text-align: center; color: #9370DB; font-weight: bold;">0</span>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 60px 60px; gap: 5px; margin-bottom: 5px;">
                <span class="stat-label">ü©π Wounded:</span>
                <span id="arsenalPlayerWounded" style="text-align: center; color: #DC143C; font-weight: bold;">0</span>
                <span id="enemyWounded" style="text-align: center; color: #DC143C; font-weight: bold;">0</span>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 60px 60px; gap: 5px; margin-bottom: 5px;">
                <span class="stat-label">‚ò†Ô∏è Casualties:</span>
                <span id="arsenalPlayerCasualties" style="text-align: center; color: #ff4444; font-weight: bold;">0</span>
                <span id="enemyCasualties" style="text-align: center; color: #ff4444; font-weight: bold;">0</span>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 60px 60px; gap: 5px; margin-bottom: 5px;">
                <span class="stat-label">üèöÔ∏è Buildings Lost:</span>
                <span id="arsenalPlayerBuildings" style="text-align: center; color: #ff8800; font-weight: bold;">0</span>
                <span id="enemyBuildings" style="text-align: center; color: #ff8800; font-weight: bold;">0</span>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 60px 60px; gap: 5px; margin-bottom: 10px;">
                <span class="stat-label">üîß Repair Cost:</span>
                <span id="arsenalPlayerRepair" style="text-align: center; color: #FFD700; font-weight: bold;">$0</span>
                <span id="enemyRepair" style="text-align: center; color: #FFD700; font-weight: bold;">$0</span>
            </div>
            <button class="arcade-button" id="convertButton" onclick="showConversionDialog()" style="margin-top: 10px;">
                üí∞ BUY WEAPONS
            </button>
            <button class="arcade-button" id="viewModeButton" onclick="toggleViewMode()" style="margin-top: 10px; background: linear-gradient(180deg, #ff4444, #cc0000);">
                ‚öîÔ∏è ATTACK MODE
            </button>
        </div>

        <!-- Enemy Inventory Panel (HIDDEN - now using combined panel above) -->
        <div class="ui-panel" id="enemyInventoryPanel" style="display: none;">
        </div>
    </div>

    <!-- Weapon Selection Modal (Attack Mode) -->
    <div class="modal-overlay" id="weaponSelectModal" style="display: none;">
        <div class="modal-dialog" id="weaponSelectDialog">
            <div class="modal-title">üéØ SELECT WEAPON TO FIRE</div>
            <div id="targetInfo" style="margin-bottom: 15px; font-size: 14px; color: #FFD700;"></div>
            <div id="weaponSelectOptions" class="conversion-grid"></div>
            <button class="arcade-button" id="cancelSelectBtn" onclick="cancelWeaponSelect()">CANCEL</button>
        </div>
    </div>

    <!-- Conversion Modal -->
    <div class="modal-overlay" id="conversionModal">
        <div class="modal-dialog" id="conversionDialog">
            <div class="modal-title" id="modalTitle">üí∞ BUY WEAPONS WITH MONEY</div>
            <div id="conversionOptions" class="conversion-grid"></div>
            <div style="display: flex; gap: 10px; margin-top: 10px;">
                <button class="arcade-button" id="closeModalBtn" style="flex: 1;">CLOSE</button>
            </div>
        </div>
    </div>

    <!-- Status Message -->
    <div class="status-message" id="statusMessage" style="display: none;"></div>

    <script>
        // Canvas Setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        function initializeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        window.addEventListener('resize', initializeCanvas);

        // Shared Economy System
        let bankMoney = 10000; // Total money in the system
        const TOTAL_ECONOMY = 10000; // Constant for reference

        // Game State
        let gameState = {
            currentSide: 'good', // 'good' or 'evil'
            phase: 'defense', // 'defense' or 'attack'
            round: 1,
            good: {
                resources: 1000,
                debt: 0, // Loan debt with 10% interest
                materials: [],
                drones: 2,
                interceptors: 0,
                soldiers: 3,
                missiles: 0,
                tanks: 2,
                heavyWeapons: 0,
                influencers: 1,
                launchedWeapons: [],
                destructionValue: 0,
                civilians: 1000,
                casualties: 0,
                buildingsDestroyed: 0,
                repairCost: 0,
                food: 5000,
                health: 85,
                hungry: 0,
                ill: 10,
                wounded: 0,
                factoryQueue: [] // Manufacturing queue: {type, timeLeft}
            },
            evil: {
                resources: 1000,
                debt: 0, // Loan debt with 10% interest
                materials: [],
                drones: 2,
                interceptors: 0,
                soldiers: 3,
                missiles: 0,
                tanks: 2,
                heavyWeapons: 0,
                influencers: 1,
                launchedWeapons: [],
                destructionValue: 0,
                civilians: 1000,
                casualties: 0,
                buildingsDestroyed: 0,
                repairCost: 0,
                food: 5000,
                health: 85,
                hungry: 0,
                ill: 10,
                wounded: 0,
                factoryQueue: [] // Manufacturing queue: {type, timeLeft}
            },
            enemiesNeeded: 8,
            enemiesKilled: 0,
            soundEnabled: true,
            gameOver: false,
            conversionDialogShown: false
        };

        // Enemy Weapons Inventory (separate from player)
        let enemyWeapons = {
            resources: 8000,
            debt: 0,
            drones: 4,
            interceptors: 0,
            soldiers: 0,
            missiles: 5,
            tanks: 1,
            heavyWeapons: 0,
            influencers: 2,
            civilians: 1000,
            casualties: 0,
            buildingsDestroyed: 0,
            repairCost: 0,
            food: 5000,
            health: 85,
            hungry: 0,
            ill: 10,
            wounded: 0,
            factoryQueue: [] // Manufacturing queue: {type, timeLeft}
        };

        // Weapon Definitions
        const WEAPONS = {
            drone: {
                name: 'üöÅ Attack Drone',
                cost: 300,
                speed: 3,
                damage: 1,
                description: 'Fast, light attack drone',
                type: 'offensive'
            },
            interceptor: {
                name: 'üõ°Ô∏è Interceptor Drone',
                cost: 400,
                speed: 6,
                damage: 1,
                description: 'Defensive anti-missile drone',
                type: 'defensive'
            },
            soldier: {
                name: 'üë®‚ÄçüöÄ Laser Soldier',
                cost: 600,
                speed: 2,
                damage: 2,
                description: 'Ground soldier with laser cannon',
                type: 'offensive'
            },
            missile: {
                name: 'üöÄ Cruise Missile',
                cost: 500,
                speed: 5,
                damage: 2,
                description: 'Medium range missile',
                type: 'offensive'
            },
            tank: {
                name: 'üõ°Ô∏è Battle Tank',
                cost: 800,
                speed: 2,
                damage: 3,
                description: 'Heavy armored ground vehicle',
                type: 'offensive'
            },
            heavy: {
                name: '‚ö° Heavy Missile',
                cost: 1000,
                speed: 4,
                damage: 3,
                description: 'Devastating heavy weapon',
                type: 'offensive'
            },
            influencer: {
                name: 'üì± Influencer',
                cost: 700,
                speed: 3,
                damage: 0,
                description: 'Converts enemy defensive units',
                type: 'offensive'
            }
        };

        // Game Objects
        let tank = null;
        let bullets = [];
        let enemies = [];
        let explosions = [];
        let particles = [];
        let stars = [];
        let buildings = [];
        let enemyBuildings = []; // Enemy city buildings for attack mode
        let terrain = null;
        let enemyTerrain = null; // Enemy terrain for attack mode
        let groundLayer = null;
        let enemyGroundLayer = null; // Enemy ground layer for attack mode
        let animationId = null;
        let viewMode = 'own'; // 'own' or 'enemy' - determines which city to display
        let people = [];
        let cars = [];
        let train = null;
        let metros = [];
        
        // Enemy city entities
        let enemyPeople = [];
        let enemyCars = [];
        let enemyTrain = null;
        let enemyMetros = [];
        let enemyTank = null; // AI-controlled enemy tank
        let enemyBullets = []; // Enemy tank bullets
        
        // Defensive units (player)
        let defensiveDrones = [];
        let defensiveInterceptors = [];
        let defensiveSoldiers = [];
        let defensiveTanks = [];
        let defensiveHeavyWeapons = [];
        
        // Enemy defensive units
        let enemyDefensiveDrones = [];
        let enemyDefensiveInterceptors = [];
        let enemyDefensiveSoldiers = [];
        let enemyDefensiveTanks = [];
        let enemyDefensiveHeavyWeapons = [];
        
        // Attack mode state
        let selectedTarget = null; // {x, y, building} when user clicks a building

        // Classes
        class Star {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height * 0.6;
                this.size = Math.random() * 2;
                this.speed = Math.random() * 0.5;
                this.brightness = Math.random();
            }

            update() {
                this.brightness += (Math.random() - 0.5) * 0.1;
                this.brightness = Math.max(0.3, Math.min(1, this.brightness));
            }

            render(ctx) {
                ctx.fillStyle = `rgba(255, 255, 255, ${this.brightness})`;
                ctx.fillRect(this.x, this.y, this.size, this.size);
            }
        }

        // Building types with properties
        const BUILDING_TYPES = {
            house: { health: 2, price: 5000, repairCost: 900, color: '#8B4513', icon: 'üè†', width: 25, height: 30 },
            school: { health: 5, price: 50000, repairCost: 1500, color: '#4169E1', icon: 'üè´', width: 45, height: 50 },
            factory: { health: 8, price: 100000, repairCost: 2000, color: '#696969', icon: 'üè≠', width: 55, height: 60 },
            farm: { health: 3, price: 30000, repairCost: 1200, color: '#8B4513', icon: 'üöú', width: 30, height: 25 },
            hospital: { health: 10, price: 150000, repairCost: 1800, color: '#DC143C', icon: 'üè•', width: 50, height: 55 },
            office: { health: 6, price: 75000, repairCost: 1400, color: '#4682B4', icon: 'üè¢', width: 35, height: 65 },
            government: { health: 12, price: 200000, repairCost: 2000, color: '#FFD700', icon: 'üèõÔ∏è', width: 55, height: 60 },
            theatre: { health: 5, price: 80000, repairCost: 2000, color: '#8B008B', icon: 'üé≠', width: 40, height: 45 },
            subway: { health: 8, price: 120000, repairCost: 1800, color: '#2F4F4F', icon: 'üöá', width: 35, height: 25 },
            shop: { health: 3, price: 25000, repairCost: 900, color: '#FF6347', icon: 'üè™', width: 28, height: 35 },
            tree: { health: 1, price: 500, repairCost: 100, color: '#228B22', icon: 'üå≥', width: 12, height: 20 },
            bush: { health: 1, price: 100, repairCost: 50, color: '#32CD32', icon: 'üåø', width: 10, height: 8 },
            bigfarm: { health: 6, price: 80000, repairCost: 1600, color: '#DEB887', icon: 'üåæ', width: 70, height: 45 },
            pool: { health: 4, price: 40000, repairCost: 1000, color: '#00CED1', icon: 'üèä', width: 35, height: 25 },
            powerplant: { health: 10, price: 250000, repairCost: 2000, color: '#FF4500', icon: '‚ö°', width: 60, height: 65 },
            powerline: { health: 2, price: 5000, repairCost: 500, color: '#A9A9A9', icon: '‚ö°', width: 8, height: 40 }
        };

        class Terrain {
            constructor(isEvil = false) {
                this.points = [];
                this.craters = []; // Track explosion craters
                this.isEvil = isEvil; // Evil enemy terrain style
                this.generateTerrain();
            }

            generateTerrain() {
                // Generate smooth hills using sine waves
                const segments = 200;
                const baseHeight = canvas.height - 150;
                
                for (let i = 0; i <= segments; i++) {
                    const x = (canvas.width / segments) * i;
                    const wave1 = Math.sin(i * 0.05) * 30;
                    const wave2 = Math.sin(i * 0.1) * 20;
                    const wave3 = Math.sin(i * 0.03) * 15;
                    const y = baseHeight + wave1 + wave2 + wave3;
                    this.points.push({ x, y, originalY: y });
                }
            }
            
            createCrater(x, radius) {
                // Add crater to the terrain
                this.craters.push({ x, radius, depth: radius * 0.5 });
                
                // Deform terrain points near the impact
                const segmentWidth = canvas.width / (this.points.length - 1);
                const centerIndex = Math.floor(x / segmentWidth);
                const affectRange = Math.ceil(radius / segmentWidth);
                
                for (let i = Math.max(0, centerIndex - affectRange); 
                     i < Math.min(this.points.length, centerIndex + affectRange + 1); 
                     i++) {
                    const dist = Math.abs(this.points[i].x - x);
                    if (dist < radius) {
                        // Crater depth based on distance from center
                        const depthFactor = 1 - (dist / radius);
                        const depression = radius * 0.5 * depthFactor * depthFactor;
                        
                        // Limit maximum deformation to prevent terrain collapse
                        const maxDeformation = 50; // Maximum pixels a point can move from original
                        const currentDeformation = this.points[i].y - this.points[i].originalY;
                        if (currentDeformation + depression <= maxDeformation) {
                            this.points[i].y += depression;
                        }
                    }
                }
            }

            getHeightAt(x) {
                // Interpolate height at given x position
                const segmentWidth = canvas.width / (this.points.length - 1);
                const index = Math.floor(x / segmentWidth);
                
                if (index >= this.points.length - 1) return this.points[this.points.length - 1].y;
                if (index < 0) return this.points[0].y;
                
                const p1 = this.points[index];
                const p2 = this.points[index + 1];
                const t = (x - p1.x) / (p2.x - p1.x);
                
                return p1.y + (p2.y - p1.y) * t;
            }

            render(ctx) {
                // Draw terrain - different colors for evil terrain
                if (this.isEvil) {
                    // Evil terrain - dark, volcanic, menacing
                    const gradient = ctx.createLinearGradient(0, canvas.height - 200, 0, canvas.height);
                    gradient.addColorStop(0, '#1a0000'); // Dark blood red
                    gradient.addColorStop(0.5, '#330000'); // Deeper red
                    gradient.addColorStop(1, '#0d0d0d'); // Almost black
                    ctx.fillStyle = gradient;
                } else {
                    // Normal green terrain
                    ctx.fillStyle = '#2F4F2F';
                }
                
                ctx.beginPath();
                ctx.moveTo(0, canvas.height);
                
                this.points.forEach(point => {
                    ctx.lineTo(point.x, point.y);
                });
                
                ctx.lineTo(canvas.width, canvas.height);
                ctx.closePath();
                ctx.fill();

                // Add evil atmosphere effects
                if (this.isEvil) {
                    // Add red glow at terrain edge
                    ctx.strokeStyle = 'rgba(139, 0, 0, 0.3)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    this.points.forEach((point, i) => {
                        if (i === 0) ctx.moveTo(point.x, point.y);
                        else ctx.lineTo(point.x, point.y);
                    });
                    ctx.stroke();
                    
                    // Add ominous fog
                    const fogGradient = ctx.createLinearGradient(0, canvas.height - 250, 0, canvas.height - 100);
                    fogGradient.addColorStop(0, 'rgba(80, 0, 0, 0)');
                    fogGradient.addColorStop(1, 'rgba(80, 0, 0, 0.2)');
                    ctx.fillStyle = fogGradient;
                    ctx.fillRect(0, canvas.height - 250, canvas.width, 150);
                }

                // Draw craters (darker areas with burn marks)
                this.craters.forEach(crater => {
                    // Dark burn area
                    const craterGrad = ctx.createRadialGradient(crater.x, this.getHeightAt(crater.x), 0, 
                                                                 crater.x, this.getHeightAt(crater.x), crater.radius);
                    craterGrad.addColorStop(0, 'rgba(20, 20, 20, 0.8)');
                    craterGrad.addColorStop(0.5, 'rgba(40, 30, 20, 0.5)');
                    craterGrad.addColorStop(1, 'rgba(47, 79, 47, 0)');
                    ctx.fillStyle = craterGrad;
                    ctx.beginPath();
                    ctx.arc(crater.x, this.getHeightAt(crater.x), crater.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Crater rim (lighter edge)
                    ctx.strokeStyle = 'rgba(100, 70, 40, 0.6)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(crater.x, this.getHeightAt(crater.x), crater.radius * 0.8, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Scorched earth pattern
                    ctx.fillStyle = 'rgba(30, 20, 10, 0.4)';
                    for (let i = 0; i < 5; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const dist = Math.random() * crater.radius * 0.7;
                        const px = crater.x + Math.cos(angle) * dist;
                        const py = this.getHeightAt(crater.x) + Math.sin(angle) * dist * 0.3;
                        ctx.fillRect(px, py, 2, 2);
                    }
                });

                // Draw grass on top
                ctx.strokeStyle = '#228B22';
                ctx.lineWidth = 3;
                ctx.beginPath();
                this.points.forEach((point, i) => {
                    if (i === 0) ctx.moveTo(point.x, point.y);
                    else ctx.lineTo(point.x, point.y);
                });
                ctx.stroke();

                // Underground layer (darker)
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, canvas.height - 100, canvas.width, 100);
            }
        }

        class GroundLayer {
            constructor(terrain, isEvil = false) {
                this.terrain = terrain;
                this.isEvil = isEvil; // Evil enemy ground layer style
                this.offsetY = 60; // Offset below terrain for depth
                this.height = 120; // Total height of ground layer (increased for better aspect ratio)
                this.roads = [];
                this.railways = [];
                this.connectingRoads = [];
                this.houses = [];
                this.trees = [];
                this.forests = [];
                this.hospital = null;
                this.trainStation = null;
                this.grassPatches = [];
                this.generateFeatures();
            }

            generateFeatures() {
                const w = canvas.width;
                const h = this.height;
                
                // Main road - horizontal across
                this.roads.push({
                    x: 0,
                    y: 25,
                    width: w,
                    height: 8
                });
                
                // Railway - parallel to road
                this.railways.push({
                    x: 0,
                    y: 15,
                    width: w,
                    height: 4
                });
                
                // Connecting roads from main road to buildings
                const connectPoints = [0.15, 0.28, 0.42, 0.55, 0.68, 0.82];
                connectPoints.forEach(point => {
                    this.connectingRoads.push({
                        x: w * point,
                        y: 25,
                        width: 4,
                        height: 20
                    });
                });
                
                // Train station - major landmark
                this.trainStation = {
                    x: w * 0.50,
                    y: 12,
                    width: w * 0.04,  // Reduced from 0.08 to 0.04 (50%)
                    height: 12
                };
                
                // Hospital - with red cross
                this.hospital = {
                    x: w * 0.35,
                    y: 50,
                    width: w * 0.03,  // Reduced from 0.06 to 0.03 (50%)
                    height: 20
                };
                
                // Small houses scattered - distributed across full height
                const housePositions = [
                    { x: w * 0.12, y: 48 },
                    { x: w * 0.18, y: 55 },
                    { x: w * 0.25, y: 52 },
                    { x: w * 0.30, y: 80 },
                    { x: w * 0.45, y: 50 },
                    { x: w * 0.52, y: 65 },
                    { x: w * 0.58, y: 90 },
                    { x: w * 0.65, y: 52 },
                    { x: w * 0.70, y: 75 },
                    { x: w * 0.78, y: 48 },
                    { x: w * 0.85, y: 58 },
                    { x: w * 0.90, y: 85 }
                ];
                
                housePositions.forEach(function(pos) {
                    this.houses.push({
                        x: pos.x,
                        y: pos.y,
                        width: w * 0.0125,  // Reduced from 0.025 to 0.0125 (50%)
                        height: 12
                    });
                }.bind(this));
                
                // Continuous grass patches with natural color variation
                for (let i = 0; i < 30; i++) {
                    this.grassPatches.push({
                        x: w * (i / 30) - w * 0.01,
                        y: 35 + Math.random() * 10,
                        width: w * 0.08,
                        height: h - 20,
                        colorVariation: Math.random() // 0-1 for color blending
                    });
                }
                
                // Underground bunker system - visible with entrances
                this.bunkers = [
                    {
                        x: w * 0.08,
                        y: 85,
                        width: w * 0.15,
                        height: 25,
                        entrance: { x: w * 0.12, y: 50, width: 15, height: 10 },  // Ground level entrance
                        capacity: 30,
                        people: [],
                        stairsY: 60  // Where stairs end before reaching bunker
                    },
                    {
                        x: w * 0.72,
                        y: 90,
                        width: w * 0.12,
                        height: 20,
                        entrance: { x: w * 0.76, y: 50, width: 15, height: 10 },  // Ground level entrance
                        capacity: 25,
                        people: [],
                        stairsY: 65  // Where stairs end before reaching bunker
                    }
                ];
                
                // Subway system - underground tunnels connecting stations (positioned away from park at 0.35-0.65)
                this.subwaySystem = {
                    tunnelY: 95,
                    tunnelHeight: 10,
                    stations: [
                        { x: w * 0.10, y: 80, width: 20, height: 15, capacity: 20, people: [], entrance: { x: w * 0.10, y: 50, width: 12, height: 8 } },  // Far left
                        { x: w * 0.25, y: 80, width: 20, height: 15, capacity: 20, people: [], entrance: { x: w * 0.25, y: 50, width: 12, height: 8 } },  // Left of park
                        { x: w * 0.70, y: 80, width: 20, height: 15, capacity: 20, people: [], entrance: { x: w * 0.70, y: 50, width: 12, height: 8 } },  // Right of park
                        { x: w * 0.85, y: 80, width: 20, height: 15, capacity: 20, people: [], entrance: { x: w * 0.85, y: 50, width: 12, height: 8 } }   // Far right
                    ],
                    // Connecting tunnels between all underground facilities
                    connectingTunnels: [
                        // Horizontal tunnel connecting bunker 1 to station 1
                        { x1: w * 0.08 + w * 0.15, y: 92, x2: w * 0.10, width: 3, height: 8 },
                        // Horizontal tunnel connecting station 2 to bunker 2
                        { x1: w * 0.25 + 20, y: 92, x2: w * 0.72, width: 3, height: 8 }
                    ]
                };
                
                // Remove old forests array initialization
                this.forests = [];
            }

            render(ctx) {
                const baseY = this.terrain.getHeightAt(canvas.width / 2) + this.offsetY;
                
                // Draw continuous grass patches with photorealistic color blending
                this.grassPatches.forEach(patch => {
                    // Photorealistic grass colors with natural variation
                    const colors = ['#9ACD32', '#7CFC00', '#32CD32', '#6B8E23'];
                    const color1 = colors[Math.floor(patch.colorVariation * 2)];
                    const color2 = colors[Math.floor(patch.colorVariation * 2) + 1] || colors[0];
                    const color3 = colors[Math.floor(patch.colorVariation * 3)] || colors[1];
                    
                    const grassGrad = ctx.createLinearGradient(patch.x, baseY + patch.y, patch.x, baseY + patch.y + patch.height);
                    grassGrad.addColorStop(0, color1);
                    grassGrad.addColorStop(0.4, color2);
                    grassGrad.addColorStop(0.7, color3);
                    grassGrad.addColorStop(1, '#228B22');
                    ctx.fillStyle = grassGrad;
                    ctx.fillRect(patch.x, baseY + patch.y, patch.width, patch.height);
                    
                    // Vertical grass blades for texture
                    ctx.strokeStyle = 'rgba(34, 139, 34, 0.3)';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 10; i++) {
                        const gx = patch.x + (i + 0.5) * (patch.width / 10);
                        const gy = baseY + patch.y + patch.height;
                        ctx.beginPath();
                        ctx.moveTo(gx, gy);
                        ctx.lineTo(gx + Math.random() * 2 - 1, gy - 3 - Math.random() * 2);
                        ctx.stroke();
                    }
                });
                
                // Draw railway
                this.railways.forEach(rail => {
                    // Railway bed (gravel)
                    const gravelGrad = ctx.createLinearGradient(0, baseY + rail.y - 1, 0, baseY + rail.y + rail.height + 1);
                    gravelGrad.addColorStop(0, '#999');
                    gravelGrad.addColorStop(1, '#666');
                    ctx.fillStyle = gravelGrad;
                    ctx.fillRect(rail.x, baseY + rail.y - 1, rail.width, rail.height + 2);
                    
                    // Rails
                    const railGrad = ctx.createLinearGradient(0, baseY + rail.y, 0, baseY + rail.y + 2);
                    railGrad.addColorStop(0, '#AAA');
                    railGrad.addColorStop(0.5, '#888');
                    railGrad.addColorStop(1, '#666');
                    ctx.fillStyle = railGrad;
                    ctx.fillRect(rail.x, baseY + rail.y + 0.5, rail.width, 1.5);
                    ctx.fillRect(rail.x, baseY + rail.y + rail.height - 2, rail.width, 1.5);
                    
                    // Railroad ties
                    ctx.fillStyle = '#4a3520';
                    const tieSpacing = 15;
                    for (let x = 0; x < rail.width; x += tieSpacing) {
                        ctx.fillRect(rail.x + x, baseY + rail.y, 3, rail.height);
                    }
                });
                
                // Draw train station
                if (this.trainStation) {
                    const st = this.trainStation;
                    const stX = st.x;
                    const stY = baseY + st.y;
                    
                    // Station building
                    const stationGrad = ctx.createLinearGradient(stX, stY, stX, stY + st.height);
                    stationGrad.addColorStop(0, '#8B7355');
                    stationGrad.addColorStop(0.5, '#6B5344');
                    stationGrad.addColorStop(1, '#4a3520');
                    ctx.fillStyle = stationGrad;
                    ctx.fillRect(stX, stY, st.width, st.height);
                    ctx.strokeStyle = '#2a1a00';
                    ctx.lineWidth = 1.5;
                    ctx.strokeRect(stX, stY, st.width, st.height);
                    
                    // Roof
                    const roofGrad = ctx.createLinearGradient(stX, stY - 4, stX, stY);
                    roofGrad.addColorStop(0, '#CC4444');
                    roofGrad.addColorStop(1, '#AA2222');
                    ctx.fillStyle = roofGrad;
                    ctx.beginPath();
                    ctx.moveTo(stX - 2, stY);
                    ctx.lineTo(stX + st.width / 2, stY - 4);
                    ctx.lineTo(stX + st.width + 2, stY);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#882222';
                    ctx.stroke();
                    
                    // Windows
                    ctx.fillStyle = '#FFD700';
                    for (let i = 0; i < 4; i++) {
                        ctx.fillRect(stX + 4 + i * (st.width / 5), stY + 3, st.width * 0.12, 4);
                    }
                    
                    // Platform
                    ctx.fillStyle = '#999';
                    ctx.fillRect(stX - 3, stY + st.height, st.width + 6, 2);
                    
                    // "STATION" sign
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(stX + st.width * 0.25, stY + st.height - 4, st.width * 0.5, 3);
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 2px Arial';
                    ctx.fillText('STATION', stX + st.width * 0.28, stY + st.height - 2);
                }
                
                // Draw main road
                this.roads.forEach(road => {
                    let roadGrad;
                    if (this.isEvil) {
                        // Evil roads - darker, blood-stained
                        roadGrad = ctx.createLinearGradient(0, baseY + road.y, 0, baseY + road.y + road.height);
                        roadGrad.addColorStop(0, '#2a0000');
                        roadGrad.addColorStop(0.5, '#1a0000');
                        roadGrad.addColorStop(1, '#0d0000');
                    } else {
                        roadGrad = ctx.createLinearGradient(0, baseY + road.y, 0, baseY + road.y + road.height);
                        roadGrad.addColorStop(0, '#505050');
                        roadGrad.addColorStop(0.5, '#3a3a3a');
                        roadGrad.addColorStop(1, '#2a2a2a');
                    }
                    ctx.fillStyle = roadGrad;
                    ctx.fillRect(road.x, baseY + road.y, road.width, road.height);
                    
                    // Road edges
                    ctx.strokeStyle = this.isEvil ? '#440000' : '#666';
                    ctx.lineWidth = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(road.x, baseY + road.y);
                    ctx.lineTo(road.x + road.width, baseY + road.y);
                    ctx.moveTo(road.x, baseY + road.y + road.height);
                    ctx.lineTo(road.x + road.width, baseY + road.y + road.height);
                    ctx.stroke();
                    
                    // Center line
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([10, 10]);
                    ctx.beginPath();
                    ctx.moveTo(road.x, baseY + road.y + road.height / 2);
                    ctx.lineTo(road.x + road.width, baseY + road.y + road.height / 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                });
                
                // Draw connecting roads
                this.connectingRoads.forEach(road => {
                    const roadGrad = ctx.createLinearGradient(road.x, baseY + road.y, road.x, baseY + road.y + road.height);
                    roadGrad.addColorStop(0, '#3a3a3a');
                    roadGrad.addColorStop(1, '#2a2a2a');
                    ctx.fillStyle = roadGrad;
                    ctx.fillRect(road.x, baseY + road.y, road.width, road.height);
                    
                    // Road edges
                    ctx.strokeStyle = '#555';
                    ctx.lineWidth = 0.5;
                    ctx.strokeRect(road.x, baseY + road.y, road.width, road.height);
                });
                
                // Draw hospital
                if (this.hospital) {
                    const h = this.hospital;
                    const hX = h.x;
                    const hY = baseY + h.y;
                    
                    // Hospital building
                    const hospGrad = ctx.createLinearGradient(hX, hY, hX, hY + h.height);
                    hospGrad.addColorStop(0, '#FFFFFF');
                    hospGrad.addColorStop(0.5, '#F0F0F0');
                    hospGrad.addColorStop(1, '#D0D0D0');
                    ctx.fillStyle = hospGrad;
                    ctx.fillRect(hX, hY, h.width, h.height);
                    ctx.strokeStyle = '#AAA';
                    ctx.lineWidth = 1.5;
                    ctx.strokeRect(hX, hY, h.width, h.height);
                    
                    // Red cross - large and prominent
                    ctx.shadowBlur = 4;
                    ctx.shadowColor = 'rgba(255, 0, 0, 0.5)';
                    const crossGrad = ctx.createRadialGradient(
                        hX + h.width / 2, hY + h.height / 2, 0,
                        hX + h.width / 2, hY + h.height / 2, h.width / 3
                    );
                    crossGrad.addColorStop(0, '#FF3333');
                    crossGrad.addColorStop(0.5, '#FF0000');
                    crossGrad.addColorStop(1, '#CC0000');
                    ctx.fillStyle = crossGrad;
                    
                    // Vertical bar
                    ctx.fillRect(hX + h.width / 2 - h.width * 0.08, hY + h.height * 0.25, h.width * 0.16, h.height * 0.5);
                    // Horizontal bar
                    ctx.fillRect(hX + h.width * 0.25, hY + h.height / 2 - h.width * 0.08, h.width * 0.5, h.width * 0.16);
                    ctx.shadowBlur = 0;
                    
                    // Windows
                    ctx.fillStyle = '#ADD8E6';
                    for (let i = 0; i < 3; i++) {
                        ctx.fillRect(hX + 2 + i * (h.width / 4), hY + 2, h.width * 0.15, 3);
                    }
                }
                
                // Draw small houses
                this.houses.forEach(house => {
                    const hX = house.x;
                    const hY = baseY + house.y;
                    
                    // House body
                    const houseGrad = ctx.createLinearGradient(hX, hY, hX, hY + house.height);
                    houseGrad.addColorStop(0, '#D2B48C');
                    houseGrad.addColorStop(1, '#A0826D');
                    ctx.fillStyle = houseGrad;
                    ctx.fillRect(hX, hY, house.width, house.height);
                    ctx.strokeStyle = '#6B5344';
                    ctx.strokeRect(hX, hY, house.width, house.height);
                    
                    // Roof
                    const roofGrad = ctx.createLinearGradient(hX, hY - 3, hX, hY);
                    roofGrad.addColorStop(0, '#8B4513');
                    roofGrad.addColorStop(1, '#654321');
                    ctx.fillStyle = roofGrad;
                    ctx.beginPath();
                    ctx.moveTo(hX - 1, hY);
                    ctx.lineTo(hX + house.width / 2, hY - 3);
                    ctx.lineTo(hX + house.width + 1, hY);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Window
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(hX + house.width * 0.3, hY + 2, house.width * 0.25, 2.5);
                    
                    // Door
                    ctx.fillStyle = '#4a3310';
                    ctx.fillRect(hX + house.width * 0.6, hY + house.height - 4, house.width * 0.25, 4);
                });
                
                // Draw bunkers (underground shelters)
                this.bunkers.forEach(bunker => {
                    const bX = bunker.x;
                    const bY = baseY + bunker.y;
                    const bW = bunker.width;
                    const bH = bunker.height;
                    
                    // Entrance at surface level (ground floor)
                    const entranceX = bunker.entrance.x;
                    const entranceY = baseY + bunker.entrance.y;
                    const entranceW = bunker.entrance.width;
                    const entranceH = bunker.entrance.height;
                    const stairsEndY = baseY + bunker.stairsY;
                    
                    // Ground level entrance building/structure
                    const entranceStructGrad = ctx.createLinearGradient(
                        entranceX - 2, entranceY - 5,
                        entranceX + entranceW + 2, entranceY - 5
                    );
                    entranceStructGrad.addColorStop(0, '#666');
                    entranceStructGrad.addColorStop(0.5, '#888');
                    entranceStructGrad.addColorStop(1, '#666');
                    ctx.fillStyle = entranceStructGrad;
                    ctx.fillRect(entranceX - 2, entranceY - 5, entranceW + 4, 5);
                    
                    // Entrance door (steel)
                    const doorGrad = ctx.createLinearGradient(
                        entranceX, entranceY,
                        entranceX + entranceW, entranceY
                    );
                    doorGrad.addColorStop(0, '#555');
                    doorGrad.addColorStop(0.5, '#777');
                    doorGrad.addColorStop(1, '#555');
                    ctx.fillStyle = doorGrad;
                    ctx.fillRect(entranceX, entranceY, entranceW, entranceH);
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(entranceX, entranceY, entranceW, entranceH);
                    
                    // Stairwell shaft (vertical tunnel from entrance to stairs end)
                    const shaftGrad = ctx.createLinearGradient(
                        entranceX, entranceY + entranceH,
                        entranceX, stairsEndY
                    );
                    shaftGrad.addColorStop(0, '#444');
                    shaftGrad.addColorStop(1, '#222');
                    ctx.fillStyle = shaftGrad;
                    ctx.fillRect(entranceX, entranceY + entranceH, entranceW, stairsEndY - (entranceY + entranceH));
                    
                    // Draw stairs inside stairwell
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 1.5;
                    const stairCount = Math.floor((stairsEndY - (entranceY + entranceH)) / 3);
                    for (let i = 0; i < stairCount; i++) {
                        const stepY = entranceY + entranceH + i * 3;
                        ctx.beginPath();
                        ctx.moveTo(entranceX + 2, stepY);
                        ctx.lineTo(entranceX + entranceW - 2, stepY);
                        ctx.stroke();
                    }
                    
                    // Handrails
                    ctx.strokeStyle = '#888';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(entranceX + 2, entranceY + entranceH);
                    ctx.lineTo(entranceX + 2, stairsEndY);
                    ctx.moveTo(entranceX + entranceW - 2, entranceY + entranceH);
                    ctx.lineTo(entranceX + entranceW - 2, stairsEndY);
                    ctx.stroke();
                    
                    // Horizontal connecting tunnel from stairs to bunker
                    const tunnelConnectY = stairsEndY;
                    const tunnelConnectH = 8;
                    const tunnelStartX = entranceX + entranceW;
                    const tunnelEndX = bX;
                    
                    const connectTunnelGrad = ctx.createLinearGradient(
                        0, tunnelConnectY,
                        0, tunnelConnectY + tunnelConnectH
                    );
                    connectTunnelGrad.addColorStop(0, '#333');
                    connectTunnelGrad.addColorStop(0.5, '#222');
                    connectTunnelGrad.addColorStop(1, '#111');
                    ctx.fillStyle = connectTunnelGrad;
                    ctx.fillRect(tunnelStartX, tunnelConnectY, tunnelEndX - tunnelStartX, tunnelConnectH);
                    ctx.strokeStyle = '#444';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(tunnelStartX, tunnelConnectY, tunnelEndX - tunnelStartX, tunnelConnectH);
                    
                    // Vertical shaft from connecting tunnel down to bunker
                    const verticalShaftX = bX - 5;
                    const verticalShaftW = 6;
                    const verticalShaftGrad = ctx.createLinearGradient(
                        verticalShaftX, tunnelConnectY + tunnelConnectH,
                        verticalShaftX, bY
                    );
                    verticalShaftGrad.addColorStop(0, '#333');
                    verticalShaftGrad.addColorStop(1, '#222');
                    ctx.fillStyle = verticalShaftGrad;
                    ctx.fillRect(verticalShaftX, tunnelConnectY + tunnelConnectH, verticalShaftW, bY - (tunnelConnectY + tunnelConnectH));
                    
                    // Ladder in vertical shaft
                    ctx.strokeStyle = '#555';
                    ctx.lineWidth = 1;
                    for (let ly = tunnelConnectY + tunnelConnectH; ly < bY; ly += 4) {
                        ctx.beginPath();
                        ctx.moveTo(verticalShaftX + 2, ly);
                        ctx.lineTo(verticalShaftX + verticalShaftW - 2, ly);
                        ctx.stroke();
                    }
                    
                    // Bunker body (concrete underground structure)
                    const bunkerGrad = ctx.createLinearGradient(bX, bY, bX, bY + bH);
                    bunkerGrad.addColorStop(0, '#555');
                    bunkerGrad.addColorStop(0.5, '#444');
                    bunkerGrad.addColorStop(1, '#333');
                    ctx.fillStyle = bunkerGrad;
                    ctx.fillRect(bX, bY, bW, bH);
                    
                    // Concrete texture (thick walls)
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(bX, bY, bW, bH);
                    
                    // Interior space
                    ctx.fillStyle = '#222';
                    ctx.fillRect(bX + 3, bY + 3, bW - 6, bH - 6);
                    
                    // Support beams
                    ctx.strokeStyle = '#888';
                    ctx.lineWidth = 1;
                    for (let i = 1; i < 3; i++) {
                        const beamX = bX + (bW / 3) * i;
                        ctx.beginPath();
                        ctx.moveTo(beamX, bY + 3);
                        ctx.lineTo(beamX, bY + bH - 3);
                        ctx.stroke();
                    }
                    
                    // Emergency lights
                    ctx.fillStyle = '#0F0';
                    ctx.shadowBlur = 3;
                    ctx.shadowColor = '#0F0';
                    ctx.fillRect(bX + 5, bY + 5, 2, 2);
                    ctx.fillRect(bX + bW - 7, bY + 5, 2, 2);
                    ctx.shadowBlur = 0;
                    
                    // Capacity indicator
                    ctx.fillStyle = '#0F0';
                    ctx.font = '8px monospace';
                    ctx.fillText(`${bunker.people.length}/${bunker.capacity}`, bX + 5, bY + 15);
                    
                    // Draw people inside bunker
                    bunker.people.forEach((person, i) => {
                        const px = bX + 6 + (i % 8) * 4;
                        const py = bY + 18 + Math.floor(i / 8) * 4;
                        ctx.fillStyle = '#FFA500';
                        ctx.fillRect(px, py, 2, 3);
                    });
                });
                
                // Draw subway system with connecting tunnels
                if (this.subwaySystem) {
                    const tunnelY = baseY + this.subwaySystem.tunnelY;
                    const tunnelH = this.subwaySystem.tunnelHeight;
                    
                    // Draw connecting tunnels between bunkers and stations
                    if (this.subwaySystem.connectingTunnels) {
                        this.subwaySystem.connectingTunnels.forEach(tunnel => {
                            const tY = baseY + tunnel.y;
                            const tH = tunnel.height;
                            const tX1 = tunnel.x1;
                            const tX2 = tunnel.x2;
                            
                            const connectGrad = ctx.createLinearGradient(0, tY, 0, tY + tH);
                            connectGrad.addColorStop(0, '#333');
                            connectGrad.addColorStop(0.5, '#222');
                            connectGrad.addColorStop(1, '#111');
                            ctx.fillStyle = connectGrad;
                            ctx.fillRect(Math.min(tX1, tX2), tY, Math.abs(tX2 - tX1), tH);
                            
                            ctx.strokeStyle = '#444';
                            ctx.lineWidth = 2;
                            ctx.strokeRect(Math.min(tX1, tX2), tY, Math.abs(tX2 - tX1), tH);
                            
                            // Lights in connecting tunnel
                            ctx.fillStyle = '#FF6';
                            const lightSpacing = 40;
                            for (let lx = Math.min(tX1, tX2); lx < Math.max(tX1, tX2); lx += lightSpacing) {
                                ctx.shadowBlur = 5;
                                ctx.shadowColor = '#FF6';
                                ctx.fillRect(lx, tY + 1, 2, 2);
                            }
                            ctx.shadowBlur = 0;
                        });
                    }
                    
                    // Draw main tunnel connecting all stations
                    const tunnelGrad = ctx.createLinearGradient(0, tunnelY, 0, tunnelY + tunnelH);
                    tunnelGrad.addColorStop(0, '#222');
                    tunnelGrad.addColorStop(0.5, '#111');
                    tunnelGrad.addColorStop(1, '#000');
                    ctx.fillStyle = tunnelGrad;
                    
                    // Tunnel from first to last station
                    const firstStation = this.subwaySystem.stations[0];
                    const lastStation = this.subwaySystem.stations[this.subwaySystem.stations.length - 1];
                    ctx.fillRect(firstStation.x - 10, tunnelY, lastStation.x - firstStation.x + 40, tunnelH);
                    
                    // Tunnel outline
                    ctx.strokeStyle = '#444';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(firstStation.x - 10, tunnelY, lastStation.x - firstStation.x + 40, tunnelH);
                    
                    // Railway tracks in tunnel
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 1;
                    const trackY1 = tunnelY + tunnelH - 3;
                    const trackY2 = tunnelY + tunnelH - 1;
                    ctx.beginPath();
                    ctx.moveTo(firstStation.x - 10, trackY1);
                    ctx.lineTo(lastStation.x + 30, trackY1);
                    ctx.moveTo(firstStation.x - 10, trackY2);
                    ctx.lineTo(lastStation.x + 30, trackY2);
                    ctx.stroke();
                    
                    // Draw stations with ground entrances
                    this.subwaySystem.stations.forEach(station => {
                        const sX = station.x;
                        const sY = tunnelY - station.height;
                        const sW = station.width;
                        const sH = station.height;
                        
                        // Ground entrance
                        const entranceX = station.entrance.x;
                        const entranceY = baseY + station.entrance.y;
                        const entranceW = station.entrance.width;
                        const entranceH = station.entrance.height;
                        
                        // Metro entrance structure (kiosk)
                        const kioskGrad = ctx.createLinearGradient(
                            entranceX - 2, entranceY - 6,
                            entranceX + entranceW + 2, entranceY - 6
                        );
                        kioskGrad.addColorStop(0, '#0AF');
                        kioskGrad.addColorStop(0.5, '#08D');
                        kioskGrad.addColorStop(1, '#0AF');
                        ctx.fillStyle = kioskGrad;
                        ctx.fillRect(entranceX - 2, entranceY - 6, entranceW + 4, 6);
                        
                        // Metro sign
                        ctx.fillStyle = '#FFF';
                        ctx.font = 'bold 8px monospace';
                        ctx.fillText('M', entranceX + entranceW / 2 - 3, entranceY - 1);
                        
                        // Entrance opening
                        ctx.fillStyle = '#222';
                        ctx.fillRect(entranceX, entranceY, entranceW, entranceH);
                        ctx.strokeStyle = '#0AF';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(entranceX, entranceY, entranceW, entranceH);
                        
                        // Stairwell from ground to platform
                        const stairwellGrad = ctx.createLinearGradient(
                            entranceX, entranceY + entranceH,
                            entranceX, sY
                        );
                        stairwellGrad.addColorStop(0, '#444');
                        stairwellGrad.addColorStop(0.5, '#333');
                        stairwellGrad.addColorStop(1, '#222');
                        ctx.fillStyle = stairwellGrad;
                        ctx.fillRect(entranceX, entranceY + entranceH, entranceW, sY - (entranceY + entranceH));
                        
                        // Stairs inside stairwell
                        ctx.strokeStyle = '#666';
                        ctx.lineWidth = 1.5;
                        const stairCount = Math.floor((sY - (entranceY + entranceH)) / 2.5);
                        for (let i = 0; i < stairCount; i++) {
                            const stepY = entranceY + entranceH + i * 2.5;
                            ctx.beginPath();
                            ctx.moveTo(entranceX + 2, stepY);
                            ctx.lineTo(entranceX + entranceW - 2, stepY);
                            ctx.stroke();
                        }
                        
                        // Handrails
                        ctx.strokeStyle = '#0AF';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(entranceX + 2, entranceY + entranceH);
                        ctx.lineTo(entranceX + 2, sY);
                        ctx.moveTo(entranceX + entranceW - 2, entranceY + entranceH);
                        ctx.lineTo(entranceX + entranceW - 2, sY);
                        ctx.stroke();
                        
                        // Station platform
                        const platformGrad = ctx.createLinearGradient(sX, sY, sX, sY + sH);
                        platformGrad.addColorStop(0, '#444');
                        platformGrad.addColorStop(1, '#333');
                        ctx.fillStyle = platformGrad;
                        ctx.fillRect(sX, sY, sW, sH);
                        ctx.strokeStyle = '#555';
                        ctx.strokeRect(sX, sY, sW, sH);
                        
                        // Platform edge (yellow safety line)
                        ctx.fillStyle = '#FF0';
                        ctx.fillRect(sX, sY + sH - 1, sW, 1);
                        
                        // Station lights
                        ctx.fillStyle = '#FFF';
                        ctx.shadowBlur = 4;
                        ctx.shadowColor = '#FFF';
                        ctx.fillRect(sX + 3, sY + 2, 2, 2);
                        ctx.fillRect(sX + sW - 5, sY + 2, 2, 2);
                        ctx.shadowBlur = 0;
                        
                        // Station signage
                        ctx.fillStyle = '#0AF';
                        ctx.font = 'bold 8px monospace';
                        ctx.fillText('M', sX + sW / 2 - 3, sY + 8);
                        
                        // Capacity indicator
                        ctx.fillStyle = '#0F0';
                        ctx.font = '7px monospace';
                        ctx.fillText(`${station.people.length}/${station.capacity}`, sX + 2, sY + sH - 2);
                        
                        // Draw people on platform
                        station.people.forEach((person, i) => {
                            const px = sX + 2 + (i % 6) * 3;
                            const py = sY + 4 + Math.floor(i / 6) * 3;
                            ctx.fillStyle = '#FFA500';
                            ctx.fillRect(px, py, 2, 2);
                        });
                    });
                }
            }
        }

        class Building {
            constructor(x, type, terrainY) {
                this.type = type;
                this.specs = BUILDING_TYPES[type];
                this.x = x;
                this.width = this.specs.width;
                this.height = this.specs.height;
                this.y = terrainY;
                this.maxHealth = this.specs.health;
                this.health = this.specs.health;
                this.price = this.specs.price;
                this.destroyed = false;
                this.isUnderground = type === 'subway';
                this.damageMarks = []; // Track damage locations for visual cracks
            }

            takeDamage(amount = 1) {
                this.health -= amount;
                
                // Add damage mark at random location on building
                this.damageMarks.push({
                    x: Math.random() * this.width,
                    y: Math.random() * this.height,
                    type: Math.floor(Math.random() * 3) // 3 types of damage marks
                });
                
                // Track repair costs for each hit (not just when destroyed)
                const damageRepairCost = Math.floor((this.specs.repairCost || this.price * 0.8) * (amount / this.maxHealth));
                
                // Determine which side's buildings are being damaged
                if (gameState.phase === 'attack' && viewMode === 'enemy') {
                    // We are attacking enemy buildings
                    enemyWeapons.repairCost += damageRepairCost;
                } else {
                    // Our own buildings are being damaged (defense mode or own city)
                    const defendingSide = gameState.currentSide;
                    gameState[defendingSide].repairCost += damageRepairCost;
                }
                
                if (this.health <= 0) {
                    this.destroyed = true;
                    createExplosion(this.x + this.width / 2, this.y - this.height / 2, 30);
                    
                    // Determine which side's buildings are being destroyed
                    if (gameState.phase === 'attack' && viewMode === 'enemy') {
                        // We are attacking enemy buildings - track for enemy
                        const attackingSide = gameState.currentSide; // Player is attacking
                        gameState[attackingSide].destructionValue += this.price;
                        
                        // Enemy takes damage
                        enemyWeapons.buildingsDestroyed++;
                        
                        const civilianLoss = Math.floor(Math.random() * 10) + 5;
                        const wounded = Math.floor(Math.random() * 15) + 10;
                        enemyWeapons.casualties += civilianLoss;
                        enemyWeapons.wounded += wounded;
                        enemyWeapons.civilians = Math.max(0, enemyWeapons.civilians - civilianLoss);
                        enemyWeapons.health = Math.max(0, enemyWeapons.health - 2);
                        
                        if (this.type === 'house' || this.type === 'apartment') {
                            enemyWeapons.food = Math.max(0, enemyWeapons.food - Math.floor(Math.random() * 100) - 50);
                        }
                    } else {
                        // Our own buildings are being destroyed (defense mode or own city)
                        const defendingSide = gameState.currentSide;
                        const attackingSide = gameState.currentSide === 'good' ? 'evil' : 'good';
                        
                        gameState[attackingSide].destructionValue += this.price;
                        gameState[defendingSide].buildingsDestroyed++;
                        
                        const civilianLoss = Math.floor(Math.random() * 10) + 5;
                        const wounded = Math.floor(Math.random() * 15) + 10;
                        gameState[defendingSide].casualties += civilianLoss;
                        gameState[defendingSide].wounded += wounded;
                        gameState[defendingSide].civilians = Math.max(0, gameState[defendingSide].civilians - civilianLoss);
                        gameState[defendingSide].health = Math.max(0, gameState[defendingSide].health - 2);
                        
                        if (this.type === 'house' || this.type === 'apartment') {
                            gameState[defendingSide].food = Math.max(0, gameState[defendingSide].food - Math.floor(Math.random() * 100) - 50);
                        }
                    }
                }
                
                updateDisplay();
            }

            render(ctx) {
                const healthPercent = this.health / this.maxHealth;
                const yPos = this.isUnderground ? canvas.height - 80 : this.y;

                // Photo-realistic rendering
                ctx.imageSmoothingEnabled = true;

                // If destroyed, draw ruins instead of building
                if (this.destroyed) {
                    this.renderRuins(ctx, yPos);
                    return;
                }

                // Building color based on health with realistic shading
                let color = this.specs.color;
                if (healthPercent < 0.3) {
                    color = '#333';
                } else if (healthPercent < 0.6) {
                    color = this.darkenColor(this.specs.color, 0.6);
                }

                // Realistic shadow
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 10;
                ctx.shadowOffsetX = 5;
                ctx.shadowOffsetY = 5;

                // Draw building with gradient
                const gradient = ctx.createLinearGradient(this.x, yPos - this.height, this.x + this.width, yPos);
                gradient.addColorStop(0, this.lightenColor(color, 1.2));
                gradient.addColorStop(0.5, color);
                gradient.addColorStop(1, this.darkenColor(color, 0.8));
                
                ctx.fillStyle = gradient;
                ctx.fillRect(this.x, yPos - this.height, this.width, this.height);
                
                ctx.shadowColor = 'transparent';
                
                // Realistic outline with depth
                ctx.strokeStyle = this.darkenColor(color, 0.5);
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, yPos - this.height, this.width, this.height);

                // Special rendering based on type - Photo-realistic style
                switch(this.type) {
                    case 'house':
                        // Pitched triangular roof with shingles
                        const roofGradient = ctx.createLinearGradient(this.x, yPos - this.height - 12, this.x, yPos - this.height);
                        roofGradient.addColorStop(0, '#B22222');
                        roofGradient.addColorStop(0.4, '#A52A2A');
                        roofGradient.addColorStop(1, '#8B0000');
                        ctx.fillStyle = roofGradient;
                        ctx.beginPath();
                        ctx.moveTo(this.x - 2, yPos - this.height);
                        ctx.lineTo(this.x + this.width / 2, yPos - this.height - 12);
                        ctx.lineTo(this.x + this.width + 2, yPos - this.height);
                        ctx.closePath();
                        ctx.fill();
                        ctx.strokeStyle = '#5D0000';
                        ctx.lineWidth = 1.5;
                        ctx.stroke();
                        
                        // Roof ridge detail
                        ctx.strokeStyle = '#6D0000';
                        ctx.beginPath();
                        ctx.moveTo(this.x + 2, yPos - this.height - 10);
                        ctx.lineTo(this.x + this.width - 2, yPos - this.height - 10);
                        ctx.stroke();
                        
                        // Chimney on roof
                        const chimneyGrad = ctx.createLinearGradient(this.x + this.width - 8, yPos - this.height - 12, this.x + this.width - 4, yPos - this.height - 12);
                        chimneyGrad.addColorStop(0, '#8B4513');
                        chimneyGrad.addColorStop(1, '#654321');
                        ctx.fillStyle = chimneyGrad;
                        ctx.fillRect(this.x + this.width - 8, yPos - this.height - 18, 4, 8);
                        ctx.strokeStyle = '#3D2817';
                        ctx.strokeRect(this.x + this.width - 8, yPos - this.height - 18, 4, 8);
                        
                        // Realistic glowing windows with frames
                        if (healthPercent > 0.5) {
                            const windowGradient = ctx.createRadialGradient(this.x + 8, yPos - this.height + 11, 0, this.x + 8, yPos - this.height + 11, 5);
                            windowGradient.addColorStop(0, '#FFFFDD');
                            windowGradient.addColorStop(0.3, '#FFFFAA');
                            windowGradient.addColorStop(0.7, '#FFFF00');
                            windowGradient.addColorStop(1, '#CC9900');
                            ctx.shadowBlur = 6;
                            ctx.shadowColor = 'rgba(255, 255, 0, 0.5)';
                            ctx.fillStyle = windowGradient;
                            ctx.fillRect(this.x + 4, yPos - this.height + 7, 7, 8);
                            ctx.fillRect(this.x + 14, yPos - this.height + 7, 7, 8);
                            ctx.shadowBlur = 0;
                            
                            // Window panes
                            ctx.strokeStyle = '#8B7355';
                            ctx.lineWidth = 1;
                            ctx.strokeRect(this.x + 4, yPos - this.height + 7, 7, 8);
                            ctx.strokeRect(this.x + 14, yPos - this.height + 7, 7, 8);
                            ctx.beginPath();
                            ctx.moveTo(this.x + 7.5, yPos - this.height + 7);
                            ctx.lineTo(this.x + 7.5, yPos - this.height + 15);
                            ctx.moveTo(this.x + 17.5, yPos - this.height + 7);
                            ctx.lineTo(this.x + 17.5, yPos - this.height + 15);
                            ctx.stroke();
                        } else {
                            ctx.fillStyle = '#1a1a1a';
                            ctx.fillRect(this.x + 4, yPos - this.height + 7, 7, 8);
                            ctx.fillRect(this.x + 14, yPos - this.height + 7, 7, 8);
                            ctx.strokeStyle = '#000';
                            ctx.strokeRect(this.x + 4, yPos - this.height + 7, 7, 8);
                            ctx.strokeRect(this.x + 14, yPos - this.height + 7, 7, 8);
                        }
                        
                        // Door with wood grain and handle
                        const doorGradient = ctx.createLinearGradient(this.x + 8, yPos - 12, this.x + 16, yPos - 12);
                        doorGradient.addColorStop(0, '#A0826D');
                        doorGradient.addColorStop(0.2, '#8B6914');
                        doorGradient.addColorStop(0.5, '#654321');
                        doorGradient.addColorStop(0.8, '#5D4227');
                        doorGradient.addColorStop(1, '#4A3310');
                        ctx.fillStyle = doorGradient;
                        ctx.fillRect(this.x + 8, yPos - 12, 9, 12);
                        ctx.strokeStyle = '#2A1A00';
                        ctx.lineWidth = 1.5;
                        ctx.strokeRect(this.x + 8, yPos - 12, 9, 12);
                        
                        // Door handle
                        ctx.fillStyle = '#FFD700';
                        ctx.beginPath();
                        ctx.arc(this.x + 15, yPos - 6, 1, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Wood grain lines
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                        ctx.lineWidth = 0.5;
                        for (let i = 0; i < 3; i++) {
                            ctx.beginPath();
                            ctx.moveTo(this.x + 9, yPos - 10 + i * 3);
                            ctx.lineTo(this.x + 16, yPos - 10 + i * 3);
                            ctx.stroke();
                        }
                        break;
                    
                    case 'factory':
                        // Industrial metal smokestacks with rivets
                        const stackGradient = ctx.createLinearGradient(this.x + 10, yPos - this.height - 12, this.x + 16, yPos - this.height - 12);
                        stackGradient.addColorStop(0, '#999');
                        stackGradient.addColorStop(0.3, '#777');
                        stackGradient.addColorStop(0.6, '#555');
                        stackGradient.addColorStop(1, '#333');
                        ctx.fillStyle = stackGradient;
                        
                        // Left smokestack (taller)
                        ctx.fillRect(this.x + 8, yPos - this.height - 16, 8, 16);
                        ctx.strokeStyle = '#222';
                        ctx.lineWidth = 1.5;
                        ctx.strokeRect(this.x + 8, yPos - this.height - 16, 8, 16);
                        
                        // Right smokestack (shorter)
                        ctx.fillRect(this.x + 24, yPos - this.height - 20, 8, 20);
                        ctx.strokeRect(this.x + 24, yPos - this.height - 20, 8, 20);
                        
                        // Metallic rivets on stacks
                        ctx.fillStyle = '#AAA';
                        for (let i = 0; i < 3; i++) {
                            ctx.beginPath();
                            ctx.arc(this.x + 10, yPos - this.height - 14 + i * 5, 0.8, 0, Math.PI * 2);
                            ctx.arc(this.x + 14, yPos - this.height - 14 + i * 5, 0.8, 0, Math.PI * 2);
                            ctx.arc(this.x + 26, yPos - this.height - 18 + i * 6, 0.8, 0, Math.PI * 2);
                            ctx.arc(this.x + 30, yPos - this.height - 18 + i * 6, 0.8, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        // Stack tops
                        ctx.fillStyle = '#666';
                        ctx.fillRect(this.x + 7, yPos - this.height - 18, 10, 2);
                        ctx.fillRect(this.x + 23, yPos - this.height - 22, 10, 2);
                        
                        if (healthPercent > 0.5) {
                            // Realistic industrial smoke
                            ctx.shadowBlur = 12;
                            ctx.shadowColor = 'rgba(80, 80, 80, 0.4)';
                            
                            const smokeGradient1 = ctx.createRadialGradient(this.x + 12, yPos - this.height - 22, 0, this.x + 12, yPos - this.height - 22, 10);
                            smokeGradient1.addColorStop(0, 'rgba(120, 120, 120, 0.9)');
                            smokeGradient1.addColorStop(0.4, 'rgba(90, 90, 90, 0.6)');
                            smokeGradient1.addColorStop(0.7, 'rgba(70, 70, 70, 0.3)');
                            smokeGradient1.addColorStop(1, 'rgba(60, 60, 60, 0)');
                            ctx.fillStyle = smokeGradient1;
                            ctx.beginPath();
                            ctx.arc(this.x + 12, yPos - this.height - 22, 8, 0, Math.PI * 2);
                            ctx.fill();
                            
                            const smokeGradient2 = ctx.createRadialGradient(this.x + 28, yPos - this.height - 26, 0, this.x + 28, yPos - this.height - 26, 10);
                            smokeGradient2.addColorStop(0, 'rgba(120, 120, 120, 0.9)');
                            smokeGradient2.addColorStop(0.4, 'rgba(90, 90, 90, 0.6)');
                            smokeGradient2.addColorStop(0.7, 'rgba(70, 70, 70, 0.3)');
                            smokeGradient2.addColorStop(1, 'rgba(60, 60, 60, 0)');
                            ctx.fillStyle = smokeGradient2;
                            ctx.beginPath();
                            ctx.arc(this.x + 28, yPos - this.height - 26, 8, 0, Math.PI * 2);
                            ctx.fill();
                            
                            ctx.shadowBlur = 0;
                            ctx.shadowColor = 'transparent';
                        }
                        
                        // Industrial windows grid with metal frames
                        const windowColor = healthPercent > 0.5 ? '#FFA500' : '#222';
                        ctx.strokeStyle = '#444';
                        ctx.lineWidth = 1;
                        for (let i = 0; i < 3; i++) {
                            for (let j = 0; j < 3; j++) {
                                if (healthPercent > 0.5) {
                                    const winGrad = ctx.createRadialGradient(
                                        this.x + 5 + i * 11, yPos - this.height + 8 + j * 14, 0,
                                        this.x + 5 + i * 11, yPos - this.height + 8 + j * 14, 4
                                    );
                                    winGrad.addColorStop(0, '#FFB52E');
                                    winGrad.addColorStop(0.5, '#FFA500');
                                    winGrad.addColorStop(1, '#CC8400');
                                    ctx.fillStyle = winGrad;
                                } else {
                                    ctx.fillStyle = windowColor;
                                }
                                ctx.fillRect(this.x + 4 + i * 11, yPos - this.height + 5 + j * 14, 7, 10);
                                ctx.strokeRect(this.x + 4 + i * 11, yPos - this.height + 5 + j * 14, 7, 10);
                            }
                        }
                        
                        // Loading bay door
                        const bayGrad = ctx.createLinearGradient(this.x + 5, yPos - 15, this.x + 5, yPos);
                        bayGrad.addColorStop(0, '#666');
                        bayGrad.addColorStop(1, '#444');
                        ctx.fillStyle = bayGrad;
                        ctx.fillRect(this.x + 5, yPos - 15, 10, 15);
                        ctx.strokeStyle = '#222';
                        ctx.strokeRect(this.x + 5, yPos - 15, 10, 15);
                        
                        // Door horizontal bands
                        ctx.strokeStyle = '#555';
                        for (let i = 1; i < 4; i++) {
                            ctx.beginPath();
                            ctx.moveTo(this.x + 5, yPos - 15 + i * 4);
                            ctx.lineTo(this.x + 15, yPos - 15 + i * 4);
                            ctx.stroke();
                        }
                        break;
                    
                    case 'school':
                    case 'hospital':
                    case 'office':
                        // Modern glass windows with reflections
                        const cols = Math.floor(this.width / 12);
                        const rows = Math.floor(this.height / 12);
                        for (let i = 0; i < Math.min(cols, 3); i++) {
                            for (let j = 0; j < Math.min(rows, 5); j++) {
                                const wx = this.x + 5 + i * 10;
                                const wy = yPos - this.height + 5 + j * 10;
                                
                                if (healthPercent > 0.5) {
                                    const wGrad = ctx.createLinearGradient(wx, wy, wx + 6, wy + 6);
                                    wGrad.addColorStop(0, '#FFFFCC');
                                    wGrad.addColorStop(0.3, '#FFFF88');
                                    wGrad.addColorStop(0.7, '#CCCC00');
                                    wGrad.addColorStop(1, '#999900');
                                    ctx.fillStyle = wGrad;
                                } else {
                                    ctx.fillStyle = '#333';
                                }
                                ctx.fillRect(wx, wy, 6, 6);
                                
                                // Glass reflection effect
                                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                                ctx.fillRect(wx, wy, 2, 2);
                            }
                        }
                        
                        // Special markers
                        if (this.type === 'hospital') {
                            // 3D red cross
                            const crossGrad = ctx.createRadialGradient(this.x + this.width/2, yPos - this.height + 5, 0, this.x + this.width/2, yPos - this.height + 5, 6);
                            crossGrad.addColorStop(0, '#FF3333');
                            crossGrad.addColorStop(0.5, '#FF0000');
                            crossGrad.addColorStop(1, '#CC0000');
                            ctx.fillStyle = crossGrad;
                            ctx.fillRect(this.x + this.width/2 - 1, yPos - this.height + 2, 2, 8);
                            ctx.fillRect(this.x + this.width/2 - 4, yPos - this.height + 5, 8, 2);
                        }
                        break;
                    
                    case 'tree':
                        // Realistic tree with foliage
                        ctx.shadowBlur = 5;
                        ctx.shadowColor = 'rgba(0, 100, 0, 0.5)';
                        const treeGrad = ctx.createRadialGradient(this.x + 6, yPos - this.height + 6, 0, this.x + 6, yPos - this.height + 6, 8);
                        treeGrad.addColorStop(0, '#33AA33');
                        treeGrad.addColorStop(0.5, '#228B22');
                        treeGrad.addColorStop(1, '#1B6B1B');
                        ctx.fillStyle = treeGrad;
                        ctx.beginPath();
                        ctx.arc(this.x + 6, yPos - this.height + 6, 7, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                        
                        // Bark texture
                        const trunkGrad = ctx.createLinearGradient(this.x + 5, yPos - 8, this.x + 7, yPos - 8);
                        trunkGrad.addColorStop(0, '#8B6914');
                        trunkGrad.addColorStop(0.5, '#654321');
                        trunkGrad.addColorStop(1, '#4A3310');
                        ctx.fillStyle = trunkGrad;
                        ctx.fillRect(this.x + 5, yPos - 8, 2, 8);
                        break;
                    
                    case 'bush':
                        // Realistic bush cluster
                        ctx.shadowBlur = 3;
                        ctx.shadowColor = 'rgba(0, 100, 0, 0.3)';
                        const bushGrad = ctx.createRadialGradient(this.x + 5, yPos - 5, 0, this.x + 5, yPos - 5, 5);
                        bushGrad.addColorStop(0, '#66FF66');
                        bushGrad.addColorStop(0.5, '#32CD32');
                        bushGrad.addColorStop(1, '#228B22');
                        ctx.fillStyle = bushGrad;
                        ctx.beginPath();
                        ctx.arc(this.x + 3, yPos - 4, 3, 0, Math.PI * 2);
                        ctx.arc(this.x + 7, yPos - 5, 3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                        break;
                    
                    case 'bigfarm':
                        // Realistic barn
                        const barnGrad = ctx.createLinearGradient(this.x + 5, yPos - 25, this.x + 25, yPos - 25);
                        barnGrad.addColorStop(0, '#A52A2A');
                        barnGrad.addColorStop(0.5, '#8B0000');
                        barnGrad.addColorStop(1, '#6B0000');
                        ctx.fillStyle = barnGrad;
                        ctx.fillRect(this.x + 5, yPos - 25, 20, 15);
                        ctx.strokeStyle = '#4B0000';
                        ctx.strokeRect(this.x + 5, yPos - 25, 20, 15);
                        
                        // Roof
                        const roofGrad2 = ctx.createLinearGradient(this.x + 15, yPos - 32, this.x + 15, yPos - 25);
                        roofGrad2.addColorStop(0, '#666');
                        roofGrad2.addColorStop(1, '#444');
                        ctx.fillStyle = roofGrad2;
                        ctx.beginPath();
                        ctx.moveTo(this.x + 5, yPos - 25);
                        ctx.lineTo(this.x + 15, yPos - 32);
                        ctx.lineTo(this.x + 25, yPos - 25);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Farm fields with rows
                        for (let i = 0; i < 5; i++) {
                            const fieldGrad = ctx.createLinearGradient(this.x + 30 + i * 7, yPos - 15, this.x + 30 + i * 7, yPos - 3);
                            fieldGrad.addColorStop(0, '#F5DEB3');
                            fieldGrad.addColorStop(0.5, '#F0E68C');
                            fieldGrad.addColorStop(1, '#DAA520');
                            ctx.fillStyle = fieldGrad;
                            ctx.fillRect(this.x + 30 + i * 7, yPos - 15, 5, 12);
                            ctx.strokeStyle = '#8B4513';
                            ctx.strokeRect(this.x + 30 + i * 7, yPos - 15, 5, 12);
                        }
                        break;
                    
                    case 'pool':
                        // Realistic water with ripples
                        const waterGrad = ctx.createLinearGradient(this.x + 3, yPos - this.height + 3, this.x + 3, yPos - 3);
                        waterGrad.addColorStop(0, '#00CED1');
                        waterGrad.addColorStop(0.3, '#20B2AA');
                        waterGrad.addColorStop(0.7, '#008B8B');
                        waterGrad.addColorStop(1, '#006666');
                        ctx.fillStyle = waterGrad;
                        ctx.fillRect(this.x + 3, yPos - this.height + 3, this.width - 6, this.height - 6);
                        
                        // Water highlights
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.fillRect(this.x + 5, yPos - this.height + 5, this.width - 10, 3);
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                        ctx.fillRect(this.x + 7, yPos - this.height + 12, this.width - 14, 2);
                        break;
                    
                    case 'powerplant':
                        // Realistic cooling towers
                        const towerGrad = ctx.createLinearGradient(this.x + 8, yPos - this.height - 10, this.x + 23, yPos - this.height - 10);
                        towerGrad.addColorStop(0, '#D3D3D3');
                        towerGrad.addColorStop(0.5, '#B0C4DE');
                        towerGrad.addColorStop(1, '#8899AA');
                        ctx.fillStyle = towerGrad;
                        ctx.fillRect(this.x + 8, yPos - this.height - 10, 15, 10);
                        ctx.fillRect(this.x + 35, yPos - this.height - 10, 15, 10);
                        ctx.strokeStyle = '#6688AA';
                        ctx.strokeRect(this.x + 8, yPos - this.height - 10, 15, 10);
                        ctx.strokeRect(this.x + 35, yPos - this.height - 10, 15, 10);
                        
                        if (healthPercent > 0.5) {
                            // Realistic steam
                            ctx.shadowBlur = 10;
                            const steamGrad = ctx.createRadialGradient(this.x + 15, yPos - this.height - 16, 0, this.x + 15, yPos - this.height - 16, 8);
                            steamGrad.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                            steamGrad.addColorStop(0.5, 'rgba(200, 200, 200, 0.4)');
                            steamGrad.addColorStop(1, 'rgba(150, 150, 150, 0.1)');
                            ctx.fillStyle = steamGrad;
                            ctx.beginPath();
                            ctx.arc(this.x + 15, yPos - this.height - 16, 7, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.beginPath();
                            ctx.arc(this.x + 42, yPos - this.height - 16, 7, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.shadowBlur = 0;
                        }
                        
                        // Building windows
                        for (let i = 0; i < 4; i++) {
                            const wg = ctx.createLinearGradient(this.x + 5 + i * 12, yPos - this.height + 10, this.x + 5 + i * 12, yPos - this.height + 16);
                            wg.addColorStop(0, '#FFFFAA');
                            wg.addColorStop(1, '#CCAA00');
                            ctx.fillStyle = wg;
                            ctx.fillRect(this.x + 5 + i * 12, yPos - this.height + 10, 6, 6);
                        }
                        break;
                    
                    case 'powerline':
                        // Realistic metal tower
                        ctx.strokeStyle = '#696969';
                        ctx.lineWidth = 3;
                        ctx.shadowBlur = 3;
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                        
                        const metalGrad = ctx.createLinearGradient(this.x + 1, yPos - this.height, this.x + 7, yPos - this.height);
                        metalGrad.addColorStop(0, '#888');
                        metalGrad.addColorStop(0.5, '#666');
                        metalGrad.addColorStop(1, '#444');
                        ctx.strokeStyle = metalGrad;
                        
                        ctx.beginPath();
                        ctx.moveTo(this.x + 4, yPos - this.height);
                        ctx.lineTo(this.x + 1, yPos);
                        ctx.moveTo(this.x + 4, yPos - this.height);
                        ctx.lineTo(this.x + 7, yPos);
                        ctx.moveTo(this.x + 2, yPos - this.height + 10);
                        ctx.lineTo(this.x + 6, yPos - this.height + 10);
                        ctx.moveTo(this.x + 2, yPos - this.height + 20);
                        ctx.lineTo(this.x + 6, yPos - this.height + 20);
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                        ctx.lineWidth = 1;
                        break;
                    
                    case 'subway':
                        // Underground entrance
                        const entranceGrad = ctx.createRadialGradient(this.x + 17, yPos - this.height + 12, 0, this.x + 17, yPos - this.height + 12, 15);
                        entranceGrad.addColorStop(0, '#222');
                        entranceGrad.addColorStop(0.7, '#000');
                        entranceGrad.addColorStop(1, '#000');
                        ctx.fillStyle = entranceGrad;
                        ctx.fillRect(this.x + 8, yPos - this.height + 5, 18, 15);
                        ctx.strokeStyle = '#666';
                        ctx.strokeRect(this.x + 8, yPos - this.height + 5, 18, 15);
                        
                        // Metro sign with glow
                        ctx.shadowBlur = 5;
                        ctx.shadowColor = '#FFD700';
                        const signGrad = ctx.createRadialGradient(this.x + 5, yPos - this.height + 5, 0, this.x + 5, yPos - this.height + 5, 4);
                        signGrad.addColorStop(0, '#FFFF00');
                        signGrad.addColorStop(0.5, '#FFD700');
                        signGrad.addColorStop(1, '#CC9900');
                        ctx.fillStyle = signGrad;
                        ctx.fillRect(this.x + 2, yPos - this.height + 2, 6, 6);
                        ctx.shadowBlur = 0;
                        
                        ctx.fillStyle = '#000';
                        ctx.font = 'bold 6px Arial';
                        ctx.fillText('M', this.x + 3, yPos - this.height + 7);
                        
                        // Stairs with depth
                        const stairGrad = ctx.createLinearGradient(this.x + 10, yPos - this.height + 8, this.x + 24, yPos - this.height + 8);
                        stairGrad.addColorStop(0, '#777');
                        stairGrad.addColorStop(0.5, '#555');
                        stairGrad.addColorStop(1, '#333');
                        ctx.fillStyle = stairGrad;
                        ctx.fillRect(this.x + 10, yPos - this.height + 8, 14, 2);
                        ctx.fillRect(this.x + 12, yPos - this.height + 11, 10, 2);
                        ctx.fillRect(this.x + 14, yPos - this.height + 14, 6, 2);
                        break;
                    
                    case 'government':
                        // Marble columns
                        for (let i = 0; i < 4; i++) {
                            const colGrad = ctx.createLinearGradient(this.x + 5 + i * 12, yPos - this.height + 10, this.x + 11 + i * 12, yPos - this.height + 10);
                            colGrad.addColorStop(0, '#FFF');
                            colGrad.addColorStop(0.5, '#EEE');
                            colGrad.addColorStop(1, '#CCC');
                            ctx.fillStyle = colGrad;
                            ctx.fillRect(this.x + 5 + i * 12, yPos - this.height + 10, 6, this.height - 10);
                            ctx.strokeStyle = '#AAA';
                            ctx.strokeRect(this.x + 5 + i * 12, yPos - this.height + 10, 6, this.height - 10);
                        }
                        
                        // Gold top triangle
                        const goldGrad = ctx.createLinearGradient(this.x, yPos - this.height - 10, this.x, yPos - this.height);
                        goldGrad.addColorStop(0, '#FFD700');
                        goldGrad.addColorStop(0.5, '#DAA520');
                        goldGrad.addColorStop(1, '#B8860B');
                        ctx.fillStyle = goldGrad;
                        ctx.beginPath();
                        ctx.moveTo(this.x, yPos - this.height);
                        ctx.lineTo(this.x + this.width / 2, yPos - this.height - 10);
                        ctx.lineTo(this.x + this.width, yPos - this.height);
                        ctx.closePath();
                        ctx.fill();
                        ctx.strokeStyle = '#8B6914';
                        ctx.stroke();
                        break;
                    
                    case 'theatre':
                        // Velvet curtains
                        const curtainGrad = ctx.createLinearGradient(this.x + 3, yPos - this.height + 3, this.x + 11, yPos - this.height + 3);
                        curtainGrad.addColorStop(0, '#AA00AA');
                        curtainGrad.addColorStop(0.5, '#8B008B');
                        curtainGrad.addColorStop(1, '#6B006B');
                        ctx.fillStyle = curtainGrad;
                        ctx.fillRect(this.x + 3, yPos - this.height + 3, 8, this.height - 6);
                        ctx.fillRect(this.x + this.width - 11, yPos - this.height + 3, 8, this.height - 6);
                        
                        // Stage with lighting
                        const stageGrad = ctx.createLinearGradient(this.x + 12, yPos - 15, this.x + 12, yPos - 5);
                        stageGrad.addColorStop(0, '#F5DEB3');
                        stageGrad.addColorStop(0.5, '#DEB887');
                        stageGrad.addColorStop(1, '#A0826D');
                        ctx.fillStyle = stageGrad;
                        ctx.fillRect(this.x + 12, yPos - 15, this.width - 24, 10);
                        break;
                    
                    case 'shop':
                        // Striped awning with fabric texture
                        const awningGrad = ctx.createLinearGradient(this.x, yPos - this.height, this.x, yPos - this.height + 6);
                        awningGrad.addColorStop(0, '#FF6347');
                        awningGrad.addColorStop(0.5, '#FF4500');
                        awningGrad.addColorStop(1, '#CC3300');
                        ctx.fillStyle = awningGrad;
                        ctx.fillRect(this.x, yPos - this.height, this.width, 6);
                        ctx.strokeStyle = '#AA2200';
                        ctx.strokeRect(this.x, yPos - this.height, this.width, 6);
                        
                        // Stripes
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                        for (let i = 0; i < 3; i++) {
                            ctx.fillRect(this.x + 5 + i * 8, yPos - this.height + 1, 3, 4);
                        }
                        
                        // Shop windows with reflection
                        if (healthPercent > 0.5) {
                            const shopWinGrad = ctx.createLinearGradient(this.x + 5, yPos - this.height + 10, this.x + 5, yPos - this.height + 18);
                            shopWinGrad.addColorStop(0, '#FFFFCC');
                            shopWinGrad.addColorStop(0.5, '#FFFF00');
                            shopWinGrad.addColorStop(1, '#CCCC00');
                            ctx.fillStyle = shopWinGrad;
                        } else {
                            ctx.fillStyle = '#333';
                        }
                        ctx.fillRect(this.x + 5, yPos - this.height + 10, 8, 8);
                        ctx.fillRect(this.x + 15, yPos - this.height + 10, 8, 8);
                        
                        // Glass reflection
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                        ctx.fillRect(this.x + 5, yPos - this.height + 10, 3, 3);
                        ctx.fillRect(this.x + 15, yPos - this.height + 10, 3, 3);
                        break;
                }

                // Draw damage marks (cracks, holes, burns)
                this.damageMarks.forEach(mark => {
                    const markX = this.x + mark.x;
                    const markY = yPos - mark.y;
                    
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
                    ctx.lineWidth = 1;
                    
                    if (mark.type === 0) {
                        // Crack pattern
                        ctx.beginPath();
                        ctx.moveTo(markX, markY);
                        ctx.lineTo(markX + 5 + Math.random() * 3, markY + 8 + Math.random() * 3);
                        ctx.moveTo(markX, markY);
                        ctx.lineTo(markX - 5 - Math.random() * 3, markY + 6 + Math.random() * 3);
                        ctx.moveTo(markX, markY);
                        ctx.lineTo(markX + 2, markY - 5 - Math.random() * 2);
                        ctx.stroke();
                    } else if (mark.type === 1) {
                        // Burn mark
                        ctx.fillStyle = 'rgba(20, 20, 20, 0.7)';
                        ctx.beginPath();
                        ctx.arc(markX, markY, 3 + Math.random() * 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = 'rgba(40, 20, 0, 0.5)';
                        ctx.beginPath();
                        ctx.arc(markX, markY, 2, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        // Impact hole
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                        ctx.fillRect(markX - 2, markY - 2, 4, 4);
                        ctx.fillStyle = 'rgba(100, 50, 0, 0.6)';
                        ctx.fillRect(markX - 1, markY - 1, 2, 2);
                    }
                });

                // Health bar with realistic styling
                if (healthPercent < 1) {
                    const barWidth = this.width;
                    const barHeight = 3;
                    const barX = this.x;
                    const barY = yPos - this.height - 5;
                    
                    // Background
                    ctx.fillStyle = '#000';
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                    
                    // Health gradient
                    const healthGrad = ctx.createLinearGradient(barX, barY, barX + barWidth * healthPercent, barY);
                    if (healthPercent > 0.6) {
                        healthGrad.addColorStop(0, '#00ff00');
                        healthGrad.addColorStop(1, '#00cc00');
                    } else if (healthPercent > 0.3) {
                        healthGrad.addColorStop(0, '#ffcc00');
                        healthGrad.addColorStop(1, '#ff8800');
                    } else {
                        healthGrad.addColorStop(0, '#ff0000');
                        healthGrad.addColorStop(1, '#cc0000');
                    }
                    ctx.fillStyle = healthGrad;
                    ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);
                    
                    // Highlight
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.fillRect(barX, barY, barWidth * healthPercent, 1);
                }
            }

            darkenColor(color, factor) {
                if (!color || typeof color !== 'string') return '#000000';
                if (color.startsWith('rgb')) return color; // Already processed
                
                const hex = color.replace('#', '');
                if (hex.length !== 6) return color; // Invalid hex
                
                const r = Math.floor(parseInt(hex.substr(0, 2), 16) * factor);
                const g = Math.floor(parseInt(hex.substr(2, 2), 16) * factor);
                const b = Math.floor(parseInt(hex.substr(4, 2), 16) * factor);
                return `rgb(${r}, ${g}, ${b})`;
            }

            lightenColor(color, factor) {
                if (!color || typeof color !== 'string') return '#FFFFFF';
                if (color.startsWith('rgb')) return color; // Already processed
                
                const hex = color.replace('#', '');
                if (hex.length !== 6) return color; // Invalid hex
                
                let r = parseInt(hex.substr(0, 2), 16);
                let g = parseInt(hex.substr(2, 2), 16);
                let b = parseInt(hex.substr(4, 2), 16);
                r = Math.min(255, Math.floor(r * factor));
                g = Math.min(255, Math.floor(g * factor));
                b = Math.min(255, Math.floor(b * factor));
                return `rgb(${r}, ${g}, ${b})`;
            }

            renderRuins(ctx, yPos) {
                // Draw building ruins - broken walls, rubble, etc.
                ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                ctx.shadowBlur = 5;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;

                // Darken the original color for ruins
                const ruinColor = '#3a3a3a';
                const rubbleColor = '#555555';
                
                // Draw partial collapsed walls (about 30% of original height)
                const ruinHeight = this.height * 0.3;
                
                // Left wall fragment
                ctx.fillStyle = ruinColor;
                ctx.fillRect(this.x, yPos - ruinHeight, this.width * 0.4, ruinHeight);
                
                // Right wall fragment (shorter)
                ctx.fillRect(this.x + this.width * 0.6, yPos - ruinHeight * 0.7, this.width * 0.4, ruinHeight * 0.7);
                
                // Add jagged broken edges on top
                ctx.fillStyle = '#2a2a2a';
                ctx.beginPath();
                ctx.moveTo(this.x, yPos - ruinHeight);
                ctx.lineTo(this.x + this.width * 0.1, yPos - ruinHeight - 5);
                ctx.lineTo(this.x + this.width * 0.2, yPos - ruinHeight + 3);
                ctx.lineTo(this.x + this.width * 0.3, yPos - ruinHeight - 2);
                ctx.lineTo(this.x + this.width * 0.4, yPos - ruinHeight);
                ctx.lineTo(this.x + this.width * 0.4, yPos - ruinHeight + 5);
                ctx.lineTo(this.x, yPos - ruinHeight + 5);
                ctx.fill();
                
                // Rubble pile at the base
                for (let i = 0; i < 8; i++) {
                    const rubbleX = this.x + Math.random() * this.width;
                    const rubbleSize = 3 + Math.random() * 5;
                    ctx.fillStyle = i % 2 === 0 ? rubbleColor : '#666666';
                    ctx.fillRect(rubbleX, yPos - rubbleSize, rubbleSize, rubbleSize);
                }
                
                // Cracks and damage marks
                ctx.strokeStyle = '#1a1a1a';
                ctx.lineWidth = 1.5;
                for (let i = 0; i < 5; i++) {
                    ctx.beginPath();
                    const crackX = this.x + Math.random() * this.width * 0.4;
                    const crackY = yPos - ruinHeight + Math.random() * ruinHeight;
                    ctx.moveTo(crackX, crackY);
                    ctx.lineTo(crackX + Math.random() * 10 - 5, crackY + Math.random() * 15);
                    ctx.stroke();
                }
                
                // Smoke/dust particles (optional - can be added if desired)
                ctx.fillStyle = 'rgba(100, 100, 100, 0.3)';
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.arc(this.x + this.width * 0.5 + (Math.random() - 0.5) * 20, 
                           yPos - ruinHeight - 10 - i * 8, 
                           3 + i * 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
            }
        }

        class Tank {
            constructor(side) {
                this.side = side; // 'good' or 'evil'
                this.x = canvas.width / 2;
                
                // Position tank on the road instead of terrain
                if (terrain && groundLayer && groundLayer.roads && groundLayer.roads.length > 0) {
                    const road = groundLayer.roads[0]; // Main road
                    const terrainBase = terrain.getHeightAt(this.x);
                    this.baseY = terrainBase + groundLayer.offsetY + road.y + road.height / 2;
                } else {
                    this.baseY = terrain ? terrain.getHeightAt(this.x) : canvas.height - 215;
                }
                
                this.y = this.baseY - 15;
                this.width = 35;
                this.height = 18;
                this.turretAngle = -Math.PI / 2;
                this.targetAngle = -Math.PI / 2;
            }

            update() {
                // Update position based on road location
                if (terrain && groundLayer && groundLayer.roads && groundLayer.roads.length > 0) {
                    const road = groundLayer.roads[0]; // Main road
                    const terrainBase = terrain.getHeightAt(this.x);
                    this.baseY = terrainBase + groundLayer.offsetY + road.y + road.height / 2;
                    this.y = this.baseY - 15;
                } else if (terrain) {
                    this.baseY = terrain.getHeightAt(this.x);
                    this.y = this.baseY - 15;
                }
                
                // Smooth turret rotation
                const diff = this.targetAngle - this.turretAngle;
                this.turretAngle += diff * 0.1;
            }

            aimAt(x, y) {
                this.targetAngle = Math.atan2(y - this.y, x - this.x);
            }

            shoot() {
                const bulletSpeed = 10;
                const bullet = new Bullet(
                    this.x,
                    this.y - 10,
                    Math.cos(this.turretAngle) * bulletSpeed,
                    Math.sin(this.turretAngle) * bulletSpeed,
                    this.side
                );
                bullets.push(bullet);
                playSound('shoot');
            }

            render(ctx) {
                ctx.imageSmoothingEnabled = true;
                
                // Realistic shadow
                ctx.shadowColor = 'rgba(0, 0, 0, 0.6)';
                ctx.shadowBlur = 8;
                ctx.shadowOffsetX = 4;
                ctx.shadowOffsetY = 4;
                
                // Tank body - metallic gradient
                const bodyGrad = ctx.createLinearGradient(this.x - this.width / 2, this.y - this.height / 2, this.x + this.width / 2, this.y + this.height / 2);
                if (this.side === 'good') {
                    bodyGrad.addColorStop(0, '#0077DD');
                    bodyGrad.addColorStop(0.5, '#0057B7');
                    bodyGrad.addColorStop(1, '#003D82');
                } else {
                    bodyGrad.addColorStop(0, '#FF5555');
                    bodyGrad.addColorStop(0.5, '#D52B1E');
                    bodyGrad.addColorStop(1, '#A32116');
                }
                ctx.fillStyle = bodyGrad;
                ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                
                // Metallic highlight
                const highlightGrad = ctx.createLinearGradient(this.x - this.width / 2, this.y - this.height / 2, this.x - this.width / 2, this.y - this.height / 2 + 8);
                highlightGrad.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
                highlightGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = highlightGrad;
                ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, 8);
                
                // Realistic tracks
                const trackGrad = ctx.createLinearGradient(this.x - this.width / 2 - 2, this.y, this.x + this.width / 2 + 2, this.y);
                trackGrad.addColorStop(0, '#333');
                trackGrad.addColorStop(0.5, '#222');
                trackGrad.addColorStop(1, '#333');
                ctx.fillStyle = trackGrad;
                ctx.fillRect(this.x - this.width / 2 - 2, this.y - this.height / 2 + 2, this.width + 4, 4);
                ctx.fillRect(this.x - this.width / 2 - 2, this.y + this.height / 2 - 6, this.width + 4, 4);
                
                // Turret base with gradient
                const turretBaseGrad = ctx.createRadialGradient(this.x, this.y - 8, 0, this.x, this.y - 8, 10);
                if (this.side === 'good') {
                    turretBaseGrad.addColorStop(0, '#004DA0');
                    turretBaseGrad.addColorStop(1, '#003D82');
                } else {
                    turretBaseGrad.addColorStop(0, '#CC3333');
                    turretBaseGrad.addColorStop(1, '#A32116');
                }
                ctx.fillStyle = turretBaseGrad;
                ctx.fillRect(this.x - 8, this.y - 12, 16, 8);
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.strokeRect(this.x - 8, this.y - 12, 16, 8);
                
                // Turret barrel with metallic sheen
                ctx.save();
                ctx.translate(this.x, this.y - 8);
                ctx.rotate(this.turretAngle);
                
                const barrelGrad = ctx.createLinearGradient(0, -2, 0, 2);
                if (this.side === 'good') {
                    barrelGrad.addColorStop(0, '#FFEE88');
                    barrelGrad.addColorStop(0.5, '#FFD700');
                    barrelGrad.addColorStop(1, '#CC9900');
                } else {
                    barrelGrad.addColorStop(0, '#FFF');
                    barrelGrad.addColorStop(0.5, '#EEE');
                    barrelGrad.addColorStop(1, '#CCC');
                }
                ctx.fillStyle = barrelGrad;
                ctx.fillRect(0, -2, 18, 4);
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.strokeRect(0, -2, 18, 4);
                
                // Barrel highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.fillRect(0, -2, 18, 1);
                
                ctx.restore();

                // Realistic flag with wave effect
                ctx.shadowBlur = 3;
                ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                
                const flagGrad = ctx.createLinearGradient(this.x - 2, this.y - 22, this.x + 2, this.y - 22);
                if (this.side === 'good') {
                    flagGrad.addColorStop(0, '#FFE44D');
                    flagGrad.addColorStop(0.5, '#FFD700');
                    flagGrad.addColorStop(1, '#CCAA00');
                } else {
                    flagGrad.addColorStop(0, '#FFF');
                    flagGrad.addColorStop(0.5, '#EEE');
                    flagGrad.addColorStop(1, '#DDD');
                }
                ctx.fillStyle = flagGrad;
                ctx.fillRect(this.x - 2, this.y - 22, 4, 6);
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
                ctx.strokeRect(this.x - 2, this.y - 22, 4, 6);
                
                ctx.shadowBlur = 0;
                
                // Flag pole
                ctx.fillStyle = '#555';
                ctx.fillRect(this.x, this.y - 22, 1, 8);
            }
        }

        // AI-controlled Enemy Tank
        class EnemyTank {
            constructor() {
                this.x = canvas.width / 2;
                
                // Position on enemy terrain
                if (enemyTerrain && enemyGroundLayer && enemyGroundLayer.roads && enemyGroundLayer.roads.length > 0) {
                    const road = enemyGroundLayer.roads[0];
                    const terrainBase = enemyTerrain.getHeightAt(this.x);
                    this.baseY = terrainBase + enemyGroundLayer.offsetY + road.y + road.height / 2;
                } else if (enemyTerrain) {
                    this.baseY = enemyTerrain.getHeightAt(this.x);
                } else {
                    this.baseY = canvas.height - 215;
                }
                
                this.y = this.baseY - 15;
                this.width = 35;
                this.height = 18;
                this.turretAngle = -Math.PI / 2;
                this.targetAngle = -Math.PI / 2;
                this.shootCooldown = 0;
                this.detectionRange = 600;
                this.reactionTime = 30; // Frames before reacting
                this.reactionCounter = 0;
            }

            update() {
                // Update position based on terrain
                if (enemyTerrain && enemyGroundLayer && enemyGroundLayer.roads && enemyGroundLayer.roads.length > 0) {
                    const road = enemyGroundLayer.roads[0];
                    const terrainBase = enemyTerrain.getHeightAt(this.x);
                    this.baseY = terrainBase + enemyGroundLayer.offsetY + road.y + road.height / 2;
                    this.y = this.baseY - 15;
                } else if (enemyTerrain) {
                    this.baseY = enemyTerrain.getHeightAt(this.x);
                    this.y = this.baseY - 15;
                }
                
                // Smooth turret rotation
                const diff = this.targetAngle - this.turretAngle;
                this.turretAngle += diff * 0.1;
                
                // AI: Find and target incoming offensive weapons
                if (window.offensiveWeapons && window.offensiveWeapons.length > 0) {
                    let closestWeapon = null;
                    let closestDist = this.detectionRange;
                    
                    window.offensiveWeapons.forEach(weapon => {
                        if (!weapon.exploded && !weapon.destroyed && weapon.canBeIntercepted) {
                            const dist = Math.sqrt((weapon.x - this.x) ** 2 + (weapon.y - this.y) ** 2);
                            if (dist < closestDist) {
                                closestDist = dist;
                                closestWeapon = weapon;
                            }
                        }
                    });
                    
                    if (closestWeapon) {
                        // Aim at the weapon
                        this.targetAngle = Math.atan2(closestWeapon.y - this.y, closestWeapon.x - this.x);
                        
                        // Shoot at it
                        this.shootCooldown--;
                        if (this.shootCooldown <= 0) {
                            this.shoot();
                            this.shootCooldown = 20; // Fire rate
                        }
                    } else {
                        // No target - aim upward
                        this.targetAngle = -Math.PI / 2;
                        this.shootCooldown = Math.max(0, this.shootCooldown - 1);
                    }
                } else {
                    this.shootCooldown = Math.max(0, this.shootCooldown - 1);
                }
            }

            shoot() {
                const bulletSpeed = 10;
                const bullet = {
                    x: this.x,
                    y: this.y - 10,
                    vx: Math.cos(this.turretAngle) * bulletSpeed,
                    vy: Math.sin(this.turretAngle) * bulletSpeed,
                    radius: 2,
                    dead: false,
                    trail: []
                };
                enemyBullets.push(bullet);
                playSound('shoot');
            }

            render(ctx) {
                ctx.imageSmoothingEnabled = true;
                
                // Realistic shadow
                ctx.shadowColor = 'rgba(0, 0, 0, 0.6)';
                ctx.shadowBlur = 8;
                ctx.shadowOffsetX = 4;
                ctx.shadowOffsetY = 4;
                
                // Tank body - evil red metallic gradient
                const bodyGrad = ctx.createLinearGradient(this.x - this.width / 2, this.y - this.height / 2, this.x + this.width / 2, this.y + this.height / 2);
                bodyGrad.addColorStop(0, '#8B0000');
                bodyGrad.addColorStop(0.5, '#660000');
                bodyGrad.addColorStop(1, '#440000');
                ctx.fillStyle = bodyGrad;
                ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                
                // Turret base
                const turretBaseGrad = ctx.createRadialGradient(this.x, this.y - 8, 0, this.x, this.y - 8, 8);
                turretBaseGrad.addColorStop(0, '#AA0000');
                turretBaseGrad.addColorStop(1, '#660000');
                ctx.fillStyle = turretBaseGrad;
                ctx.fillRect(this.x - 8, this.y - 12, 16, 8);
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.strokeRect(this.x - 8, this.y - 12, 16, 8);
                
                // Turret barrel
                ctx.save();
                ctx.translate(this.x, this.y - 8);
                ctx.rotate(this.turretAngle);
                
                const barrelGrad = ctx.createLinearGradient(0, -2, 0, 2);
                barrelGrad.addColorStop(0, '#CC4444');
                barrelGrad.addColorStop(0.5, '#AA0000');
                barrelGrad.addColorStop(1, '#660000');
                ctx.fillStyle = barrelGrad;
                ctx.fillRect(0, -2, 18, 4);
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.strokeRect(0, -2, 18, 4);
                
                ctx.restore();
            }
        }

        // Defensive Drone - flies and shoots laser beams
        class DefensiveDrone {
            constructor(side) {
                this.side = side;
                this.x = Math.random() * canvas.width;
                this.y = 100 + Math.random() * 150;
                this.targetX = this.x;
                this.targetY = this.y;
                this.speed = 2;
                this.shootCooldown = 0;
                this.shootInterval = 60; // Shoot every 60 frames
                this.detectionRange = 400;
            }

            update() {
                // Move towards target position
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 5) {
                    this.x += (dx / dist) * this.speed;
                    this.y += (dy / dist) * this.speed;
                } else {
                    // Pick new random patrol position
                    this.targetX = Math.random() * canvas.width;
                    this.targetY = 100 + Math.random() * 150;
                }

                // Hover effect
                this.y += Math.sin(Date.now() * 0.003) * 0.5;

                // Find and shoot at nearest enemy
                this.shootCooldown--;
                if (this.shootCooldown <= 0) {
                    const nearestEnemy = this.findNearestEnemy();
                    if (nearestEnemy) {
                        this.shootAt(nearestEnemy);
                        this.shootCooldown = this.shootInterval;
                    }
                }
            }

            findNearestEnemy() {
                let nearest = null;
                let minDist = this.detectionRange;
                
                // In defense phase, target incoming enemy missiles
                enemies.forEach(enemy => {
                    const dx = enemy.x - this.x;
                    const dy = enemy.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = enemy;
                    }
                });
                
                // In attack phase (for enemy defensive units), target our offensive weapons
                if (gameState.phase === 'attack' && window.offensiveWeapons) {
                    window.offensiveWeapons.forEach(weapon => {
                        if (!weapon.exploded && !weapon.destroyed && weapon.canBeIntercepted) {
                            const dx = weapon.x - this.x;
                            const dy = weapon.y - this.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < minDist) {
                                minDist = dist;
                                nearest = weapon;
                            }
                        }
                    });
                }
                
                return nearest;
            }

            shootAt(target) {
                const angle = Math.atan2(target.y - this.y, target.x - this.x);
                const bulletSpeed = 8;
                bullets.push(new Bullet(
                    this.x,
                    this.y,
                    Math.cos(angle) * bulletSpeed,
                    Math.sin(angle) * bulletSpeed,
                    this.side
                ));
                playSound('shoot');
            }

            render(ctx) {
                // Drone body
                ctx.fillStyle = this.side === 'good' ? '#0057B7' : '#D52B1E';
                ctx.fillRect(this.x - 8, this.y - 3, 16, 6);
                
                // Propellers
                const propAngle = (Date.now() * 0.5) % 360;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                
                // Front propellers
                for (let i = 0; i < 4; i++) {
                    const angle = (propAngle + i * 90) * Math.PI / 180;
                    ctx.beginPath();
                    ctx.moveTo(this.x - 10, this.y);
                    ctx.lineTo(this.x - 10 + Math.cos(angle) * 5, this.y + Math.sin(angle) * 5);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(this.x + 10, this.y);
                    ctx.lineTo(this.x + 10 + Math.cos(angle) * 5, this.y + Math.sin(angle) * 5);
                    ctx.stroke();
                }
                
                // Camera/sensor
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(this.x, this.y + 2, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Defensive Interceptor - fast missile interceptor
        class DefensiveInterceptor {
            constructor(side) {
                this.side = side;
                this.x = Math.random() * canvas.width;
                this.y = 50 + Math.random() * 100;
                this.targetX = this.x;
                this.targetY = this.y;
                this.speed = 4;
                this.shootCooldown = 0;
                this.shootInterval = 40;
                this.detectionRange = 500;
            }

            update() {
                // Fast patrol
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 5) {
                    this.x += (dx / dist) * this.speed;
                    this.y += (dy / dist) * this.speed;
                } else {
                    this.targetX = Math.random() * canvas.width;
                    this.targetY = 50 + Math.random() * 100;
                }

                // Shoot at enemies
                this.shootCooldown--;
                if (this.shootCooldown <= 0) {
                    const nearestEnemy = this.findNearestEnemy();
                    if (nearestEnemy) {
                        this.shootAt(nearestEnemy);
                        this.shootCooldown = this.shootInterval;
                    }
                }
            }

            findNearestEnemy() {
                let nearest = null;
                let minDist = this.detectionRange;
                
                enemies.forEach(enemy => {
                    const dx = enemy.x - this.x;
                    const dy = enemy.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = enemy;
                    }
                });
                
                return nearest;
            }

            shootAt(target) {
                const angle = Math.atan2(target.y - this.y, target.x - this.x);
                const bulletSpeed = 12;
                bullets.push(new Bullet(
                    this.x,
                    this.y,
                    Math.cos(angle) * bulletSpeed,
                    Math.sin(angle) * bulletSpeed,
                    this.side
                ));
                playSound('shoot');
            }

            render(ctx) {
                // Sleek interceptor design
                const angle = Math.atan2(this.targetY - this.y, this.targetX - this.x);
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(angle);
                
                // Body
                ctx.fillStyle = this.side === 'good' ? '#FFD700' : '#FFF';
                ctx.beginPath();
                ctx.moveTo(15, 0);
                ctx.lineTo(-8, -4);
                ctx.lineTo(-8, 4);
                ctx.closePath();
                ctx.fill();
                
                // Cockpit
                ctx.fillStyle = '#333';
                ctx.fillRect(5, -2, 4, 4);
                
                // Wings
                ctx.fillStyle = this.side === 'good' ? '#0057B7' : '#D52B1E';
                ctx.fillRect(-5, -8, 10, 2);
                ctx.fillRect(-5, 6, 10, 2);
                
                ctx.restore();
            }
        }

        // Defensive Soldier - ground unit with laser cannon
        class DefensiveSoldier {
            constructor(side) {
                this.side = side;
                this.x = 50 + Math.random() * (canvas.width - 100);
                
                if (terrain && groundLayer) {
                    const terrainHeight = terrain.getHeightAt(this.x);
                    this.y = terrainHeight + groundLayer.offsetY - 10;
                } else {
                    this.y = canvas.height - 100;
                }
                
                this.targetX = this.x;
                this.speed = 1;
                this.shootCooldown = 0;
                this.shootInterval = 80;
                this.detectionRange = 450;
                this.facing = 1; // 1 = right, -1 = left
            }

            update() {
                // Update Y position based on terrain
                if (terrain && groundLayer) {
                    const terrainHeight = terrain.getHeightAt(this.x);
                    this.y = terrainHeight + groundLayer.offsetY - 10;
                }

                // Patrol movement
                const dx = this.targetX - this.x;
                if (Math.abs(dx) > 5) {
                    this.x += Math.sign(dx) * this.speed;
                    this.facing = Math.sign(dx);
                } else {
                    this.targetX = 50 + Math.random() * (canvas.width - 100);
                }

                // Shoot laser at enemies
                this.shootCooldown--;
                if (this.shootCooldown <= 0) {
                    const nearestEnemy = this.findNearestEnemy();
                    if (nearestEnemy) {
                        this.shootLaser(nearestEnemy);
                        this.shootCooldown = this.shootInterval;
                    }
                }
            }

            findNearestEnemy() {
                let nearest = null;
                let minDist = this.detectionRange;
                
                enemies.forEach(enemy => {
                    const dx = enemy.x - this.x;
                    const dy = enemy.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = enemy;
                    }
                });
                
                return nearest;
            }

            shootLaser(target) {
                const angle = Math.atan2(target.y - this.y, target.x - this.x);
                const bulletSpeed = 10;
                bullets.push(new Bullet(
                    this.x + this.facing * 8,
                    this.y - 8,
                    Math.cos(angle) * bulletSpeed,
                    Math.sin(angle) * bulletSpeed,
                    this.side,
                    true // Laser bullet
                ));
                playSound('shoot');
            }

            render(ctx) {
                // Body
                ctx.fillStyle = this.side === 'good' ? '#0057B7' : '#D52B1E';
                ctx.fillRect(this.x - 3, this.y - 10, 6, 10);
                
                // Head
                ctx.fillStyle = '#FDB';
                ctx.fillRect(this.x - 2, this.y - 13, 4, 3);
                
                // Helmet
                ctx.fillStyle = this.side === 'good' ? '#FFD700' : '#555';
                ctx.fillRect(this.x - 2.5, this.y - 15, 5, 2);
                
                // Laser cannon
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.x + this.facing * 3, this.y - 8);
                ctx.lineTo(this.x + this.facing * 10, this.y - 8);
                ctx.stroke();
                
                // Legs
                ctx.strokeStyle = this.side === 'good' ? '#004494' : '#A32116';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.x - 1, this.y);
                ctx.lineTo(this.x - 2, this.y + 5);
                ctx.moveTo(this.x + 1, this.y);
                ctx.lineTo(this.x + 2, this.y + 5);
                ctx.stroke();
            }
        }

        // Defensive Tank - heavy armored unit
        class DefensiveTank {
            constructor(side) {
                this.side = side;
                this.x = 100 + Math.random() * (canvas.width - 200);
                
                if (terrain && groundLayer) {
                    const terrainHeight = terrain.getHeightAt(this.x);
                    this.y = terrainHeight + groundLayer.offsetY - 20;
                } else {
                    this.y = canvas.height - 120;
                }
                
                this.width = 30;
                this.height = 15;
                this.turretAngle = -Math.PI / 2;
                this.shootCooldown = 0;
                this.shootInterval = 120;
                this.detectionRange = 500;
            }

            update() {
                // Update Y position based on terrain
                if (terrain && groundLayer) {
                    const terrainHeight = terrain.getHeightAt(this.x);
                    this.y = terrainHeight + groundLayer.offsetY - 20;
                }

                // Find and aim at nearest enemy
                const nearestEnemy = this.findNearestEnemy();
                if (nearestEnemy) {
                    this.turretAngle = Math.atan2(nearestEnemy.y - this.y, nearestEnemy.x - this.x);
                    
                    this.shootCooldown--;
                    if (this.shootCooldown <= 0) {
                        this.shoot();
                        this.shootCooldown = this.shootInterval;
                    }
                }
            }

            findNearestEnemy() {
                let nearest = null;
                let minDist = this.detectionRange;
                
                enemies.forEach(enemy => {
                    const dx = enemy.x - this.x;
                    const dy = enemy.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = enemy;
                    }
                });
                
                return nearest;
            }

            shoot() {
                const bulletSpeed = 10;
                bullets.push(new Bullet(
                    this.x + Math.cos(this.turretAngle) * 15,
                    this.y + Math.sin(this.turretAngle) * 15,
                    Math.cos(this.turretAngle) * bulletSpeed,
                    Math.sin(this.turretAngle) * bulletSpeed,
                    this.side
                ));
                playSound('shoot');
            }

            render(ctx) {
                // Tank body
                ctx.fillStyle = this.side === 'good' ? '#0057B7' : '#D52B1E';
                ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                
                // Tracks
                ctx.fillStyle = '#333';
                ctx.fillRect(this.x - this.width / 2 - 2, this.y - this.height / 2 + 2, this.width + 4, 3);
                ctx.fillRect(this.x - this.width / 2 - 2, this.y + this.height / 2 - 5, this.width + 4, 3);
                
                // Turret
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.turretAngle);
                
                ctx.fillStyle = this.side === 'good' ? '#FFD700' : '#FFF';
                ctx.fillRect(0, -2, 15, 4);
                
                ctx.restore();
                
                // Turret base
                ctx.fillStyle = this.side === 'good' ? '#004494' : '#A32116';
                ctx.fillRect(this.x - 6, this.y - 6, 12, 6);
            }
        }

        // Defensive Heavy Weapon - stationary powerful weapon
        class DefensiveHeavyWeapon {
            constructor(side) {
                this.side = side;
                this.x = 80 + Math.random() * (canvas.width - 160);
                
                if (terrain && groundLayer) {
                    const terrainHeight = terrain.getHeightAt(this.x);
                    this.y = terrainHeight + groundLayer.offsetY - 15;
                } else {
                    this.y = canvas.height - 115;
                }
                
                this.angle = -Math.PI / 2;
                this.shootCooldown = 0;
                this.shootInterval = 150;
                this.detectionRange = 600;
                this.barrelRecoil = 0;
            }

            update() {
                // Update Y position based on terrain
                if (terrain && groundLayer) {
                    const terrainHeight = terrain.getHeightAt(this.x);
                    this.y = terrainHeight + groundLayer.offsetY - 15;
                }

                // Recoil animation
                if (this.barrelRecoil > 0) {
                    this.barrelRecoil *= 0.8;
                    if (this.barrelRecoil < 0.5) this.barrelRecoil = 0;
                }

                // Find and shoot at enemies
                const nearestEnemy = this.findNearestEnemy();
                if (nearestEnemy) {
                    this.angle = Math.atan2(nearestEnemy.y - this.y, nearestEnemy.x - this.x);
                    
                    this.shootCooldown--;
                    if (this.shootCooldown <= 0) {
                        this.shoot();
                        this.shootCooldown = this.shootInterval;
                        this.barrelRecoil = 8;
                    }
                }
            }

            findNearestEnemy() {
                let nearest = null;
                let minDist = this.detectionRange;
                
                enemies.forEach(enemy => {
                    const dx = enemy.x - this.x;
                    const dy = enemy.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = enemy;
                    }
                });
                
                return nearest;
            }

            shoot() {
                // Shoot 3 bullets in a spread
                for (let i = -1; i <= 1; i++) {
                    const spreadAngle = this.angle + (i * 0.1);
                    const bulletSpeed = 12;
                    bullets.push(new Bullet(
                        this.x + Math.cos(spreadAngle) * 20,
                        this.y + Math.sin(spreadAngle) * 20,
                        Math.cos(spreadAngle) * bulletSpeed,
                        Math.sin(spreadAngle) * bulletSpeed,
                        this.side
                    ));
                }
                playSound('shoot');
            }

            render(ctx) {
                // Base platform
                ctx.fillStyle = '#555';
                ctx.fillRect(this.x - 15, this.y, 30, 8);
                
                // Support legs
                ctx.strokeStyle = '#444';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(this.x - 12, this.y);
                ctx.lineTo(this.x - 18, this.y + 15);
                ctx.moveTo(this.x + 12, this.y);
                ctx.lineTo(this.x + 18, this.y + 15);
                ctx.stroke();
                
                // Rotating mount
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                // Heavy barrel with recoil
                const barrelLength = 25 - this.barrelRecoil;
                ctx.fillStyle = this.side === 'good' ? '#FFD700' : '#FFF';
                ctx.fillRect(0, -3, barrelLength, 6);
                
                // Barrel tip
                ctx.fillStyle = '#333';
                ctx.fillRect(barrelLength, -2, 3, 4);
                
                ctx.restore();
                
                // Mount body
                ctx.fillStyle = this.side === 'good' ? '#0057B7' : '#D52B1E';
                ctx.fillRect(this.x - 8, this.y - 8, 16, 8);
            }
        }


        class Bullet {
            constructor(x, y, vx, vy, side, isLaser = false) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.side = side;
                this.radius = 2;
                this.dead = false;
                this.trail = [];
                this.isLaser = isLaser;
            }

            update() {
                // Store trail
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > 5) this.trail.shift();
                
                this.x += this.vx;
                this.y += this.vy;

                // Check collision with enemies
                enemies.forEach(enemy => {
                    if (!enemy.dead && !enemy.converted) {
                        const dist = Math.sqrt((this.x - enemy.x) ** 2 + (this.y - enemy.y) ** 2);
                        if (dist < enemy.radius + this.radius) {
                            enemy.hit();
                            this.dead = true;
                        }
                    }
                });
                
                // Check collision with offensive weapons (can hit enemy weapons in defense mode, or enemy shooting our weapons in attack)
                if (window.offensiveWeapons) {
                    window.offensiveWeapons.forEach(weapon => {
                        if (!weapon.exploded && !weapon.destroyed && weapon.canBeIntercepted) {
                            // Only hit if it's from the opposite side
                            const isEnemyWeapon = weapon.side === 'evil';
                            const isPlayerBullet = this.side === 'good';
                            const isEnemyBullet = this.side === 'evil';
                            
                            // Player bullets hit enemy weapons, enemy bullets hit player weapons
                            if ((isPlayerBullet && isEnemyWeapon) || (isEnemyBullet && !isEnemyWeapon)) {
                                const dist = Math.sqrt((this.x - weapon.x) ** 2 + (this.y - weapon.y) ** 2);
                                if (dist < (weapon.radius || 10) + this.radius) {
                                    weapon.exploded = true;
                                    weapon.destroyed = true;
                                    this.dead = true;
                                    createExplosion(weapon.x, weapon.y, 25);
                                    playSound('explosion');
                                    
                                    // Determine who gets the reward
                                    const rewardMoney = 200;
                                    const actualReward = Math.min(rewardMoney, bankMoney);
                                    
                                    if (isPlayerBullet && isEnemyWeapon) {
                                        // Player shot down enemy weapon
                                        if (actualReward > 0) {
                                            const side = gameState[gameState.currentSide];
                                            side.resources += actualReward;
                                            bankMoney -= actualReward;
                                            showStatus(`üí∞ Enemy weapon destroyed! +$${actualReward}`, 1500);
                                        } else {
                                            showStatus('‚ö†Ô∏è Bank is empty! No reward!', 1500);
                                        }
                                        gameState.enemiesKilled++;
                                    } else if (isEnemyBullet && !isEnemyWeapon) {
                                        // Enemy shot down player weapon
                                        if (actualReward > 0) {
                                            enemyWeapons.resources += actualReward;
                                            bankMoney -= actualReward;
                                            showStatus('‚ùå Weapon intercepted! Enemy earned $' + actualReward, 1500);
                                        } else {
                                            showStatus('‚ùå Weapon intercepted by enemy defenses!', 1500);
                                        }
                                    }
                                    updateDisplay();
                                }
                            }
                        }
                    });
                }

                // During attack phase, bullets can also damage enemy buildings
                if (gameState.phase === 'attack') {
                    enemyBuildings.forEach(building => {
                        if (building.health > 0) {
                            const inX = this.x >= building.x && this.x <= building.x + building.width;
                            const inY = this.y >= building.y - building.height && this.y <= building.y;
                            if (inX && inY) {
                                building.takeDamage(0.5);
                                this.dead = true;
                                particles.push(new Particle(this.x, this.y, '#FFA500'));
                            }
                        }
                    });
                }

                // Remove if off screen
                if (this.y < 0 || this.y > canvas.height || this.x < 0 || this.x > canvas.width) {
                    this.dead = true;
                }
            }

            render(ctx) {
                ctx.imageSmoothingEnabled = true;
                
                // Laser bullets have different rendering
                if (this.isLaser) {
                    // Laser beam effect
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = this.side === 'good' ? '#0FF' : '#F0F';
                    ctx.strokeStyle = this.side === 'good' ? '#0FF' : '#F0F';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x - this.vx * 2, this.y - this.vy * 2);
                    ctx.stroke();
                    
                    // Core beam
                    ctx.strokeStyle = '#FFF';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x - this.vx * 2, this.y - this.vy * 2);
                    ctx.stroke();
                    
                    ctx.shadowBlur = 0;
                    return;
                }
                
                // Regular bullet trail with glow
                this.trail.forEach((pos, i) => {
                    const alpha = i / this.trail.length;
                    ctx.shadowBlur = 5 * alpha;
                    
                    if (this.side === 'good') {
                        ctx.shadowColor = `rgba(255, 215, 0, ${alpha})`;
                        const trailGrad = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, 3);
                        trailGrad.addColorStop(0, `rgba(255, 255, 100, ${alpha * 0.8})`);
                        trailGrad.addColorStop(0.5, `rgba(255, 215, 0, ${alpha * 0.5})`);
                        trailGrad.addColorStop(1, `rgba(255, 180, 0, ${alpha * 0.2})`);
                        ctx.fillStyle = trailGrad;
                    } else {
                        ctx.shadowColor = `rgba(255, 102, 102, ${alpha})`;
                        const trailGrad = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, 3);
                        trailGrad.addColorStop(0, `rgba(255, 150, 150, ${alpha * 0.8})`);
                        trailGrad.addColorStop(0.5, `rgba(255, 102, 102, ${alpha * 0.5})`);
                        trailGrad.addColorStop(1, `rgba(255, 50, 50, ${alpha * 0.2})`);
                        ctx.fillStyle = trailGrad;
                    }
                    
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, 2 * alpha, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                ctx.shadowBlur = 0;
                
                // Glowing bullet with radial gradient
                ctx.shadowBlur = 8;
                const bulletGrad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius * 2);
                if (this.side === 'good') {
                    ctx.shadowColor = '#FFD700';
                    bulletGrad.addColorStop(0, '#FFFFAA');
                    bulletGrad.addColorStop(0.4, '#FFD700');
                    bulletGrad.addColorStop(0.7, '#FFAA00');
                    bulletGrad.addColorStop(1, 'rgba(255, 170, 0, 0)');
                } else {
                    ctx.shadowColor = '#ff6666';
                    bulletGrad.addColorStop(0, '#FFAAAA');
                    bulletGrad.addColorStop(0.4, '#ff6666');
                    bulletGrad.addColorStop(0.7, '#ff3333');
                    bulletGrad.addColorStop(1, 'rgba(255, 51, 51, 0)');
                }
                ctx.fillStyle = bulletGrad;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Core bullet
                ctx.shadowBlur = 3;
                const coreGrad = ctx.createRadialGradient(this.x - 0.5, this.y - 0.5, 0, this.x, this.y, this.radius);
                if (this.side === 'good') {
                    coreGrad.addColorStop(0, '#FFFF66');
                    coreGrad.addColorStop(1, '#FFD700');
                } else {
                    coreGrad.addColorStop(0, '#FF8888');
                    coreGrad.addColorStop(1, '#ff6666');
                }
                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
            }
        }

        class Enemy {
            constructor(isAttacking) {
                this.isAttacking = isAttacking; // true = going down to attack, false = coming from top
                
                if (isAttacking) {
                    // Attack mode: start from far away (off-screen) with ballistic trajectory
                    this.x = canvas.width + 200 + Math.random() * 200; // Start far right off-screen
                    this.y = 50 + Math.random() * 100; // Start high in the air
                    this.targetX = Math.random() * canvas.width; // Random target on ground
                    this.targetY = canvas.height - 150; // Target ground level
                    
                    // Calculate ballistic trajectory
                    const dx = this.targetX - this.x;
                    const dy = this.targetY - this.y;
                    const totalTime = 120; // Frames to reach target
                    
                    this.vx = dx / totalTime;
                    this.vy = -4; // Start going up for arc
                    this.gravity = 0.15; // Gravity pulls missile down
                    this.hasApex = false; // Track if missile has reached arc peak
                } else {
                    // Defense mode: appear from top with cargo
                    this.x = Math.random() * canvas.width;
                    this.y = -50;
                    this.targetY = -50; // Just fly across
                    this.vx = (Math.random() - 0.5) * 2;
                    this.vy = 1;
                    this.gravity = 0;
                }
                
                this.radius = 8;
                this.health = 1;
                this.dead = false;
                this.converted = false;
                this.cargo = this.isAttacking ? null : this.getRandomCargo();
                this.trailPoints = []; // For visual trail effect
            }

            getRandomCargo() {
                const materials = [
                    { value: 1, money: 100, name: 'Aluminium' },
                    { value: 2, money: 150, name: 'Steel' },
                    { value: 3, money: 300, name: 'Chips' },
                    { value: 4, money: 250, name: 'Copper' },
                    { value: 5, money: 500, name: 'Gold' }
                ];
                return materials[Math.floor(Math.random() * materials.length)];
            }

            hit() {
                this.health--;
                if (this.health <= 0) {
                    this.dead = true;
                    createExplosion(this.x, this.y, 20);
                    
                    if (!this.isAttacking && this.cargo) {
                        // Cargo destroyed - no money created, just collect materials
                        const side = gameState.currentSide;
                        gameState[side].materials.push(this.cargo);
                        // No money added - cargo is just materials now
                        gameState.enemiesKilled++;
                    } else if (this.isAttacking) {
                        // Destroyed attacking enemy missile - reward money from BANK
                        const side = gameState.currentSide;
                        const rewardMoney = 200; // Base reward for destroying enemy missile
                        
                        // Money comes from bank (if available)
                        const actualReward = Math.min(rewardMoney, bankMoney);
                        if (actualReward > 0) {
                            gameState[side].resources += actualReward;
                            bankMoney -= actualReward;
                            
                            // Show money reward notification
                            showMoneyReward(this.x, this.y, actualReward);
                        } else {
                            showStatus('‚ö†Ô∏è Bank is empty! No reward!', 1500);
                        }
                        
                        gameState.enemiesKilled++;
                    }
                    
                    playSound('explosion');
                    updateDisplay();
                }
            }

            update() {
                // Store trail points for visual effect
                if (this.isAttacking) {
                    this.trailPoints.push({ x: this.x, y: this.y, life: 20 });
                    if (this.trailPoints.length > 15) {
                        this.trailPoints.shift();
                    }
                    // Update trail life
                    this.trailPoints = this.trailPoints.filter(p => {
                        p.life--;
                        return p.life > 0;
                    });
                }
                
                // Apply ballistic physics for attacking missiles
                if (this.isAttacking) {
                    this.x += this.vx;
                    this.y += this.vy;
                    this.vy += this.gravity; // Apply gravity for ballistic arc
                    
                    // Track if missile has reached apex
                    if (this.vy > 0 && !this.hasApex) {
                        this.hasApex = true;
                    }
                } else {
                    // Regular movement for cargo missiles
                    this.x += this.vx;
                    this.y += this.vy;
                }

                // In attack phase, enemies try to intercept our offensive weapons
                if (gameState.phase === 'attack' && window.offensiveWeapons) {
                    window.offensiveWeapons.forEach(weapon => {
                        if (weapon.canBeIntercepted && !weapon.exploded && !weapon.destroyed) {
                            const dist = Math.sqrt((this.x - weapon.x) ** 2 + (this.y - weapon.y) ** 2);
                            if (dist < this.radius + 15) {
                                // Enemy intercepted our weapon!
                                weapon.exploded = true;
                                weapon.destroyed = true;
                                this.dead = true;
                                createExplosion(weapon.x, weapon.y, 25);
                                playSound('explosion');
                                
                                // Enemy gets points for interception
                                showStatus('‚ùå Weapon intercepted by enemy defense!', 1500);
                            }
                        }
                    });
                }

                if (this.isAttacking) {
                    let hitSomething = false;
                    
                    // Check collision with buildings first
                    for (let building of buildings) {
                        if (!hitSomething && !building.destroyed &&
                            this.x >= building.x - this.radius &&
                            this.x <= building.x + building.width + this.radius) {
                            
                            const buildingTop = building.isUnderground ? 
                                canvas.height - 80 - building.height : 
                                building.y - building.height;
                            
                            if (this.y + this.radius >= buildingTop) {
                                building.takeDamage();
                                this.dead = true;
                                hitSomething = true;
                                createExplosion(this.x, this.y, 25);
                                // Create small crater near building base
                                if (terrain && !building.isUnderground) {
                                    terrain.createCrater(this.x, 10);
                                }
                                playSound('explosion');
                                break;
                            }
                        }
                    }
                    
                    // Check if reached ground (only if didn't hit building)
                    if (!hitSomething && terrain) {
                        const groundLevel = terrain.getHeightAt(this.x);
                        if (this.y + this.radius >= groundLevel) {
                            this.dead = true;
                            createExplosion(this.x, groundLevel, 20);
                            // Create crater on ground impact
                            terrain.createCrater(this.x, 15);
                            
                            // Check for civilian casualties from ground explosion
                            const defendingSide = gameState.currentSide === 'good' ? 'good' : 'evil';
                            const casualties = Math.floor(Math.random() * 3); // 0-2 casualties
                            const wounded = Math.floor(Math.random() * 5); // 0-4 wounded
                            if (casualties > 0) {
                                gameState[defendingSide].casualties += casualties;
                                gameState[defendingSide].civilians = Math.max(0, gameState[defendingSide].civilians - casualties);
                            }
                            if (wounded > 0) {
                                gameState[defendingSide].wounded += wounded;
                                gameState[defendingSide].health = Math.max(0, gameState[defendingSide].health - 1);
                            }
                            
                            playSound('explosion');
                            updateDisplay();
                        }
                    }
                    
                    // Safety check - remove if way below screen
                    if (this.y > canvas.height + 100) {
                        this.dead = true;
                    }
                } else {
                    // Remove if off screen
                    if (this.y > canvas.height || this.x < -50 || this.x > canvas.width + 50) {
                        this.dead = true;
                    }
                }
            }

            render(ctx) {
                ctx.imageSmoothingEnabled = true;
                
                // Draw smoke trail for attacking missiles
                if (this.isAttacking && this.trailPoints.length > 0) {
                    ctx.strokeStyle = 'rgba(150, 150, 150, 0.3)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    this.trailPoints.forEach((point, i) => {
                        const alpha = (point.life / 20) * 0.3;
                        if (i === 0) {
                            ctx.moveTo(point.x, point.y);
                        } else {
                            ctx.lineTo(point.x, point.y);
                        }
                    });
                    ctx.stroke();
                }
                
                // Realistic missile with 3D shading
                const side = this.isAttacking ? 
                    (gameState.currentSide === 'good' ? 'evil' : 'good') : 
                    (gameState.currentSide === 'good' ? 'evil' : 'good');
                
                // Shadow
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 6;
                ctx.shadowOffsetX = 3;
                ctx.shadowOffsetY = 3;
                
                // Missile body with metallic gradient
                const bodyGrad = ctx.createLinearGradient(this.x - 4, this.y - 8, this.x + 4, this.y + 4);
                if (side === 'good') {
                    bodyGrad.addColorStop(0, '#0077DD');
                    bodyGrad.addColorStop(0.5, '#0057B7');
                    bodyGrad.addColorStop(1, '#003D82');
                } else {
                    bodyGrad.addColorStop(0, '#FF5555');
                    bodyGrad.addColorStop(0.5, '#D52B1E');
                    bodyGrad.addColorStop(1, '#A32116');
                }
                ctx.fillStyle = bodyGrad;
                ctx.fillRect(this.x - 4, this.y - 8, 8, 12);
                
                // Nose cone
                const noseGrad = ctx.createLinearGradient(this.x - 2, this.y - 10, this.x + 2, this.y - 8);
                if (side === 'good') {
                    noseGrad.addColorStop(0, '#99CCFF');
                    noseGrad.addColorStop(1, '#0077DD');
                } else {
                    noseGrad.addColorStop(0, '#FF8888');
                    noseGrad.addColorStop(1, '#FF5555');
                }
                ctx.fillStyle = noseGrad;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y - 10);
                ctx.lineTo(this.x + 2, this.y - 8);
                ctx.lineTo(this.x - 2, this.y - 8);
                ctx.closePath();
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                
                // Highlight on body
                const highlightGrad = ctx.createLinearGradient(this.x - 4, this.y - 8, this.x - 1, this.y - 8);
                highlightGrad.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
                highlightGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = highlightGrad;
                ctx.fillRect(this.x - 4, this.y - 8, 3, 12);
                
                // Fins with gradient
                const finGrad = ctx.createLinearGradient(this.x - 6, this.y, this.x + 6, this.y);
                if (side === 'good') {
                    finGrad.addColorStop(0, '#FFE44D');
                    finGrad.addColorStop(0.5, '#FFD700');
                    finGrad.addColorStop(1, '#CCAA00');
                } else {
                    finGrad.addColorStop(0, '#FFAAAA');
                    finGrad.addColorStop(0.5, '#ff6666');
                    finGrad.addColorStop(1, '#ff3333');
                }
                ctx.fillStyle = finGrad;
                ctx.fillRect(this.x - 6, this.y, 2, 4);
                ctx.fillRect(this.x + 4, this.y, 2, 4);
                
                // Outline
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.lineWidth = 1;
                ctx.strokeRect(this.x - 4, this.y - 8, 8, 12);

                // Cargo display with realistic styling
                if (!this.isAttacking && this.cargo) {
                    const cargoGrad = ctx.createLinearGradient(this.x - 8, this.y + 6, this.x - 8, this.y + 14);
                    cargoGrad.addColorStop(0, '#444');
                    cargoGrad.addColorStop(1, '#000');
                    ctx.fillStyle = cargoGrad;
                    ctx.fillRect(this.x - 8, this.y + 6, 16, 8);
                    
                    ctx.shadowBlur = 2;
                    ctx.shadowColor = '#FFD700';
                    const textGrad = ctx.createLinearGradient(this.x - 6, this.y + 8, this.x - 6, this.y + 12);
                    textGrad.addColorStop(0, '#FFFF88');
                    textGrad.addColorStop(1, '#FFD700');
                    ctx.fillStyle = textGrad;
                    ctx.font = 'bold 8px Arial';
                    ctx.fillText(this.cargo.name.substring(0, 2).toUpperCase(), this.x - 6, this.y + 12);
                    ctx.shadowBlur = 0;
                }
                
                // Warning indicator for attacking missiles
                if (this.isAttacking) {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                    ctx.font = 'bold 12px Arial';
                    ctx.fillText('‚ö†', this.x - 6, this.y - 12);
                }

                // Realistic flame trail with multiple colors
                ctx.shadowBlur = 8;
                
                // Outer flame glow
                ctx.shadowColor = 'rgba(255, 100, 0, 0.8)';
                const flameOuterGrad = ctx.createRadialGradient(this.x, this.y + 6, 0, this.x, this.y + 6, 6);
                flameOuterGrad.addColorStop(0, 'rgba(255, 200, 0, 0.9)');
                flameOuterGrad.addColorStop(0.5, 'rgba(255, 100, 0, 0.6)');
                flameOuterGrad.addColorStop(1, 'rgba(255, 50, 0, 0)');
                ctx.fillStyle = flameOuterGrad;
                ctx.beginPath();
                ctx.arc(this.x, this.y + 6, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // Middle flame
                const flameMidGrad = ctx.createRadialGradient(this.x, this.y + 5, 0, this.x, this.y + 5, 4);
                flameMidGrad.addColorStop(0, '#FFFF00');
                flameMidGrad.addColorStop(0.5, '#FFAA00');
                flameMidGrad.addColorStop(1, 'rgba(255, 100, 0, 0)');
                ctx.fillStyle = flameMidGrad;
                ctx.beginPath();
                ctx.arc(this.x, this.y + 5, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner white-hot core
                const flameCoreGrad = ctx.createRadialGradient(this.x, this.y + 4, 0, this.x, this.y + 4, 2);
                flameCoreGrad.addColorStop(0, '#FFFFFF');
                flameCoreGrad.addColorStop(0.5, '#FFFFAA');
                flameCoreGrad.addColorStop(1, '#FFFF00');
                ctx.fillStyle = flameCoreGrad;
                ctx.beginPath();
                ctx.arc(this.x, this.y + 4, 1.5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
            }
        }

        class Explosion {
            constructor(x, y, maxRadius) {
                this.x = x;
                this.y = y;
                this.radius = 0;
                this.maxRadius = maxRadius;
                this.alpha = 1;
                this.done = false;
                this.pixels = [];
                
                // Create pixel explosion pattern
                for (let i = 0; i < 20; i++) {
                    this.pixels.push({
                        offsetX: (Math.random() - 0.5) * maxRadius,
                        offsetY: (Math.random() - 0.5) * maxRadius,
                        size: Math.floor(Math.random() * 3) + 2,
                        speed: Math.random() * 2
                    });
                }
            }

            update() {
                this.radius += 2;
                this.alpha -= 0.05;
                this.pixels.forEach(p => {
                    p.offsetX *= 1.1;
                    p.offsetY *= 1.1;
                });
                if (this.alpha <= 0) {
                    this.done = true;
                }
            }

            render(ctx) {
                ctx.imageSmoothingEnabled = true;
                
                // Realistic particle explosion with gradients
                this.pixels.forEach(p => {
                    const progress = 1 - this.alpha;
                    
                    // Shadow for each particle
                    ctx.shadowBlur = 8 * this.alpha;
                    ctx.shadowColor = 'rgba(255, 100, 0, 0.6)';
                    
                    // Particle gradient - changes color over time
                    const particleGrad = ctx.createRadialGradient(
                        this.x + p.offsetX, 
                        this.y + p.offsetY, 
                        0,
                        this.x + p.offsetX, 
                        this.y + p.offsetY, 
                        p.size * 1.5
                    );
                    
                    if (progress < 0.3) {
                        // Early: white-hot
                        particleGrad.addColorStop(0, `rgba(255, 255, 255, ${this.alpha})`);
                        particleGrad.addColorStop(0.5, `rgba(255, 255, 100, ${this.alpha * 0.8})`);
                        particleGrad.addColorStop(1, `rgba(255, 200, 0, 0)`);
                    } else if (progress < 0.6) {
                        // Middle: yellow-orange
                        particleGrad.addColorStop(0, `rgba(255, 255, 0, ${this.alpha})`);
                        particleGrad.addColorStop(0.5, `rgba(255, 170, 0, ${this.alpha * 0.8})`);
                        particleGrad.addColorStop(1, `rgba(255, 100, 0, 0)`);
                    } else {
                        // Late: orange-red
                        particleGrad.addColorStop(0, `rgba(255, 100, 0, ${this.alpha})`);
                        particleGrad.addColorStop(0.5, `rgba(255, 69, 0, ${this.alpha * 0.7})`);
                        particleGrad.addColorStop(1, `rgba(200, 0, 0, 0)`);
                    }
                    
                    ctx.fillStyle = particleGrad;
                    ctx.globalAlpha = 1; // Alpha is in gradient
                    ctx.beginPath();
                    ctx.arc(
                        this.x + p.offsetX,
                        this.y + p.offsetY,
                        p.size,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                });
                
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
                ctx.globalAlpha = 1;
            }
        }

        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 5;
                this.vy = (Math.random() - 0.5) * 5;
                this.life = 30;
                this.maxLife = 30;
                this.size = Math.floor(Math.random() * 2) + 2;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.2; // gravity
                this.life--;
            }

            render(ctx) {
                ctx.imageSmoothingEnabled = true;
                const alpha = this.life / this.maxLife;
                
                // Shadow for particle
                ctx.shadowBlur = 6 * alpha;
                ctx.shadowColor = `rgba(255, 100, 0, ${alpha * 0.8})`;
                
                // Glowing particle with radial gradient
                const particleGrad = ctx.createRadialGradient(
                    this.x + this.size / 2, 
                    this.y + this.size / 2, 
                    0,
                    this.x + this.size / 2, 
                    this.y + this.size / 2, 
                    this.size * 1.5
                );
                
                // Color progression based on life
                if (alpha > 0.7) {
                    // Fresh: white-yellow
                    particleGrad.addColorStop(0, `rgba(255, 255, 200, ${alpha})`);
                    particleGrad.addColorStop(0.4, `rgba(255, 255, 0, ${alpha * 0.8})`);
                    particleGrad.addColorStop(1, `rgba(255, 170, 0, 0)`);
                } else if (alpha > 0.4) {
                    // Cooling: yellow-orange
                    particleGrad.addColorStop(0, `rgba(255, 255, 0, ${alpha})`);
                    particleGrad.addColorStop(0.4, `rgba(255, 170, 0, ${alpha * 0.8})`);
                    particleGrad.addColorStop(1, `rgba(255, 69, 0, 0)`);
                } else {
                    // Dying: orange-red
                    particleGrad.addColorStop(0, `rgba(255, 100, 0, ${alpha})`);
                    particleGrad.addColorStop(0.4, `rgba(255, 69, 0, ${alpha * 0.7})`);
                    particleGrad.addColorStop(1, `rgba(150, 0, 0, 0)`);
                }
                
                ctx.fillStyle = particleGrad;
                ctx.globalAlpha = 1; // Alpha is in gradient
                ctx.beginPath();
                ctx.arc(this.x + this.size / 2, this.y + this.size / 2, this.size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
                ctx.globalAlpha = 1;
            }
        }

        // Car class - moving vehicles on roads
        class Car {
            constructor(x, y, roadY, direction) {
                this.x = x;
                this.y = y; // Relative to groundLayer base
                this.roadY = roadY; // The road this car is on
                this.direction = direction; // 1 = right, -1 = left
                this.speed = 0.8 + Math.random() * 1.2;
                this.width = 16;
                this.height = 8;
                this.color = this.randomCarColor();
                this.type = Math.random() > 0.3 ? 'car' : 'truck';
                if (this.type === 'truck') {
                    this.width = 24;
                    this.height = 10;
                    this.speed *= 0.7;
                }
            }
            
            randomCarColor() {
                const colors = ['#FF0000', '#0000FF', '#FFFF00', '#00FF00', '#FF00FF', 
                               '#00FFFF', '#FFA500', '#800080', '#C0C0C0', '#000000'];
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            update() {
                this.x += this.speed * this.direction;
                
                // Reset position when off screen
                if (this.direction > 0 && this.x > canvas.width + 50) {
                    this.x = -50;
                } else if (this.direction < 0 && this.x < -50) {
                    this.x = canvas.width + 50;
                }
            }
            
            render(ctx) {
                if (!terrain || !groundLayer) return;
                
                const baseY = terrain.getHeightAt(canvas.width / 2) + groundLayer.offsetY;
                const carY = baseY + this.y;
                
                ctx.imageSmoothingEnabled = false;
                
                // Car shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(this.x, carY + this.height, this.width, 2);
                
                if (this.type === 'car') {
                    // Car body
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.x + 2, carY + 2, this.width - 4, this.height - 2);
                    
                    // Car roof
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.x + 4, carY, this.width - 8, 4);
                    
                    // Windows
                    ctx.fillStyle = '#87CEEB';
                    ctx.fillRect(this.x + 5, carY + 1, 2, 2);
                    ctx.fillRect(this.x + this.width - 7, carY + 1, 2, 2);
                    
                    // Wheels
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(this.x + 3, carY + this.height - 1, 2, 2);
                    ctx.fillRect(this.x + this.width - 5, carY + this.height - 1, 2, 2);
                } else {
                    // Truck body
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.x + 2, carY + 3, this.width - 4, this.height - 3);
                    
                    // Truck cabin
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.x + this.width - 10, carY, 8, 6);
                    
                    // Window
                    ctx.fillStyle = '#87CEEB';
                    ctx.fillRect(this.x + this.width - 9, carY + 1, 2, 3);
                    
                    // Wheels
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(this.x + 4, carY + this.height - 1, 2, 2);
                    ctx.fillRect(this.x + 10, carY + this.height - 1, 2, 2);
                    ctx.fillRect(this.x + this.width - 6, carY + this.height - 1, 2, 2);
                }
                
                ctx.imageSmoothingEnabled = true;
            }
        }

        // Train class - moving on railway
        class Train {
            constructor(x, y) {
                this.x = x;
                this.y = y; // Relative to groundLayer base
                this.speed = 2;
                this.direction = 1; // Always moves right
                this.length = 120; // Total train length
                this.carriages = 4;
                this.carriageWidth = 28;
                this.carriageHeight = 14;
                this.wheelOffset = 0;
                this.wheelSpeed = 0.5;
            }
            
            update() {
                this.x += this.speed * this.direction;
                this.wheelOffset += this.wheelSpeed;
                if (this.wheelOffset >= 8) this.wheelOffset = 0;
                
                // Reset position when completely off screen
                if (this.x > canvas.width + this.length) {
                    this.x = -this.length;
                }
            }
            
            render(ctx) {
                if (!terrain || !groundLayer) return;
                
                const baseY = terrain.getHeightAt(canvas.width / 2) + groundLayer.offsetY;
                const trainY = baseY + this.y;
                
                ctx.imageSmoothingEnabled = false;
                
                // Draw each carriage
                for (let i = 0; i < this.carriages; i++) {
                    const carriageX = this.x + i * (this.carriageWidth + 2);
                    const isLocomotive = i === 0;
                    
                    // Shadow
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.fillRect(carriageX, trainY + this.carriageHeight, this.carriageWidth, 2);
                    
                    if (isLocomotive) {
                        // Locomotive
                        ctx.fillStyle = '#C41E3A';
                        ctx.fillRect(carriageX, trainY + 2, this.carriageWidth, this.carriageHeight - 2);
                        
                        // Cabin
                        ctx.fillStyle = '#8B0000';
                        ctx.fillRect(carriageX + 16, trainY, 10, 6);
                        
                        // Window
                        ctx.fillStyle = '#FFD700';
                        ctx.fillRect(carriageX + 18, trainY + 1, 3, 3);
                        
                        // Chimney
                        ctx.fillStyle = '#2F4F4F';
                        ctx.fillRect(carriageX + 4, trainY - 2, 4, 4);
                        
                        // Smoke
                        ctx.fillStyle = 'rgba(128, 128, 128, 0.5)';
                        ctx.fillRect(carriageX + 3, trainY - 4, 2, 2);
                        ctx.fillRect(carriageX + 5, trainY - 6, 2, 2);
                    } else {
                        // Cargo carriage
                        const cargoColors = ['#654321', '#8B4513', '#A0522D'];
                        ctx.fillStyle = cargoColors[i % cargoColors.length];
                        ctx.fillRect(carriageX, trainY + 2, this.carriageWidth, this.carriageHeight - 2);
                        
                        // Cargo details (stripes)
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                        ctx.fillRect(carriageX + 8, trainY + 2, 2, this.carriageHeight - 2);
                        ctx.fillRect(carriageX + 18, trainY + 2, 2, this.carriageHeight - 2);
                    }
                    
                    // Wheels
                    ctx.fillStyle = '#2F4F4F';
                    const wheel1X = carriageX + 4 + (this.wheelOffset % 8);
                    const wheel2X = carriageX + this.carriageWidth - 8 + (this.wheelOffset % 8);
                    ctx.fillRect(wheel1X, trainY + this.carriageHeight - 2, 3, 3);
                    ctx.fillRect(wheel2X, trainY + this.carriageHeight - 2, 3, 3);
                    
                    // Wheel spokes
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(wheel1X + 1, trainY + this.carriageHeight - 1, 1, 1);
                    ctx.fillRect(wheel2X + 1, trainY + this.carriageHeight - 1, 1, 1);
                    
                    // Coupling between carriages
                    if (i < this.carriages - 1) {
                        ctx.fillStyle = '#696969';
                        ctx.fillRect(carriageX + this.carriageWidth, trainY + this.carriageHeight / 2, 2, 2);
                    }
                }
                
                ctx.imageSmoothingEnabled = true;
            }
        }

        // Metro class - subway trains
        class Metro {
            constructor(startX, tunnelY) {
                this.x = startX;
                this.tunnelY = tunnelY; // Relative to groundLayer base
                this.speed = 1.5;
                this.direction = 1; // 1 = right, -1 = left
                this.length = 80; // Total metro length
                this.cars = 3;
                this.carWidth = 25;
                this.carHeight = 8;
                this.wheelOffset = 0;
                this.wheelSpeed = 0.4;
                this.doorOpen = false;
                this.doorTimer = 0;
                this.atStation = false;
            }
            
            update(groundLayer) {
                // Check if at a station
                if (groundLayer && groundLayer.subwaySystem) {
                    this.atStation = false;
                    groundLayer.subwaySystem.stations.forEach(station => {
                        const stationCenter = station.x + station.width / 2;
                        const metroCenter = this.x + this.length / 2;
                        const dist = Math.abs(metroCenter - stationCenter);
                        
                        if (dist < 15) {
                            this.atStation = true;
                        }
                    });
                }
                
                // Stop at station
                if (this.atStation) {
                    this.doorTimer++;
                    this.doorOpen = true;
                    
                    // Wait 120 frames (2 seconds) then continue
                    if (this.doorTimer > 120) {
                        this.doorTimer = 0;
                        this.doorOpen = false;
                        this.atStation = false;
                    }
                } else {
                    this.x += this.speed * this.direction;
                    this.wheelOffset += this.wheelSpeed;
                    if (this.wheelOffset >= 6) this.wheelOffset = 0;
                }
                
                // Turn around at tunnel ends
                if (groundLayer && groundLayer.subwaySystem) {
                    const firstStation = groundLayer.subwaySystem.stations[0];
                    const lastStation = groundLayer.subwaySystem.stations[groundLayer.subwaySystem.stations.length - 1];
                    
                    if (this.direction === 1 && this.x > lastStation.x + 30) {
                        this.direction = -1;
                    } else if (this.direction === -1 && this.x < firstStation.x - 30) {
                        this.direction = 1;
                    }
                }
            }
            
            render(ctx, groundLayer) {
                if (!terrain || !groundLayer) return;
                
                const baseY = terrain.getHeightAt(canvas.width / 2) + groundLayer.offsetY;
                const metroY = baseY + this.tunnelY + 2; // Position on tracks
                
                ctx.imageSmoothingEnabled = false;
                
                // Draw each car
                for (let i = 0; i < this.cars; i++) {
                    const carX = this.direction === 1 
                        ? this.x + i * (this.carWidth + 1)
                        : this.x - i * (this.carWidth + 1);
                    
                    // Shadow
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                    ctx.fillRect(carX, metroY + this.carHeight, this.carWidth, 1);
                    
                    // Car body - modern metro design
                    const bodyGrad = ctx.createLinearGradient(carX, metroY, carX, metroY + this.carHeight);
                    bodyGrad.addColorStop(0, '#0AF');
                    bodyGrad.addColorStop(0.5, '#08D');
                    bodyGrad.addColorStop(1, '#06B');
                    ctx.fillStyle = bodyGrad;
                    ctx.fillRect(carX, metroY, this.carWidth, this.carHeight);
                    
                    // Stripe
                    ctx.fillStyle = '#FFF';
                    ctx.fillRect(carX, metroY + 2, this.carWidth, 1);
                    
                    // Windows
                    ctx.fillStyle = this.doorOpen && this.atStation ? '#222' : '#FFD700';
                    for (let w = 0; w < 4; w++) {
                        ctx.fillRect(carX + 3 + w * 5, metroY + 1, 3, 2);
                    }
                    
                    // Doors (darker section when closed, open when at station)
                    if (this.doorOpen) {
                        ctx.fillStyle = '#000';
                        ctx.fillRect(carX + this.carWidth / 2 - 2, metroY + 4, 2, 4);
                    } else {
                        ctx.fillStyle = '#0AF';
                        ctx.fillRect(carX + this.carWidth / 2 - 2, metroY + 4, 4, 4);
                    }
                    
                    // Wheels/bogies
                    ctx.fillStyle = '#333';
                    const wheel1X = carX + 3 + (this.wheelOffset % 6);
                    const wheel2X = carX + this.carWidth - 6 + (this.wheelOffset % 6);
                    ctx.fillRect(wheel1X, metroY + this.carHeight - 1, 2, 2);
                    ctx.fillRect(wheel2X, metroY + this.carHeight - 1, 2, 2);
                    
                    // Front/rear lights
                    if ((this.direction === 1 && i === 0) || (this.direction === -1 && i === this.cars - 1)) {
                        ctx.fillStyle = '#FFF';
                        ctx.shadowBlur = 3;
                        ctx.shadowColor = '#FFF';
                        const lightX = this.direction === 1 ? carX + this.carWidth - 2 : carX + 1;
                        ctx.fillRect(lightX, metroY + 2, 1, 2);
                        ctx.shadowBlur = 0;
                    }
                    
                    // Red tail lights on back
                    if ((this.direction === 1 && i === this.cars - 1) || (this.direction === -1 && i === 0)) {
                        ctx.fillStyle = '#F00';
                        const lightX = this.direction === 1 ? carX + 1 : carX + this.carWidth - 2;
                        ctx.fillRect(lightX, metroY + 2, 1, 2);
                    }
                    
                    // Coupling between cars
                    if (i < this.cars - 1) {
                        ctx.fillStyle = '#555';
                        const couplingX = this.direction === 1 
                            ? carX + this.carWidth
                            : carX;
                        ctx.fillRect(couplingX, metroY + this.carHeight / 2, 1, 2);
                    }
                }
                
                ctx.imageSmoothingEnabled = true;
            }
        }

        // Person class - 8x8 pixel animated sprites
        class Person {
            constructor(x, y, location) {
                this.x = x;
                this.y = y;
                this.location = location; // 'building', 'house', 'walking'
                this.targetX = x;
                this.targetY = y;
                this.speed = 0.3 + Math.random() * 0.3;
                this.frame = 0;
                this.animationSpeed = 8;
                this.animationCounter = 0;
                this.direction = Math.random() > 0.5 ? 1 : -1; // 1 = right, -1 = left
                this.socializing = false;
                this.socializeTimer = 0;
                this.color = this.randomPersonColor();
                this.fleeing = false;
                this.groupTarget = null;
                
                // Shelter system
                this.inShelter = false;
                this.shelterType = null; // 'bunker' or 'subway'
                this.shelterIndex = null;
                this.seekingShelter = false;
                this.dangerLevel = 0; // Track how dangerous the situation is
                
                // Person characteristics (affects shelter-seeking behavior)
                this.vulnerability = Math.random(); // 0-1, higher = more vulnerable (old, children, women)
                this.isVulnerable = this.vulnerability > 0.5; // 50% chance of being vulnerable
                
                // Set initial behavior based on location
                if (location === 'walking') {
                    this.setNewDestination();
                }
            }
            
            randomPersonColor() {
                const colors = [
                    { shirt: '#FF6B6B', pants: '#4A90E2' },
                    { shirt: '#51CF66', pants: '#495057' },
                    { shirt: '#FFD93D', pants: '#6C5CE7' },
                    { shirt: '#A8DADC', pants: '#457B9D' },
                    { shirt: '#E76F51', pants: '#2A9D8F' },
                    { shirt: '#F72585', pants: '#7209B7' },
                    { shirt: '#FB8500', pants: '#023047' }
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            setNewDestination() {
                // Pick a random social gathering point or building
                const destinations = [];
                
                // Add buildings as destinations
                buildings.forEach((building, index) => {
                    if (building.health > 0) {
                        destinations.push({
                            x: building.x + Math.random() * 20 - 10,
                            y: building.y + building.height - 8,
                            type: 'building'
                        });
                    }
                });
                
                // Add some random walking points
                for (let i = 0; i < 5; i++) {
                    destinations.push({
                        x: Math.random() * canvas.width,
                        y: terrain.getHeightAt(Math.random() * canvas.width) - 20 - Math.random() * 30,
                        type: 'walking'
                    });
                }
                
                if (destinations.length > 0) {
                    const dest = destinations[Math.floor(Math.random() * destinations.length)];
                    this.targetX = dest.x;
                    this.targetY = dest.y;
                    this.location = dest.type;
                }
            }
            
            findNearestShelter() {
                if (!groundLayer) return null;
                
                let nearestShelter = null;
                let nearestDist = Infinity;
                
                // Check bunkers
                if (groundLayer.bunkers) {
                    groundLayer.bunkers.forEach((bunker, index) => {
                        if (bunker.people.length < bunker.capacity) {
                            const entranceX = bunker.entrance.x;
                            const entranceY = terrain.getHeightAt(canvas.width / 2) + groundLayer.offsetY + bunker.entrance.y;
                            const dist = Math.hypot(this.x - entranceX, this.y - entranceY);
                            if (dist < nearestDist) {
                                nearestDist = dist;
                                nearestShelter = {
                                    type: 'bunker',
                                    index: index,
                                    x: entranceX,
                                    y: entranceY,
                                    distance: dist
                                };
                            }
                        }
                    });
                }
                
                // Check subway stations
                if (groundLayer.subwaySystem && groundLayer.subwaySystem.stations) {
                    groundLayer.subwaySystem.stations.forEach((station, index) => {
                        if (station.people.length < station.capacity) {
                            const stationX = station.x + station.width / 2;
                            const stationY = terrain.getHeightAt(canvas.width / 2) + groundLayer.offsetY + station.y - 15;
                            const dist = Math.hypot(this.x - stationX, this.y - stationY);
                            if (dist < nearestDist) {
                                nearestDist = dist;
                                nearestShelter = {
                                    type: 'subway',
                                    index: index,
                                    x: stationX,
                                    y: stationY,
                                    distance: dist
                                };
                            }
                        }
                    });
                }
                
                return nearestShelter;
            }
            
            enterShelter(shelter) {
                this.inShelter = true;
                this.shelterType = shelter.type;
                this.shelterIndex = shelter.index;
                this.seekingShelter = false;
                
                // Add to shelter's people array
                if (shelter.type === 'bunker') {
                    groundLayer.bunkers[shelter.index].people.push(this);
                } else if (shelter.type === 'subway') {
                    groundLayer.subwaySystem.stations[shelter.index].people.push(this);
                }
            }
            
            exitShelter() {
                if (!this.inShelter) return;
                
                // Remove from shelter's people array
                if (this.shelterType === 'bunker') {
                    const bunker = groundLayer.bunkers[this.shelterIndex];
                    const idx = bunker.people.indexOf(this);
                    if (idx > -1) bunker.people.splice(idx, 1);
                } else if (this.shelterType === 'subway') {
                    const station = groundLayer.subwaySystem.stations[this.shelterIndex];
                    const idx = station.people.indexOf(this);
                    if (idx > -1) station.people.splice(idx, 1);
                }
                
                this.inShelter = false;
                this.shelterType = null;
                this.shelterIndex = null;
                this.setNewDestination();
            }
            
            checkDanger() {
                // If already in shelter, check if it's safe to leave
                if (this.inShelter) {
                    // Count nearby dangers
                    let nearbyDangers = 0;
                    for (let explosion of explosions) {
                        const dist = Math.hypot(this.x - explosion.x, this.y - explosion.y);
                        if (dist < 300) nearbyDangers++;
                    }
                    for (let enemy of enemies) {
                        const dist = Math.hypot(this.x - enemy.x, this.y - enemy.y);
                        if (dist < 250) nearbyDangers++;
                    }
                    
                    // Only exit if safe (no nearby dangers) and random chance
                    if (nearbyDangers === 0 && Math.random() < 0.01) {
                        this.exitShelter();
                    }
                    return; // Don't process other logic while in shelter
                }
                
                // Calculate danger level
                this.dangerLevel = 0;
                let closestDanger = Infinity;
                
                // Check for nearby explosions - flee from larger radius
                for (let explosion of explosions) {
                    const dist = Math.hypot(this.x - explosion.x, this.y - explosion.y);
                    if (dist < 200) { // Increased from 150
                        this.dangerLevel += (200 - dist) / 200; // Higher danger when closer
                        closestDanger = Math.min(closestDanger, dist);
                        this.fleeing = true;
                        this.socializing = false;
                        this.speed = 0.6 + Math.random() * 0.3; // Run faster when fleeing
                        
                        // Vulnerable people seek shelter instead of just running
                        if (this.isVulnerable && this.dangerLevel > 0.5) {
                            const shelter = this.findNearestShelter();
                            if (shelter && shelter.distance < 200) {
                                this.seekingShelter = true;
                                this.targetX = shelter.x;
                                this.targetY = shelter.y;
                                return;
                            }
                        }
                        
                        // Run away from explosion
                        const angle = Math.atan2(this.y - explosion.y, this.x - explosion.x);
                        const newX = this.x + Math.cos(angle) * 250;
                        const newY = terrain.getHeightAt(newX) - 20; // Stay on ground
                        this.targetX = newX;
                        this.targetY = newY;
                        return;
                    }
                }
                
                // Check for nearby fire particles
                for (let particle of particles) {
                    const dist = Math.hypot(this.x - particle.x, this.y - particle.y);
                    if (dist < 80) {
                        this.dangerLevel += 0.3;
                        this.fleeing = true;
                        this.socializing = false;
                        this.speed = 0.6 + Math.random() * 0.3;
                        const angle = Math.atan2(this.y - particle.y, this.x - particle.x);
                        const newX = this.x + Math.cos(angle) * 120;
                        const newY = terrain.getHeightAt(newX) - 20;
                        this.targetX = newX;
                        this.targetY = newY;
                        return;
                    }
                }
                
                // Check for nearby bullets/missiles
                for (let bullet of bullets) {
                    const dist = Math.hypot(this.x - bullet.x, this.y - bullet.y);
                    if (dist < 150) { // Increased from 100
                        this.dangerLevel += (150 - dist) / 150;
                        this.fleeing = true;
                        this.socializing = false;
                        this.speed = 0.6 + Math.random() * 0.3;
                        const angle = Math.atan2(this.y - bullet.y, this.x - bullet.x);
                        const newX = this.x + Math.cos(angle) * 180;
                        const newY = terrain.getHeightAt(newX) - 20; // Stay on ground
                        this.targetX = newX;
                        this.targetY = newY;
                        return;
                    }
                }
                
                // Check for nearby incoming missiles (enemies) - HIGH DANGER
                for (let enemy of enemies) {
                    const dist = Math.hypot(this.x - enemy.x, this.y - enemy.y);
                    if (dist < 180) { // Increased from 120
                        this.dangerLevel += (180 - dist) / 180 * 1.5; // Missiles are very dangerous
                        this.fleeing = true;
                        this.socializing = false;
                        this.speed = 0.6 + Math.random() * 0.3;
                        
                        // Seek shelter when missiles are nearby and person is vulnerable
                        if (this.isVulnerable && this.dangerLevel > 0.4) {
                            const shelter = this.findNearestShelter();
                            if (shelter && shelter.distance < 250) {
                                this.seekingShelter = true;
                                this.targetX = shelter.x;
                                this.targetY = shelter.y;
                                return;
                            }
                        }
                        
                        const angle = Math.atan2(this.y - enemy.y, this.x - enemy.x);
                        const newX = this.x + Math.cos(angle) * 200;
                        const newY = terrain.getHeightAt(newX) - 20; // Stay on ground
                        this.targetX = newX;
                        this.targetY = newY;
                        return;
                    }
                }
                
                // Check for damaged/destroyed buildings nearby
                for (let building of buildings) {
                    if (building.health < building.maxHealth) {
                        const distX = Math.abs(this.x - (building.x + building.width / 2));
                        const distY = Math.abs(this.y - (building.y - building.height / 2));
                        const dist = Math.hypot(distX, distY);
                        
                        // Flee from heavily damaged buildings
                        if (building.health <= 0 && dist < 100) {
                            this.dangerLevel += 0.5;
                            this.fleeing = true;
                            this.socializing = false;
                            this.speed = 0.5 + Math.random() * 0.2;
                            const angle = Math.atan2(this.y - building.y, this.x - building.x);
                            const newX = this.x + Math.cos(angle) * 150;
                            const newY = terrain.getHeightAt(newX) - 20;
                            this.targetX = newX;
                            this.targetY = newY;
                            return;
                        }
                        // Avoid buildings that are taking damage
                        else if (building.health < building.maxHealth * 0.5 && dist < 60) {
                            this.dangerLevel += 0.3;
                            this.fleeing = true;
                            this.socializing = false;
                            const angle = Math.atan2(this.y - building.y, this.x - building.x);
                            const newX = this.x + Math.cos(angle) * 100;
                            const newY = terrain.getHeightAt(newX) - 20;
                            this.targetX = newX;
                            this.targetY = newY;
                            return;
                        }
                    }
                }
                
                // If danger level is very high, all vulnerable people seek shelter
                if (this.isVulnerable && this.dangerLevel > 0.6) {
                    const shelter = this.findNearestShelter();
                    if (shelter && shelter.distance < 300) {
                        this.seekingShelter = true;
                        this.targetX = shelter.x;
                        this.targetY = shelter.y;
                        return;
                    }
                }
                
                // Reset speed when not fleeing
                if (this.fleeing) {
                    this.speed = 0.3 + Math.random() * 0.3;
                }
                this.fleeing = false;
            }
            
            findNearbyPeople() {
                // Group with nearby people at social locations
                if (this.location === 'building') {
                    for (let person of people) {
                        if (person !== this && person.socializing) {
                            const dist = Math.hypot(this.x - person.x, this.y - person.y);
                            if (dist < 30 && dist > 5) {
                                // Move slightly closer to form a group
                                this.groupTarget = person;
                                return;
                            }
                        }
                    }
                }
                this.groupTarget = null;
            }
            
            update() {
                this.checkDanger();
                
                // Skip movement if in shelter
                if (this.inShelter) {
                    return;
                }
                
                if (!this.fleeing && !this.seekingShelter) {
                    this.findNearbyPeople();
                }
                
                // Handle socializing behavior
                if (this.socializing && !this.fleeing && !this.seekingShelter) {
                    this.socializeTimer--;
                    if (this.socializeTimer <= 0) {
                        this.socializing = false;
                        this.setNewDestination();
                    } else if (this.groupTarget) {
                        // Move slightly toward group member
                        const dx = this.groupTarget.x - this.x;
                        const dy = this.groupTarget.y - this.y;
                        const dist = Math.hypot(dx, dy);
                        if (dist > 10) {
                            this.x += (dx / dist) * 0.1;
                            this.y += (dy / dist) * 0.1;
                        }
                    }
                    return;
                }
                
                // Move toward target
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const dist = Math.hypot(dx, dy);
                
                if (dist > 2) {
                    const moveX = (dx / dist) * this.speed;
                    const moveY = (dy / dist) * this.speed;
                    this.x += moveX;
                    this.y += moveY;
                    
                    // Update direction based on movement
                    this.direction = moveX > 0 ? 1 : -1;
                    
                    // Animate walking
                    this.animationCounter++;
                    if (this.animationCounter >= this.animationSpeed) {
                        this.frame = (this.frame + 1) % 2;
                        this.animationCounter = 0;
                    }
                } else {
                    // Reached destination
                    if (this.seekingShelter) {
                        // Enter the shelter
                        const shelter = this.findNearestShelter();
                        if (shelter && shelter.distance < 20) {
                            this.enterShelter(shelter);
                        } else {
                            this.seekingShelter = false;
                        }
                    } else if (!this.fleeing) {
                        this.setNewDestination();
                    } else {
                        this.fleeing = false;
                        this.setNewDestination();
                    }
                }
                
                // Keep within bounds
                this.x = Math.max(0, Math.min(canvas.width, this.x));
                this.y = Math.max(0, Math.min(canvas.height, this.y));
                
                // Constrain to ground level - people can't fly!
                if (terrain) {
                    const groundLevel = terrain.getHeightAt(this.x) - 8; // -8 for sprite height
                    if (this.y < groundLevel) {
                        this.y = groundLevel;
                    }
                }
            }
            
            render(ctx) {
                // Don't render if person is in shelter (they're shown inside the shelter)
                if (this.inShelter) {
                    return;
                }
                
                ctx.imageSmoothingEnabled = false; // Pixel art style
                
                // 8x8 pixel sprite
                const size = 8;
                const x = Math.floor(this.x);
                const y = Math.floor(this.y);
                
                // Draw shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(x, y + 7, size, 1);
                
                // Head (2x2 pixels)
                ctx.fillStyle = '#FDBCB4';
                ctx.fillRect(x + 3, y, 2, 2);
                
                // Body (shirt) - 4x3 pixels
                ctx.fillStyle = this.color.shirt;
                ctx.fillRect(x + 2, y + 2, 4, 3);
                
                // Legs (pants) - different based on animation frame
                ctx.fillStyle = this.color.pants;
                if (this.socializing) {
                    // Standing still
                    ctx.fillRect(x + 2, y + 5, 2, 3);
                    ctx.fillRect(x + 4, y + 5, 2, 3);
                } else {
                    // Walking animation
                    if (this.frame === 0) {
                        ctx.fillRect(x + 2, y + 5, 2, 3);
                        ctx.fillRect(x + 4, y + 6, 2, 2);
                    } else {
                        ctx.fillRect(x + 2, y + 6, 2, 2);
                        ctx.fillRect(x + 4, y + 5, 2, 3);
                    }
                }
                
                // Arms (small dots on sides)
                ctx.fillStyle = this.color.shirt;
                if (this.frame === 0) {
                    ctx.fillRect(x + 1, y + 3, 1, 1);
                    ctx.fillRect(x + 6, y + 3, 1, 1);
                } else {
                    ctx.fillRect(x + 1, y + 2, 1, 1);
                    ctx.fillRect(x + 6, y + 4, 1, 1);
                }
                
                ctx.imageSmoothingEnabled = true;
            }
        }

        // Helper Functions
        function createExplosion(x, y, maxRadius) {
            explosions.push(new Explosion(x, y, maxRadius));
            for (let i = 0; i < 20; i++) {
                particles.push(new Particle(x, y));
            }
        }

        function launchEnemyOffensiveWeapon(weaponType, targetX, targetY) {
            // Enemy launches same weapons as player, just from their side
            // Temporarily set currentSide to evil for the launch
            const originalSide = gameState.currentSide;
            gameState.currentSide = 'evil';
            
            // Launch the appropriate weapon type using same functions as player
            if (weaponType === 'missile') {
                launchOffensiveMissile(targetX, targetY);
            } else if (weaponType === 'drone') {
                launchOffensiveDrone(targetX, targetY);
            } else if (weaponType === 'soldier') {
                launchOffensiveSoldier(targetX, targetY);
            } else if (weaponType === 'tank') {
                launchOffensiveTank(targetX, targetY);
            } else if (weaponType === 'heavy') {
                launchHeavyBarrage(targetX, targetY);
            }
            
            // Restore original side
            gameState.currentSide = originalSide;
        }

        function spawnEnemy() {
            // Defense phase: enemy launches their offensive weapons from inventory
            const isAttacking = gameState.phase === 'defense' ? true : false;
            
            if (isAttacking) {
                // Enemy uses their weapons from inventory to attack us
                const availableWeapons = [];
                if (enemyWeapons.drones > 0) availableWeapons.push('drone');
                if (enemyWeapons.missiles > 0) availableWeapons.push('missile');
                if (enemyWeapons.soldiers > 0) availableWeapons.push('soldier');
                if (enemyWeapons.tanks > 0) availableWeapons.push('tank');
                if (enemyWeapons.heavyWeapons > 0) availableWeapons.push('heavy');
                
                if (availableWeapons.length > 0) {
                    // Randomly select weapon type
                    const weaponType = availableWeapons[Math.floor(Math.random() * availableWeapons.length)];
                    
                    // Launch enemy offensive weapon toward player's city
                    const targetX = Math.random() * canvas.width;
                    const targetY = canvas.height - 150 - Math.random() * 100;
                    
                    launchEnemyOffensiveWeapon(weaponType, targetX, targetY);
                    
                    // Deduct from enemy inventory
                    if (weaponType === 'drone') enemyWeapons.drones--;
                    else if (weaponType === 'missile') enemyWeapons.missiles--;
                    else if (weaponType === 'soldier') enemyWeapons.soldiers--;
                    else if (weaponType === 'tank') enemyWeapons.tanks--;
                    else if (weaponType === 'heavy') enemyWeapons.heavyWeapons--;
                    
                    updateDisplay();
                } else {
                    // No weapons left, spawn regular enemy missile
                    enemies.push(new Enemy(isAttacking));
                }
            } else {
                enemies.push(new Enemy(isAttacking));
            }
        }

        function updateDisplay() {
            const side = gameState[gameState.currentSide];
            
            document.getElementById('currentSide').textContent = 
                gameState.currentSide === 'good' ? 'üòá GOOD' : 'üòà EVIL';
            document.getElementById('currentPhase').textContent = 
                gameState.phase.toUpperCase();
            document.getElementById('bankMoney').textContent = `$${bankMoney}`;
            document.getElementById('resources').textContent = `$${side.resources}`;
            document.getElementById('enemiesLeft').textContent = 
                Math.max(0, gameState.enemiesNeeded - gameState.enemiesKilled);
            document.getElementById('materialsCount').textContent = side.materials.length;
            document.getElementById('dronesCount').textContent = side.drones;
            document.getElementById('interceptorsCount').textContent = side.interceptors;
            document.getElementById('soldiersCount').textContent = side.soldiers;
            document.getElementById('missilesCount').textContent = side.missiles;
            document.getElementById('tanksCount').textContent = side.tanks;
            document.getElementById('heavyCount').textContent = side.heavyWeapons;
            document.getElementById('influencersCount').textContent = side.influencers;
            document.getElementById('damageValue').textContent = `$${side.destructionValue}`;

            // Update phase panel
            document.getElementById('phaseText').textContent = 
                gameState.phase === 'defense' ? 
                `${gameState.currentSide.toUpperCase()} DEFENDING` :
                `${gameState.currentSide.toUpperCase()} ATTACKING`;
            document.getElementById('roundText').textContent = `Round ${gameState.round}`;

            // Update panel colors
            const titlePanel = document.getElementById('titlePanel');
            const scorePanel = document.getElementById('scorePanel');
            const phasePanel = document.getElementById('phasePanel');
            const inventoryPanel = document.getElementById('inventoryPanel');

            if (gameState.currentSide === 'good') {
                titlePanel.classList.add('good-panel');
                titlePanel.classList.remove('evil-panel');
                scorePanel.classList.add('good-panel');
                scorePanel.classList.remove('evil-panel');
                phasePanel.classList.add('good-panel');
                phasePanel.classList.remove('evil-panel');
                inventoryPanel.classList.add('good-panel');
                inventoryPanel.classList.remove('evil-panel');
            } else {
                titlePanel.classList.add('evil-panel');
                titlePanel.classList.remove('good-panel');
                scorePanel.classList.add('evil-panel');
                scorePanel.classList.remove('good-panel');
                phasePanel.classList.add('evil-panel');
                phasePanel.classList.remove('good-panel');
                inventoryPanel.classList.add('evil-panel');
                inventoryPanel.classList.remove('good-panel');
            }

            // Show/hide buttons based on phase
            // BUY WEAPONS button always visible
            document.getElementById('convertButton').style.display = 'block';
            
            // Update arsenal money displays (player and enemy in same panel)
            document.getElementById('arsenalPlayerMoney').textContent = `$${side.resources}`;
            document.getElementById('enemyResources').textContent = `$${enemyWeapons.resources}`;
            document.getElementById('enemyDronesCount').textContent = enemyWeapons.drones;
            document.getElementById('enemyInterceptorsCount').textContent = enemyWeapons.interceptors;
            document.getElementById('enemySoldiersCount').textContent = enemyWeapons.soldiers;
            document.getElementById('enemyMissilesCount').textContent = enemyWeapons.missiles;
            document.getElementById('enemyTanksCount').textContent = enemyWeapons.tanks;
            document.getElementById('enemyHeavyCount').textContent = enemyWeapons.heavyWeapons;
            document.getElementById('enemyInfluencersCount').textContent = enemyWeapons.influencers;
            
            // Update statistics
            document.getElementById('arsenalPlayerCivilians').textContent = side.civilians;
            document.getElementById('enemyCivilians').textContent = enemyWeapons.civilians;
            document.getElementById('arsenalPlayerFood').textContent = side.food;
            document.getElementById('enemyFood').textContent = enemyWeapons.food;
            document.getElementById('arsenalPlayerHealth').textContent = `${side.health}%`;
            document.getElementById('enemyHealth').textContent = `${enemyWeapons.health}%`;
            document.getElementById('arsenalPlayerHungry').textContent = side.hungry;
            document.getElementById('enemyHungry').textContent = enemyWeapons.hungry;
            document.getElementById('arsenalPlayerIll').textContent = side.ill;
            document.getElementById('enemyIll').textContent = enemyWeapons.ill;
            document.getElementById('arsenalPlayerWounded').textContent = side.wounded;
            document.getElementById('enemyWounded').textContent = enemyWeapons.wounded;
            document.getElementById('arsenalPlayerCasualties').textContent = side.casualties;
            document.getElementById('enemyCasualties').textContent = enemyWeapons.casualties;
            document.getElementById('arsenalPlayerBuildings').textContent = side.buildingsDestroyed;
            document.getElementById('enemyBuildings').textContent = enemyWeapons.buildingsDestroyed;
            document.getElementById('arsenalPlayerRepair').textContent = `$${side.repairCost}`;
            document.getElementById('enemyRepair').textContent = `$${enemyWeapons.repairCost}`;
            
            // Update debt display
            document.getElementById('playerDebt').textContent = `$${side.debt}`;
            
            // Update factory queue display
            const queueEl = document.getElementById('factoryQueue');
            if (side.factoryQueue.length > 0) {
                const item = side.factoryQueue[0];
                const secondsLeft = Math.ceil(item.timeLeft / 1000);
                queueEl.textContent = `${item.name} (${secondsLeft}s)`;
                queueEl.style.color = '#FFD700';
            } else {
                queueEl.textContent = 'None';
                queueEl.style.color = '#888';
            }
        }

        function showStatus(message, duration = 3000) {
            const statusEl = document.getElementById('statusMessage');
            statusEl.textContent = message;
            statusEl.style.display = 'block';
            setTimeout(() => {
                statusEl.style.display = 'none';
            }, duration);
        }

        // Money reward particles
        let moneyRewards = [];

        function showMoneyReward(x, y, amount) {
            moneyRewards.push({
                x: x,
                y: y,
                amount: amount,
                life: 60, // frames
                offsetY: 0,
                alpha: 1
            });
        }

        function updateMoneyRewards() {
            moneyRewards = moneyRewards.filter(reward => {
                reward.offsetY -= 1; // Float upward
                reward.life--;
                reward.alpha = reward.life / 60;
                
                // Render the reward
                ctx.save();
                ctx.globalAlpha = reward.alpha;
                ctx.fillStyle = '#0F0';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.font = 'bold 16px monospace';
                ctx.strokeText(`+$${reward.amount}`, reward.x, reward.y + reward.offsetY);
                ctx.fillText(`+$${reward.amount}`, reward.x, reward.y + reward.offsetY);
                ctx.restore();
                
                return reward.life > 0;
            });
        }

        function showConversionDialog() {
            const side = gameState[gameState.currentSide];
            const modal = document.getElementById('conversionModal');
            const optionsContainer = document.getElementById('conversionOptions');
            
            // Clear and rebuild options
            optionsContainer.innerHTML = '';

            Object.entries(WEAPONS).forEach(([key, weapon]) => {
                const canAfford = side.resources >= weapon.cost;
                const optionDiv = document.createElement('div');
                optionDiv.className = 'conversion-option' + (canAfford ? '' : ' disabled');
                optionDiv.innerHTML = `
                    <div class="weapon-name">${weapon.name}</div>
                    <div class="weapon-cost">Cost: $${weapon.cost}</div>
                    <div class="weapon-stats">${weapon.description}</div>
                    <div class="weapon-stats">Speed: ${weapon.speed} | Damage: ${weapon.damage}</div>
                `;
                
                if (canAfford) {
                    optionDiv.style.cursor = 'pointer';
                    optionDiv.onclick = function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        convertToWeapon(key);
                    };
                } else {
                    optionDiv.style.cursor = 'not-allowed';
                }
                
                optionsContainer.appendChild(optionDiv);
            });

            modal.style.display = 'flex';
        }

        let isUpdatingOptions = false;
        
        function updateConversionOptions() {
            if (isUpdatingOptions) return; // Prevent recursive updates
            isUpdatingOptions = true;
            
            const side = gameState[gameState.currentSide];
            const optionsContainer = document.getElementById('conversionOptions');
            const options = optionsContainer.getElementsByClassName('conversion-option');
            
            // Update existing options instead of recreating them
            let index = 0;
            Object.entries(WEAPONS).forEach(([key, weapon]) => {
                if (options[index]) {
                    const canAfford = side.resources >= weapon.cost;
                    const optionDiv = options[index];
                    
                    // Update classes
                    if (canAfford) {
                        optionDiv.classList.remove('disabled');
                        optionDiv.style.cursor = 'pointer';
                    } else {
                        optionDiv.classList.add('disabled');
                        optionDiv.style.cursor = 'not-allowed';
                    }
                }
                index++;
            });
            
            isUpdatingOptions = false;
        }

        function prepareAttack() {
            // Close the modal
            hideConversionDialog();
            
            // Show the launch attack button
            const launchBtn = document.getElementById('launchButton');
            const convertBtn = document.getElementById('convertButton');
            
            launchBtn.style.display = 'block';
            convertBtn.style.display = 'none';
            
            showStatus('‚öîÔ∏è Ready to attack! Click "START ATTACK!" when ready.', 3000);
        }

        function hideConversionDialog() {
            const modal = document.getElementById('conversionModal');
            if (modal.style.display === 'flex') {
                modal.style.display = 'none';
            }
        }

        // Setup modal event listeners
        function setupModalListeners() {
            const modal = document.getElementById('conversionModal');
            const dialog = document.getElementById('conversionDialog');
            const closeBtn = document.getElementById('closeModalBtn');
            
            // Close on overlay click
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    e.preventDefault();
                    e.stopPropagation();
                    hideConversionDialog();
                }
            });
            
            // Prevent dialog clicks from closing modal
            dialog.addEventListener('click', function(e) {
                e.stopPropagation();
            });
            
            // Close button - use mousedown instead of click to avoid conflicts
            closeBtn.addEventListener('mousedown', function(e) {
                e.preventDefault();
                e.stopPropagation();
                hideConversionDialog();
            });
            
            // Also handle keyboard
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && modal.style.display === 'flex') {
                    hideConversionDialog();
                }
            });
        }

        let isConverting = false;
        
        function convertToWeapon(weaponType) {
            if (isConverting) return; // Prevent multiple simultaneous conversions
            isConverting = true;
            
            const side = gameState[gameState.currentSide];
            const weapon = WEAPONS[weaponType];

            if (side.resources >= weapon.cost) {
                // Money goes from player to bank
                side.resources -= weapon.cost;
                bankMoney += weapon.cost;
                
                if (weaponType === 'drone') {
                    side.drones++;
                    // Deploy immediately if in defense phase
                    if (gameState.phase === 'defense') {
                        defensiveDrones.push(new DefensiveDrone(gameState.currentSide));
                    }
                } else if (weaponType === 'interceptor') {
                    side.interceptors++;
                    if (gameState.phase === 'defense') {
                        defensiveInterceptors.push(new DefensiveInterceptor(gameState.currentSide));
                    }
                } else if (weaponType === 'soldier') {
                    side.soldiers++;
                    if (gameState.phase === 'defense') {
                        defensiveSoldiers.push(new DefensiveSoldier(gameState.currentSide));
                    }
                } else if (weaponType === 'missile') {
                    side.missiles++;
                } else if (weaponType === 'tank') {
                    side.tanks++;
                    if (gameState.phase === 'defense') {
                        defensiveTanks.push(new DefensiveTank(gameState.currentSide));
                    }
                } else if (weaponType === 'heavy') {
                    side.heavyWeapons++;
                    if (gameState.phase === 'defense') {
                        defensiveHeavyWeapons.push(new DefensiveHeavyWeapon(gameState.currentSide));
                    }
                } else if (weaponType === 'influencer') {
                    side.influencers++;
                    // Influencers don't deploy in defense - they're offensive only
                }

                updateDisplay();
                playSound('collect');
                showStatus(`‚úÖ ${weapon.name} created!`);
                
                // Update affordability without rebuilding DOM
                updateConversionOptions();
            }
            
            // Reset flag after a short delay
            setTimeout(() => {
                isConverting = false;
            }, 100);
        }

        function toggleViewMode() {
            // Toggle between DEFENSE mode (own city) and ATTACK mode (enemy city)
            if (gameState.phase === 'defense') {
                // Switch to ATTACK mode
                startAttackPhase();
            } else {
                // Switch back to DEFENSE mode
                endAttackPhase();
            }
        }

        function startAttackPhase() {
            // Switch to attack phase - SHOW ENEMY CITY
            gameState.phase = 'attack';
            gameState.enemiesKilled = 0;
            gameState.enemiesNeeded = 8;
            gameState.conversionDialogShown = false;
            
            // Initialize offensive weapons array
            if (!window.offensiveWeapons) window.offensiveWeapons = [];
            
            // Create enemy city if not exists
            if (enemyBuildings.length === 0) {
                createEnemyCity();
            }
            
            // Automatically switch to enemy view
            viewMode = 'enemy';
            
            // Update button to show "DEFENSE MODE" (to go back)
            document.getElementById('viewModeButton').textContent = 'üõ°Ô∏è DEFENSE MODE';
            document.getElementById('viewModeButton').style.background = 'linear-gradient(180deg, #4488ff, #2266dd)';
            
            showStatus(`‚öîÔ∏è ATTACK PHASE: Now YOU attack ENEMY city! Click buildings to launch weapons!`, 3000);
            updateDisplay();
            
            // Deploy enemy defensive units based on their inventory
            enemyDefensiveDrones = [];
            enemyDefensiveInterceptors = [];
            enemyDefensiveSoldiers = [];
            enemyDefensiveTanks = [];
            enemyDefensiveHeavyWeapons = [];
            
            for (let i = 0; i < enemyWeapons.drones; i++) {
                enemyDefensiveDrones.push(new DefensiveDrone('evil'));
            }
            for (let i = 0; i < enemyWeapons.interceptors; i++) {
                enemyDefensiveInterceptors.push(new DefensiveInterceptor('evil'));
            }
            for (let i = 0; i < enemyWeapons.soldiers; i++) {
                enemyDefensiveSoldiers.push(new DefensiveSoldier('evil'));
            }
            for (let i = 0; i < enemyWeapons.tanks; i++) {
                enemyDefensiveTanks.push(new DefensiveTank('evil'));
            }
            for (let i = 0; i < enemyWeapons.heavyWeapons; i++) {
                enemyDefensiveHeavyWeapons.push(new DefensiveHeavyWeapon('evil'));
            }
            
            // Enemy command post shoots down our missiles
            setTimeout(() => {
                enemySpawnInterval = setInterval(() => {
                    // Enemy tank tries to shoot down our weapons - AGGRESSIVE
                    if (enemies.length < 5) { // Increased from 2 to 5
                        spawnEnemy();
                    }
                }, 1000); // Reduced from 3000 to 1000ms - more aggressive
            }, 500); // Start attacking sooner
        }

        function createEnemyCity() {
            // Create enemy terrain with EVIL style
            enemyTerrain = new Terrain(true); // Evil terrain
            enemyGroundLayer = new GroundLayer(enemyTerrain, true); // Evil ground layer
            
            // Create enemy buildings - SAME LAYOUT as our city
            const w = canvas.width;
            const enemyBuildingPlan = [
                // FAR LEFT - Forest and farms (0-12.5%)
                { type: 'tree', x: w * 0.015 },
                { type: 'tree', x: w * 0.028 },
                { type: 'bush', x: w * 0.041 },
                { type: 'tree', x: w * 0.050 },
                { type: 'bigfarm', x: w * 0.063 },
                { type: 'tree', x: w * 0.088 },
                { type: 'bush', x: w * 0.100 },
                { type: 'farm', x: w * 0.110 },
                { type: 'tree', x: w * 0.122 },
                
                // LEFT - Farms and power infrastructure (12.5-25%)
                { type: 'farm', x: w * 0.131 },
                { type: 'tree', x: w * 0.150 },
                { type: 'powerline', x: w * 0.163 },
                { type: 'bigfarm', x: w * 0.175 },
                { type: 'bush', x: w * 0.197 },
                { type: 'farm', x: w * 0.206 },
                { type: 'tree', x: w * 0.222 },
                { type: 'powerplant', x: w * 0.234 },
                
                // CENTER CITY - Main buildings (25-75%)
                { type: 'house', x: w * 0.256 },
                { type: 'tree', x: w * 0.272 },
                { type: 'house', x: w * 0.281 },
                { type: 'shop', x: w * 0.297 },
                { type: 'subway', x: w * 0.313 },
                { type: 'house', x: w * 0.328 },
                
                { type: 'office', x: w * 0.347 },
                { type: 'shop', x: w * 0.369 },
                { type: 'office', x: w * 0.384 },
                { type: 'pool', x: w * 0.406 },
                
                // City center - tall buildings
                { type: 'hospital', x: w * 0.431 },
                { type: 'office', x: w * 0.456 },
                { type: 'government', x: w * 0.481 },
                { type: 'theatre', x: w * 0.506 },
                { type: 'office', x: w * 0.531 },
                { type: 'school', x: w * 0.556 },
                { type: 'subway', x: w * 0.581 },
                
                { type: 'office', x: w * 0.606 },
                { type: 'shop', x: w * 0.628 },
                { type: 'school', x: w * 0.650 },
                
                // Industrial zone
                { type: 'factory', x: w * 0.672 },
                { type: 'factory', x: w * 0.697 },
                { type: 'factory', x: w * 0.722 },
                
                { type: 'house', x: w * 0.741 },
                
                // RIGHT - Power infrastructure and farms (75-87.5%)
                { type: 'powerline', x: w * 0.756 },
                { type: 'farm', x: w * 0.772 },
                { type: 'tree', x: w * 0.794 },
                { type: 'bigfarm', x: w * 0.806 },
                { type: 'bush', x: w * 0.831 },
                { type: 'farm', x: w * 0.844 },
                { type: 'powerline', x: w * 0.863 },
                
                // FAR RIGHT - Forest (87.5-100%)
                { type: 'tree', x: w * 0.881 },
                { type: 'bush', x: w * 0.897 },
                { type: 'farm', x: w * 0.909 },
                { type: 'tree', x: w * 0.928 },
                { type: 'tree', x: w * 0.944 },
                { type: 'bush', x: w * 0.959 },
                { type: 'tree', x: w * 0.972 },
                { type: 'tree', x: w * 0.988 }
            ];
            
            // Find all hill peaks (local minima in y, since lower y = higher elevation)
            const hillPeaks = [];
            for (let i = 5; i < enemyTerrain.points.length - 5; i++) {
                const curr = enemyTerrain.points[i].y;
                let isPeak = true;
                
                // Check if this is lower (higher elevation) than neighbors
                for (let j = -5; j <= 5; j++) {
                    if (j !== 0 && enemyTerrain.points[i + j].y < curr) {
                        isPeak = false;
                        break;
                    }
                }
                
                if (isPeak) {
                    hillPeaks.push({
                        x: enemyTerrain.points[i].x,
                        y: enemyTerrain.points[i].y,
                        index: i
                    });
                }
            }
            
            // Helper function to find nearest hill peak to an x position
            function findNearestPeak(targetX) {
                let nearest = hillPeaks[0];
                let minDist = Math.abs(hillPeaks[0].x - targetX);
                
                for (let peak of hillPeaks) {
                    const dist = Math.abs(peak.x - targetX);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = peak;
                    }
                }
                return nearest;
            }
            
            enemyBuildings = [];
            enemyBuildingPlan.forEach(plan => {
                // Find nearest hill peak to this building's x position
                const nearestPeak = findNearestPeak(plan.x);
                
                // Place building on or near the peak (use peak's y for height calculation)
                // But keep the original x from the plan
                const terrainY = nearestPeak.y + enemyGroundLayer.offsetY;
                enemyBuildings.push(new Building(plan.x, plan.type, terrainY));
            });
            
            // Create enemy people - SAME as our city
            enemyPeople = [];
            
            // People at buildings
            enemyBuildings.forEach((building, index) => {
                if (building.health > 0) {
                    let numPeople = 0;
                    
                    // Theatre - LARGE GROUP (15-20 people)
                    if (building.type === 'theatre') {
                        numPeople = 15 + Math.floor(Math.random() * 6);
                        for (let i = 0; i < numPeople; i++) {
                            const personX = building.x + Math.random() * 40 - 20;
                            const personY = building.y + building.height - 8 + Math.random() * 10 - 5;
                            enemyPeople.push(new Person(personX, personY, 'building'));
                        }
                    }
                    // City center buildings - MORE PEOPLE
                    else if (['government', 'office', 'school', 'hospital', 'subway'].includes(building.type)) {
                        const isCityCenter = building.x > canvas.width * 0.40 && building.x < canvas.width * 0.60;
                        
                        if (isCityCenter) {
                            // 8-12 people at city center buildings
                            numPeople = 8 + Math.floor(Math.random() * 5);
                        } else {
                            // 3-5 people at other similar buildings
                            numPeople = 3 + Math.floor(Math.random() * 3);
                        }
                        
                        for (let i = 0; i < numPeople; i++) {
                            const personX = building.x + Math.random() * 30 - 15;
                            const personY = building.y + building.height - 8 + Math.random() * 8 - 4;
                            enemyPeople.push(new Person(personX, personY, 'building'));
                        }
                    }
                    // Regular buildings - fewer people
                    else if (['house', 'shop'].includes(building.type)) {
                        numPeople = 1 + Math.floor(Math.random() * 2);
                        for (let i = 0; i < numPeople; i++) {
                            const personX = building.x + Math.random() * 20 - 10;
                            const personY = building.y + building.height - 8;
                            enemyPeople.push(new Person(personX, personY, 'building'));
                        }
                    }
                }
            });
            
            // Add extra crowd in city center
            const cityCenter = canvas.width * 0.50;
            const cityCenterRadius = canvas.width * 0.08;
            for (let i = 0; i < 20; i++) {
                const personX = cityCenter + (Math.random() - 0.5) * cityCenterRadius * 2;
                const personY = enemyTerrain.getHeightAt(personX) - 15 - Math.random() * 20;
                enemyPeople.push(new Person(personX, personY, 'walking'));
            }
            
            // People walking around randomly
            for (let i = 0; i < 15; i++) {
                const personX = Math.random() * canvas.width;
                const personY = enemyTerrain.getHeightAt(personX) - 20 - Math.random() * 30;
                enemyPeople.push(new Person(personX, personY, 'walking'));
            }
            
            // Create enemy cars on roads
            enemyCars = [];
            if (enemyGroundLayer && enemyGroundLayer.roads) {
                enemyGroundLayer.roads.forEach(road => {
                    const numCars = 3 + Math.floor(Math.random() * 3);
                    for (let i = 0; i < numCars; i++) {
                        const carX = Math.random() * canvas.width;
                        const carY = road.y + road.height / 2 - 4;
                        const direction = Math.random() > 0.5 ? 1 : -1;
                        enemyCars.push(new Car(carX, carY, road.y, direction));
                    }
                });
            }
            
            // Create enemy train on railway
            enemyTrain = null;
            if (enemyGroundLayer && enemyGroundLayer.railways && enemyGroundLayer.railways.length > 0) {
                const railway = enemyGroundLayer.railways[0];
                const trainY = railway.y + railway.height / 2 - 7;
                enemyTrain = new Train(-120, trainY);
            }
            
            // Create enemy metros in subway system
            enemyMetros = [];
            if (enemyGroundLayer && enemyGroundLayer.subwaySystem) {
                const tunnelY = enemyGroundLayer.subwaySystem.tunnelY + enemyGroundLayer.subwaySystem.tunnelHeight / 2 - 4;
                enemyMetros.push(new Metro(canvas.width * 0.15, tunnelY));
                enemyMetros.push(new Metro(canvas.width * 0.75, tunnelY));
                enemyMetros[1].direction = -1;
            }
            
            // Create AI-controlled enemy tank
            enemyTank = new EnemyTank();
            enemyBullets = [];
        }

        function endAttackPhase() {
            // Player manually ends attack - switch back to DEFENSE
            clearInterval(enemySpawnInterval);
            
            // Clear offensive weapons
            if (window.offensiveWeapons) {
                window.offensiveWeapons = [];
            }
            
            // Clear enemies
            enemies = [];
            enemyBullets = [];
            
            // Switch back to defense phase
            gameState.phase = 'defense';
            viewMode = 'own';
            
            // Restart enemy spawning for defense mode - AGGRESSIVE
            enemySpawnInterval = setInterval(() => {
                if (enemies.length < 8 && gameState.enemiesKilled < gameState.enemiesNeeded) { // Increased from 5 to 8
                    spawnEnemy();
                }
            }, 800); // Reduced from 2000 to 800ms - much more aggressive
            
            // Update button to show "ATTACK MODE" (to go to attack)
            document.getElementById('viewModeButton').textContent = '‚öîÔ∏è ATTACK MODE';
            document.getElementById('viewModeButton').style.background = 'linear-gradient(180deg, #ff4444, #cc0000)';
            
            showStatus(`üõ°Ô∏è DEFENSE MODE: Defend your city!`, 2000);
            updateDisplay();
        }

        function showWeaponSelectDialog(targetBuilding) {
            const side = gameState[gameState.currentSide];
            const modal = document.getElementById('weaponSelectModal');
            const optionsContainer = document.getElementById('weaponSelectOptions');
            const targetInfo = document.getElementById('targetInfo');
            
            selectedTarget = { building: targetBuilding, x: targetBuilding.x + targetBuilding.width / 2, y: targetBuilding.y - targetBuilding.height / 2 };
            
            targetInfo.innerHTML = `Target: <strong>${targetBuilding.type.toUpperCase()}</strong> (${targetBuilding.health}/${targetBuilding.maxHealth} HP)`;
            
            // Clear and build weapon options
            optionsContainer.innerHTML = '';
            
            const availableWeapons = [
                { key: 'drone', count: side.drones },
                { key: 'interceptor', count: side.interceptors },
                { key: 'soldier', count: side.soldiers },
                { key: 'missile', count: side.missiles },
                { key: 'tank', count: side.tanks },
                { key: 'heavy', count: side.heavyWeapons },
                { key: 'influencer', count: side.influencers }
            ];
            
            availableWeapons.forEach(({ key, count }) => {
                if (count > 0) {
                    const weapon = WEAPONS[key];
                    const optionDiv = document.createElement('div');
                    optionDiv.className = 'conversion-option';
                    optionDiv.style.cursor = 'pointer';
                    optionDiv.innerHTML = `
                        <div class="weapon-name">${weapon.name}</div>
                        <div class="weapon-cost">Available: ${count}</div>
                        <div class="weapon-stats">Damage: ${weapon.damage}</div>
                    `;
                    optionDiv.onclick = function() {
                        fireWeaponAtTarget(key);
                    };
                    optionsContainer.appendChild(optionDiv);
                }
            });
            
            if (optionsContainer.children.length === 0) {
                optionsContainer.innerHTML = '<div style="color: #f00; padding: 20px;">No weapons available!</div>';
            }
            
            modal.style.display = 'flex';
        }

        function cancelWeaponSelect() {
            document.getElementById('weaponSelectModal').style.display = 'none';
            selectedTarget = null;
        }

        function fireWeaponAtTarget(weaponType) {
            if (!selectedTarget) return;
            
            const side = gameState[gameState.currentSide];
            const targetX = selectedTarget.x;
            const targetY = selectedTarget.y;
            
            // Launch the selected weapon
            if (weaponType === 'missile' && side.missiles > 0) {
                side.missiles--;
                launchOffensiveMissile(targetX, targetY);
            } else if (weaponType === 'drone' && side.drones > 0) {
                side.drones--;
                launchOffensiveDrone(targetX, targetY);
            } else if (weaponType === 'interceptor' && side.interceptors > 0) {
                side.interceptors--;
                launchOffensiveInterceptor(targetX, targetY);
            } else if (weaponType === 'soldier' && side.soldiers > 0) {
                side.soldiers--;
                launchOffensiveSoldier(targetX, targetY);
            } else if (weaponType === 'tank' && side.tanks > 0) {
                side.tanks--;
                launchOffensiveTank(targetX, targetY);
            } else if (weaponType === 'heavy' && side.heavyWeapons > 0) {
                side.heavyWeapons--;
                launchHeavyBarrage(targetX, targetY);
            } else if (weaponType === 'influencer' && side.influencers > 0) {
                side.influencers--;
                launchInfluencer(targetX, targetY);
            }
            
            updateDisplay();
            cancelWeaponSelect();
            
            showStatus(`üöÄ ${WEAPONS[weaponType].name} launched!`, 1500);
        }

        function launchWeaponAtTarget(targetX, targetY) {
            const side = gameState[gameState.currentSide];
            
            // Check what weapons are available and launch one
            if (side.missiles > 0) {
                side.missiles--;
                launchOffensiveMissile(targetX, targetY);
                updateDisplay();
            } else if (side.drones > 0) {
                side.drones--;
                launchOffensiveDrone(targetX, targetY);
                updateDisplay();
            } else if (side.interceptors > 0) {
                side.interceptors--;
                launchOffensiveInterceptor(targetX, targetY);
                updateDisplay();
            } else if (side.soldiers > 0) {
                side.soldiers--;
                launchOffensiveSoldier(targetX, targetY);
                updateDisplay();
            } else if (side.tanks > 0) {
                side.tanks--;
                launchOffensiveTank(targetX, targetY);
                updateDisplay();
            } else if (side.heavyWeapons > 0) {
                side.heavyWeapons--;
                launchHeavyBarrage(targetX, targetY);
                updateDisplay();
            } else {
                showStatus('‚ùå No weapons left!', 2000);
            }
        }

        function launchOffensiveWeapons() {
            // This function is no longer used - weapons are launched on click
        }

        function launchOffensiveMissile(targetX, targetY) {
            // Create a missile that flies to clicked target
            const startX = gameState.currentSide === 'good' ? 0 : canvas.width;
            
            const missile = {
                x: startX,
                y: 100,
                targetX: targetX,
                targetY: targetY,
                speed: gameState.currentSide === 'good' ? 4 : 2, // Evil side slower
                side: gameState.currentSide,
                type: 'missile',
                exploded: false,
                canBeIntercepted: true,
                
                update: function() {
                    const dx = this.targetX - this.x;
                    const dy = this.targetY - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 10) {
                        // Hit target - create explosion and damage
                        this.exploded = true;
                        explosions.push(new Explosion(this.x, this.y, 40));
                        damageNearbyBuildings(this.x, this.y, 80);
                        gameState.enemiesKilled++;
                        playSound('explosion');
                        updateDisplay();
                    } else {
                        this.x += (dx / dist) * this.speed;
                        this.y += (dy / dist) * this.speed;
                    }
                },
                
                render: function(ctx) {
                    const angle = Math.atan2(this.targetY - this.y, this.targetX - this.x);
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(angle);
                    
                    // Missile body
                    ctx.fillStyle = this.side === 'good' ? '#FFD700' : '#F00';
                    ctx.fillRect(-10, -3, 20, 6);
                    
                    // Fins
                    ctx.fillStyle = this.side === 'good' ? '#0057B7' : '#D52B1E';
                    ctx.beginPath();
                    ctx.moveTo(-10, -3);
                    ctx.lineTo(-15, -6);
                    ctx.lineTo(-10, -6);
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.moveTo(-10, 3);
                    ctx.lineTo(-15, 6);
                    ctx.lineTo(-10, 6);
                    ctx.fill();
                    
                    // Exhaust trail
                    ctx.fillStyle = 'rgba(255, 150, 0, 0.5)';
                    ctx.fillRect(-15, -2, -8, 4);
                    
                    ctx.restore();
                }
            };
            
            // Add to a new offensive weapons array
            if (!window.offensiveWeapons) window.offensiveWeapons = [];
            window.offensiveWeapons.push(missile);
        }

        function launchOffensiveDrone(targetX, targetY) {
            const startX = gameState.currentSide === 'good' ? 50 : canvas.width - 50;
            
            const drone = {
                x: startX,
                y: 80 + Math.random() * 100,
                targetX: targetX,
                targetY: targetY,
                speed: gameState.currentSide === 'good' ? 2.5 : 1.5, // Evil side slower
                side: gameState.currentSide,
                type: 'drone',
                shootCooldown: 0,
                destroyed: false,
                canBeIntercepted: true,
                
                update: function() {
                    const dx = this.targetX - this.x;
                    const dy = this.targetY - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > 20) {
                        this.x += (dx / dist) * this.speed;
                        this.y += (dy / dist) * this.speed;
                    }
                    
                    // Hover and shoot at buildings
                    this.shootCooldown--;
                    if (this.shootCooldown <= 0 && dist < 100) {
                        this.shootAtBuilding();
                        this.shootCooldown = 80;
                    }
                },
                
                shootAtBuilding: function() {
                    // Find nearest enemy building and shoot
                    let nearest = null;
                    let minDist = 300;
                    const targetBuildings = gameState.phase === 'attack' ? enemyBuildings : buildings;
                    
                    targetBuildings.forEach(b => {
                        if (b.health > 0) {
                            const d = Math.sqrt((b.x - this.x) ** 2 + (b.y - this.y) ** 2);
                            if (d < minDist) {
                                minDist = d;
                                nearest = b;
                            }
                        }
                    });
                    
                    if (nearest) {
                        const angle = Math.atan2(nearest.y - this.y, nearest.x - this.x);
                        bullets.push(new Bullet(
                            this.x, this.y,
                            Math.cos(angle) * 6,
                            Math.sin(angle) * 6,
                            this.side
                        ));
                        playSound('shoot');
                        gameState.enemiesKilled += 0.1;
                        updateDisplay();
                    }
                },
                
                render: function(ctx) {
                    ctx.fillStyle = this.side === 'good' ? '#0057B7' : '#D52B1E';
                    ctx.fillRect(this.x - 6, this.y - 2, 12, 4);
                    ctx.fillStyle = '#333';
                    ctx.fillRect(this.x - 2, this.y, 4, 2);
                }
            };
            
            if (!window.offensiveWeapons) window.offensiveWeapons = [];
            window.offensiveWeapons.push(drone);
        }

        function launchOffensiveInterceptor(targetX, targetY) {
            launchOffensiveDrone(targetX, targetY); // Similar but faster
        }

        function launchOffensiveSoldier(targetX, targetY) {
            const startX = gameState.currentSide === 'good' ? 50 : canvas.width - 50;
            
            const soldier = {
                x: startX,
                y: 50,
                targetX: targetX,
                targetY: targetY,
                speed: gameState.currentSide === 'good' ? 0.5 : 0.3, // Evil side slower
                parachute: true,
                side: gameState.currentSide,
                type: 'soldier',
                canBeIntercepted: true,
                
                update: function() {
                    // Parachute down
                    if (this.parachute && this.y < this.targetY - 10) {
                        this.y += (gameState.currentSide === 'good' ? 1 : 0.6); // Evil side falls slower
                        this.x += (this.targetX - this.x) * 0.01;
                    } else {
                        this.parachute = false;
                        // On ground - create small damage
                        if (Math.abs(this.y - this.targetY) < 5) {
                            damageNearbyBuildings(this.x, this.y, 30);
                            gameState.enemiesKilled += 0.5;
                            this.destroyed = true;
                            updateDisplay();
                        }
                    }
                },
                
                render: function(ctx) {
                    if (this.parachute) {
                        // Parachute
                        ctx.fillStyle = this.side === 'good' ? '#FFD700' : '#FFF';
                        ctx.beginPath();
                        ctx.arc(this.x, this.y - 10, 8, 0, Math.PI, true);
                        ctx.fill();
                    }
                    // Soldier
                    ctx.fillStyle = this.side === 'good' ? '#0057B7' : '#D52B1E';
                    ctx.fillRect(this.x - 2, this.y, 4, 8);
                }
            };
            
            if (!window.offensiveWeapons) window.offensiveWeapons = [];
            window.offensiveWeapons.push(soldier);
        }

        function launchOffensiveTank(targetX, targetY) {
            launchOffensiveMissile(targetX, targetY); // Heavy attack
        }

        function launchHeavyBarrage(targetX, targetY) {
            // Launch 5 missiles in quick succession at same target
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    launchOffensiveMissile(targetX, targetY);
                }, i * 200);
            }
        }

        function launchInfluencer(targetX, targetY) {
            // Create an influencer that flies toward enemy defenses to convert them
            const startX = gameState.currentSide === 'good' ? 0 : canvas.width;
            
            const influencer = {
                x: startX,
                y: canvas.height - 100,
                targetX: targetX,
                targetY: targetY,
                radius: 15,
                speed: 3,
                exploded: false,
                destroyed: false,
                canBeIntercepted: true,
                conversionRadius: 100, // Range to convert enemy units
                type: 'influencer',
                side: gameState.currentSide,
                update: function() {
                    if (this.exploded || this.destroyed) return;
                    
                    // Find nearest unconverted enemy ground unit (only soldiers, tanks, heavy weapons)
                    const allEnemyUnits = [
                        ...enemyDefensiveSoldiers,
                        ...enemyDefensiveTanks,
                        ...enemyDefensiveHeavyWeapons
                    ];
                    
                    let nearestUnit = null;
                    let nearestDist = Infinity;
                    
                    allEnemyUnits.forEach(unit => {
                        if (!unit.converted) {
                            const dx = unit.x - this.x;
                            const dy = unit.y - this.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < nearestDist) {
                                nearestDist = dist;
                                nearestUnit = unit;
                            }
                        }
                    });
                    
                    // If found a target, move toward it; otherwise move to initial target
                    if (nearestUnit) {
                        this.targetX = nearestUnit.x;
                        this.targetY = nearestUnit.y;
                    }
                    
                    // Move toward current target
                    const dx = this.targetX - this.x;
                    const dy = this.targetY - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > this.speed) {
                        this.x += (dx / dist) * this.speed;
                        this.y += (dy / dist) * this.speed;
                    } else {
                        this.x = this.targetX;
                        this.y = this.targetY;
                    }
                    
                    // Try to convert nearby enemy defensive units
                    this.tryConvertUnits();
                    
                    // Remove if no more enemy units to convert
                    if (allEnemyUnits.filter(u => !u.converted).length === 0) {
                        this.exploded = true;
                    }
                },
                tryConvertUnits: function() {
                    // Convert enemy ground defensive units within range (only soldiers, tanks, heavy weapons)
                    const unitsToConvert = [
                        ...enemyDefensiveSoldiers,
                        ...enemyDefensiveTanks,
                        ...enemyDefensiveHeavyWeapons
                    ];
                    
                    unitsToConvert.forEach(unit => {
                        const dx = unit.x - this.x;
                        const dy = unit.y - this.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < this.conversionRadius && !unit.converted) {
                            // Mark unit as converted
                            unit.converted = true;
                            unit.convertedBy = this.side;
                            
                            // Remove from enemy defensive arrays and add to player's
                            this.convertUnit(unit);
                            
                            showStatus('üì± Enemy unit converted!', 1000);
                            playSound('collect');
                            createExplosion(unit.x, unit.y, 20, '#FFD700');
                        }
                    });
                },
                convertUnit: function(unit) {
                    // Remove from enemy arrays
                    const removeFromArray = (arr, item) => {
                        const index = arr.indexOf(item);
                        if (index > -1) arr.splice(index, 1);
                    };
                    
                    removeFromArray(enemyDefensiveDrones, unit);
                    removeFromArray(enemyDefensiveInterceptors, unit);
                    removeFromArray(enemyDefensiveSoldiers, unit);
                    removeFromArray(enemyDefensiveTanks, unit);
                    removeFromArray(enemyDefensiveHeavyWeapons, unit);
                    
                    // Change unit's side
                    unit.side = this.side;
                    
                    // Add to player's defensive arrays
                    if (unit.type === 'drone') defensiveDrones.push(unit);
                    else if (unit.type === 'interceptor') defensiveInterceptors.push(unit);
                    else if (unit.type === 'soldier') defensiveSoldiers.push(unit);
                    else if (unit.type === 'tank') defensiveTanks.push(unit);
                    else if (unit.type === 'heavy') defensiveHeavyWeapons.push(unit);
                },
                render: function(ctx) {
                    if (this.exploded || this.destroyed) return;
                    
                    // Draw influencer as a pulsating phone/social media icon
                    const pulse = Math.sin(Date.now() / 200) * 5;
                    
                    // Glow effect
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#4169E1';
                    
                    // Phone/screen
                    ctx.fillStyle = '#4169E1';
                    ctx.fillRect(this.x - 10, this.y - 15 + pulse, 20, 30);
                    
                    // Screen glow
                    ctx.fillStyle = '#87CEEB';
                    ctx.fillRect(this.x - 7, this.y - 12 + pulse, 14, 20);
                    
                    // Signal waves
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.arc(this.x, this.y + pulse, 15 + i * 8, 0, Math.PI * 2);
                        ctx.globalAlpha = 0.3 - i * 0.1;
                        ctx.stroke();
                    }
                    ctx.globalAlpha = 1;
                    ctx.shadowBlur = 0;
                }
            };
            
            if (!window.offensiveWeapons) window.offensiveWeapons = [];
            window.offensiveWeapons.push(influencer);
        }

        function damageNearbyBuildings(x, y, radius) {
            // In attack mode, damage enemy buildings; in defense mode, damage our buildings
            const targetBuildings = gameState.phase === 'attack' ? enemyBuildings : buildings;
            let anyDamaged = false;
            
            targetBuildings.forEach(building => {
                const dist = Math.sqrt((building.x - x) ** 2 + (building.y - y) ** 2);
                if (dist < radius && building.health > 0) {
                    building.takeDamage(1);
                    anyDamaged = true;
                }
            });
            
            if (anyDamaged) {
                updateDisplay();
            }
        }

        function deployDefensiveUnits() {
            // Clear existing defensive units
            defensiveDrones = [];
            defensiveInterceptors = [];
            defensiveSoldiers = [];
            defensiveTanks = [];
            defensiveHeavyWeapons = [];
            
            const side = gameState[gameState.currentSide];
            
            // Deploy drones
            for (let i = 0; i < side.drones; i++) {
                defensiveDrones.push(new DefensiveDrone(gameState.currentSide));
            }
            
            // Deploy interceptors
            for (let i = 0; i < side.interceptors; i++) {
                defensiveInterceptors.push(new DefensiveInterceptor(gameState.currentSide));
            }
            
            // Deploy soldiers
            for (let i = 0; i < side.soldiers; i++) {
                defensiveSoldiers.push(new DefensiveSoldier(gameState.currentSide));
            }
            
            // Deploy tanks
            for (let i = 0; i < side.tanks; i++) {
                defensiveTanks.push(new DefensiveTank(gameState.currentSide));
            }
            
            // Deploy heavy weapons
            for (let i = 0; i < side.heavyWeapons; i++) {
                defensiveHeavyWeapons.push(new DefensiveHeavyWeapon(gameState.currentSide));
            }
        }

        function switchSides() {
            // Switch sides
            gameState.currentSide = gameState.currentSide === 'good' ? 'evil' : 'good';
            gameState.phase = 'defense';
            gameState.enemiesKilled = 0;
            gameState.enemiesNeeded = 8;
            gameState.conversionDialogShown = false; // Reset for new defense phase
            
            if (gameState.currentSide === 'good') {
                gameState.round++;
            }

            // Clear offensive weapons from previous attack
            if (window.offensiveWeapons) {
                window.offensiveWeapons = [];
            }

            // Switch back to own city view
            viewMode = 'own';
            
            // Update button to show "ATTACK MODE" (since we're now in defense)
            document.getElementById('viewModeButton').textContent = '‚öîÔ∏è ATTACK MODE';
            document.getElementById('viewModeButton').style.background = 'linear-gradient(180deg, #ff4444, #cc0000)';

            // Reset tank
            tank = new Tank(gameState.currentSide);
            
            // Deploy defensive units from arsenal
            deployDefensiveUnits();
            
            showStatus(`üîÑ ${gameState.currentSide.toUpperCase()} DEFENSE PHASE!`, 3000);
            updateDisplay();

            // Start spawning enemies for defense - AGGRESSIVE
            setTimeout(() => {
                enemySpawnInterval = setInterval(() => {
                    if (enemies.length < 8 && gameState.enemiesKilled < gameState.enemiesNeeded) { // Increased to 8
                        spawnEnemy();
                    }
                }, 800); // Reduced to 800ms for aggressive attacks
            }, 500); // Start sooner
        }

        function checkPhaseComplete() {
            if (gameState.enemiesKilled >= gameState.enemiesNeeded && enemies.length === 0) {
                clearInterval(enemySpawnInterval);
                
                if (gameState.phase === 'defense') {
                    // Defense complete - allow conversion (only show dialog once)
                    const side = gameState[gameState.currentSide];
                    showStatus(`‚úÖ DEFENSE COMPLETE! You earned $${side.resources}! Buy weapons!`, 3000);
                    if (!gameState.conversionDialogShown) {
                        gameState.conversionDialogShown = true;
                        setTimeout(() => {
                            showConversionDialog();
                        }, 1000);
                    }
                } else {
                    // Attack complete
                    showStatus(`‚úÖ ATTACK COMPLETE!`, 3000);
                }
            }
        }

        // Sound System
        let audioContext = null;
        let audioInitialized = false;

        function initializeAudio() {
            if (!audioInitialized && gameState.soundEnabled) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Resume context if it's suspended (required by some browsers)
                    if (audioContext.state === 'suspended') {
                        audioContext.resume();
                    }
                    
                    audioInitialized = true;
                } catch (error) {
                    console.warn('Audio initialization failed:', error);
                    gameState.soundEnabled = false;
                }
            }
        }

        function playSound(type) {
            if (!gameState.soundEnabled) return;
            
            if (!audioInitialized) {
                initializeAudio();
                if (!audioInitialized) return;
            }
            
            // Resume context if suspended
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume().catch(err => console.warn('Audio resume failed:', err));
            }

            try {
                if (!audioContext || audioContext.state !== 'running') {
                    return; // Don't play if audio isn't ready
                }
                
                switch(type) {
                    case 'shoot':
                        createBeep(audioContext, 800, 0.1, 0.2);
                        break;
                    case 'explosion':
                        createBeep(audioContext, 200, 0.3, 0.4);
                        setTimeout(() => createBeep(audioContext, 100, 0.2, 0.3), 100);
                        break;
                    case 'collect':
                        createBeep(audioContext, 1200, 0.1, 0.3);
                        setTimeout(() => createBeep(audioContext, 1600, 0.1, 0.2), 100);
                        break;
                }
            } catch (error) {
                console.warn('Sound playback failed:', error);
            }
        }

        function createBeep(audioContext, frequency, duration, volume) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            oscillator.type = 'square';
            
            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        function toggleSound() {
            gameState.soundEnabled = !gameState.soundEnabled;
            document.getElementById('soundToggle').textContent = gameState.soundEnabled ? 'üîä' : 'üîá';
        }

        // Game Initialization
        function initializeGame() {
            // Create terrain first
            terrain = new Terrain();
            
            // Create ground layer (roads, railways, parks)
            groundLayer = new GroundLayer(terrain);
            
            tank = new Tank(gameState.currentSide);
            bullets = [];
            enemies = [];
            explosions = [];
            particles = [];
            stars = [];
            buildings = [];

            // Create stars
            for (let i = 0; i < 100; i++) {
                stars.push(new Star());
            }

            // Create diverse buildings layout
            // Using percentages of canvas width for responsive positioning
            // Left edge: forests, farms, power infrastructure (0-25%)
            // Center: main city buildings (25%-75%, which is center 50%)
            // Right edge: forests, farms, power infrastructure (75%-100%)
            const w = canvas.width;
            const buildingPlan = [
                // FAR LEFT - Forest and farms (0-12.5%)
                { type: 'tree', x: w * 0.015 },
                { type: 'tree', x: w * 0.028 },
                { type: 'bush', x: w * 0.041 },
                { type: 'tree', x: w * 0.050 },
                { type: 'bigfarm', x: w * 0.063 },
                { type: 'tree', x: w * 0.088 },
                { type: 'bush', x: w * 0.100 },
                { type: 'farm', x: w * 0.110 },
                { type: 'tree', x: w * 0.122 },
                
                // LEFT - Farms and power infrastructure (12.5-25%)
                { type: 'farm', x: w * 0.131 },
                { type: 'tree', x: w * 0.150 },
                { type: 'powerline', x: w * 0.163 },
                { type: 'bigfarm', x: w * 0.175 },
                { type: 'bush', x: w * 0.197 },
                { type: 'farm', x: w * 0.206 },
                { type: 'tree', x: w * 0.222 },
                { type: 'powerplant', x: w * 0.234 },
                
                // CENTER CITY - Main buildings (25-75%, center 50% of screen)
                // Left city edge - transition
                { type: 'house', x: w * 0.256 },
                { type: 'tree', x: w * 0.272 },
                { type: 'house', x: w * 0.281 },
                { type: 'shop', x: w * 0.297 },
                { type: 'subway', x: w * 0.313 },
                { type: 'house', x: w * 0.328 },
                
                // Left downtown - office buildings
                { type: 'office', x: w * 0.347 },
                { type: 'shop', x: w * 0.369 },
                { type: 'office', x: w * 0.384 },
                { type: 'pool', x: w * 0.406 },
                
                // City center - tall buildings clustered
                { type: 'hospital', x: w * 0.431 },
                { type: 'office', x: w * 0.456 },
                { type: 'government', x: w * 0.481 },
                { type: 'theatre', x: w * 0.506 },
                { type: 'office', x: w * 0.531 },
                { type: 'school', x: w * 0.556 },
                { type: 'subway', x: w * 0.581 },
                
                // Right downtown - mixed buildings
                { type: 'office', x: w * 0.606 },
                { type: 'shop', x: w * 0.628 },
                { type: 'school', x: w * 0.650 },
                
                // Industrial zone - factories
                { type: 'factory', x: w * 0.672 },
                { type: 'factory', x: w * 0.697 },
                { type: 'factory', x: w * 0.722 },
                
                // Right city edge - transition
                { type: 'house', x: w * 0.741 },
                
                // RIGHT - Power infrastructure and farms (75-87.5%)
                { type: 'powerline', x: w * 0.756 },
                { type: 'farm', x: w * 0.772 },
                { type: 'tree', x: w * 0.794 },
                { type: 'bigfarm', x: w * 0.806 },
                { type: 'bush', x: w * 0.831 },
                { type: 'farm', x: w * 0.844 },
                { type: 'powerline', x: w * 0.863 },
                
                // FAR RIGHT - Forest (87.5-100%)
                { type: 'tree', x: w * 0.881 },
                { type: 'bush', x: w * 0.897 },
                { type: 'farm', x: w * 0.909 },
                { type: 'tree', x: w * 0.928 },
                { type: 'tree', x: w * 0.944 },
                { type: 'bush', x: w * 0.959 },
                { type: 'tree', x: w * 0.972 },
                { type: 'tree', x: w * 0.988 }
            ];

            // Create buildings at terrain height
            buildingPlan.forEach(plan => {
                const terrainY = terrain.getHeightAt(plan.x);
                buildings.push(new Building(plan.x, plan.type, terrainY));
            });

            // Create people walking around
            people = [];
            
            // People at buildings (houses, schools, shops, etc.)
            buildings.forEach((building, index) => {
                if (building.health > 0) {
                    let numPeople = 0;
                    
                    // Theatre - LARGE GROUP (15-20 people)
                    if (building.type === 'theatre') {
                        numPeople = 15 + Math.floor(Math.random() * 6);
                        for (let i = 0; i < numPeople; i++) {
                            const personX = building.x + Math.random() * 40 - 20;
                            const personY = building.y + building.height - 8 + Math.random() * 10 - 5;
                            people.push(new Person(personX, personY, 'building'));
                        }
                    }
                    // City center buildings (government, office, school, hospital, subway) - MORE PEOPLE
                    else if (['government', 'office', 'school', 'hospital', 'subway'].includes(building.type)) {
                        // City center is around x = 0.43-0.58 (based on buildingPlan)
                        const isCityCenter = building.x > canvas.width * 0.40 && building.x < canvas.width * 0.60;
                        
                        if (isCityCenter) {
                            // 8-12 people at city center buildings
                            numPeople = 8 + Math.floor(Math.random() * 5);
                        } else {
                            // 3-5 people at other similar buildings
                            numPeople = 3 + Math.floor(Math.random() * 3);
                        }
                        
                        for (let i = 0; i < numPeople; i++) {
                            const personX = building.x + Math.random() * 30 - 15;
                            const personY = building.y + building.height - 8 + Math.random() * 8 - 4;
                            people.push(new Person(personX, personY, 'building'));
                        }
                    }
                    // Regular buildings - fewer people
                    else if (['house', 'shop'].includes(building.type)) {
                        numPeople = 1 + Math.floor(Math.random() * 2);
                        for (let i = 0; i < numPeople; i++) {
                            const personX = building.x + Math.random() * 20 - 10;
                            const personY = building.y + building.height - 8;
                            people.push(new Person(personX, personY, 'building'));
                        }
                    }
                }
            });
            
            // Add extra crowd in city center (around 45-55% of screen width)
            const cityCenter = canvas.width * 0.50;
            const cityCenterRadius = canvas.width * 0.08;
            for (let i = 0; i < 20; i++) {
                const personX = cityCenter + (Math.random() - 0.5) * cityCenterRadius * 2;
                const personY = terrain.getHeightAt(personX) - 15 - Math.random() * 20;
                people.push(new Person(personX, personY, 'walking'));
            }
            
            // People walking around randomly - reduced from 25 to 15
            for (let i = 0; i < 15; i++) {
                const personX = Math.random() * canvas.width;
                const personY = terrain.getHeightAt(personX) - 20 - Math.random() * 30;
                people.push(new Person(personX, personY, 'walking'));
            }

            // Create cars on roads
            cars = [];
            if (groundLayer && groundLayer.roads) {
                groundLayer.roads.forEach(road => {
                    // Add 3-5 cars per road
                    const numCars = 3 + Math.floor(Math.random() * 3);
                    for (let i = 0; i < numCars; i++) {
                        const carX = Math.random() * canvas.width;
                        const carY = road.y + road.height / 2 - 4; // Center on road
                        const direction = Math.random() > 0.5 ? 1 : -1;
                        cars.push(new Car(carX, carY, road.y, direction));
                    }
                });
            }

            // Create train on railway
            train = null;
            if (groundLayer && groundLayer.railways && groundLayer.railways.length > 0) {
                const railway = groundLayer.railways[0];
                const trainY = railway.y + railway.height / 2 - 7; // Center on railway
                train = new Train(-120, trainY); // Start off screen
            }

            // Create metro trains in subway system
            metros = [];
            if (groundLayer && groundLayer.subwaySystem) {
                const tunnelY = groundLayer.subwaySystem.tunnelY + groundLayer.subwaySystem.tunnelHeight / 2 - 4;
                // Create 2 metros going in opposite directions
                metros.push(new Metro(canvas.width * 0.15, tunnelY));
                metros.push(new Metro(canvas.width * 0.75, tunnelY));
                metros[1].direction = -1; // Second metro goes left
            }

            updateDisplay();
            showStatus(`üõ°Ô∏è DEFENSE PHASE: Enemy is attacking YOUR city! Destroy ${gameState.enemiesNeeded} enemy weapons! ($200 each)`, 4000);

            // Start spawning enemies - AGGRESSIVE
            enemySpawnInterval = setInterval(() => {
                if (enemies.length < 8 && gameState.enemiesKilled < gameState.enemiesNeeded) { // Increased to 8
                    spawnEnemy();
                }
            }, 800); // Reduced to 800ms for relentless assault
        }

        let enemySpawnInterval = null;

        // Enemy AI Strategic Weapon Buying
        function takeLoan() {
            // Player takes a loan from the bank
            const loanAmount = 1000;
            const interestRate = 0.10;
            const debtAmount = Math.floor(loanAmount * (1 + interestRate)); // $1100
            
            if (bankMoney < loanAmount) {
                showStatus('Bank has insufficient funds!', 2000);
                return;
            }
            
            if (gameState[gameState.currentSide].debt >= 10000) {
                showStatus('Maximum debt limit reached!', 2000);
                return;
            }
            
            // Transfer money from bank to player and add debt
            bankMoney -= loanAmount;
            gameState[gameState.currentSide].resources += loanAmount;
            gameState[gameState.currentSide].debt += debtAmount;
            
            showStatus(`Loan received: $${loanAmount} (debt +$${debtAmount})`, 3000);
            updateDisplay();
        }
        
        function enemyTakeLoan() {
            // Enemy takes a loan from the bank
            const loanAmount = 1000;
            const interestRate = 0.10;
            const debtAmount = Math.floor(loanAmount * (1 + interestRate)); // $1100
            
            if (bankMoney < loanAmount) {
                return; // Silently fail for enemy
            }
            
            if (enemyWeapons.debt >= 10000) {
                return; // Maximum debt limit
            }
            
            // Transfer money from bank to enemy and add debt
            bankMoney -= loanAmount;
            enemyWeapons.resources += loanAmount;
            enemyWeapons.debt += debtAmount;
            
            console.log(`Enemy took loan: $${loanAmount} (debt now $${enemyWeapons.debt})`);
        }

        // Weapons Factory Manufacturing System
        function manufactureWeapon(weaponType) {
            const side = gameState[gameState.currentSide];
            
            const manufactureCosts = {
                missile: { cost: 400, time: 5000, name: 'üöÄ Missile' },
                drone: { cost: 250, time: 3000, name: 'üöÅ Drone' }
            };
            
            if (!manufactureCosts[weaponType]) {
                showStatus('Invalid weapon type!', 2000);
                return;
            }
            
            const specs = manufactureCosts[weaponType];
            
            // Check if factory is already producing
            if (side.factoryQueue.length > 0) {
                showStatus('Factory is busy! Wait for current production to finish.', 2000);
                return;
            }
            
            // Check if player has enough resources
            if (side.resources < specs.cost) {
                showStatus(`Not enough resources! Need $${specs.cost}`, 2000);
                return;
            }
            
            // Deduct cost and start production
            side.resources -= specs.cost;
            bankMoney += specs.cost;
            
            side.factoryQueue.push({
                type: weaponType,
                name: specs.name,
                timeLeft: specs.time,
                totalTime: specs.time
            });
            
            showStatus(`Factory started producing ${specs.name}`, 2000);
            updateDisplay();
        }
        
        function enemyManufactureWeapon() {
            // Enemy AI decides to manufacture weapons
            const manufactureCosts = {
                missile: { cost: 400, time: 5000 },
                drone: { cost: 250, time: 3000 }
            };
            
            // Check if factory is already producing
            if (enemyWeapons.factoryQueue.length > 0) {
                return; // Busy
            }
            
            // Randomly decide what to manufacture (favor missiles in attack phase)
            const weaponType = Math.random() < 0.6 ? 'missile' : 'drone';
            const specs = manufactureCosts[weaponType];
            
            // Check if enemy has enough resources
            if (enemyWeapons.resources < specs.cost) {
                return; // Can't afford
            }
            
            // Deduct cost and start production
            enemyWeapons.resources -= specs.cost;
            bankMoney += specs.cost;
            
            enemyWeapons.factoryQueue.push({
                type: weaponType,
                timeLeft: specs.time,
                totalTime: specs.time
            });
            
            console.log(`Enemy factory producing ${weaponType}`);
        }
        
        function updateFactoryProduction(deltaTime) {
            // Update good side factory
            if (gameState.good.factoryQueue.length > 0) {
                const item = gameState.good.factoryQueue[0];
                item.timeLeft -= deltaTime;
                
                if (item.timeLeft <= 0) {
                    // Production complete!
                    if (item.type === 'missile') {
                        gameState.good.missiles++;
                    } else if (item.type === 'drone') {
                        gameState.good.drones++;
                    }
                    gameState.good.factoryQueue.shift();
                    if (gameState.currentSide === 'good') {
                        showStatus(`${item.name} manufacturing complete!`, 2000);
                    }
                    updateDisplay();
                }
            }
            
            // Update evil side factory
            if (gameState.evil.factoryQueue.length > 0) {
                const item = gameState.evil.factoryQueue[0];
                item.timeLeft -= deltaTime;
                
                if (item.timeLeft <= 0) {
                    // Production complete!
                    if (item.type === 'missile') {
                        gameState.evil.missiles++;
                    } else if (item.type === 'drone') {
                        gameState.evil.drones++;
                    }
                    gameState.evil.factoryQueue.shift();
                    if (gameState.currentSide === 'evil') {
                        showStatus(`${item.name} manufacturing complete!`, 2000);
                    }
                    updateDisplay();
                }
            }
            
            // Update enemy factory
            if (enemyWeapons.factoryQueue.length > 0) {
                const item = enemyWeapons.factoryQueue[0];
                item.timeLeft -= deltaTime;
                
                if (item.timeLeft <= 0) {
                    // Production complete!
                    if (item.type === 'missile') {
                        enemyWeapons.missiles++;
                    } else if (item.type === 'drone') {
                        enemyWeapons.drones++;
                    }
                    enemyWeapons.factoryQueue.shift();
                    console.log(`Enemy ${item.type} manufacturing complete!`);
                }
            }
        }

        function enemyStrategicBuy() {
            // Enemy buys weapons strategically when they have money
            // Calculate what to buy based on game phase and available resources
            
            // Consider taking a loan if resources are low and debt is manageable
            if (enemyWeapons.resources < 500 && enemyWeapons.debt < 5000 && bankMoney >= 1000) {
                enemyTakeLoan();
            }
            
            // Consider manufacturing weapons (20% chance per cycle if factory idle)
            if (Math.random() < 0.2 && enemyWeapons.factoryQueue.length === 0) {
                enemyManufactureWeapon();
            }
            
            let weaponsBought = 0;
            const maxBuys = Math.floor(Math.random() * 3) + 2; // Try to buy 2-4 weapons per cycle
            
            for (let i = 0; i < maxBuys; i++) {
                let purchased = false;
                
                if (gameState.phase === 'defense') {
                    // In defense mode, buy defensive weapons if affordable
                    const randomChoice = Math.random();
                    if (randomChoice < 0.3 && enemyWeapons.resources >= 300) {
                        enemyWeapons.drones++;
                        enemyWeapons.resources -= 300;
                        bankMoney += 300;
                        purchased = true;
                        console.log('Enemy bought defensive drone');
                    } else if (randomChoice < 0.5 && enemyWeapons.resources >= 400) {
                        enemyWeapons.interceptors++;
                        enemyWeapons.resources -= 400;
                        bankMoney += 400;
                        purchased = true;
                        console.log('Enemy bought defensive interceptor');
                    } else if (randomChoice < 0.7 && enemyWeapons.resources >= 600) {
                        enemyWeapons.soldiers++;
                        enemyWeapons.resources -= 600;
                        bankMoney += 600;
                        purchased = true;
                        console.log('Enemy bought defensive soldier');
                    } else if (randomChoice < 0.85 && enemyWeapons.resources >= 1000) {
                        enemyWeapons.tanks++;
                        enemyWeapons.resources -= 1000;
                        bankMoney += 1000;
                        purchased = true;
                        console.log('Enemy bought defensive tank');
                    } else if (randomChoice < 1.0 && enemyWeapons.resources >= 1500) {
                        enemyWeapons.heavyWeapons++;
                        enemyWeapons.resources -= 1500;
                        bankMoney += 1500;
                        purchased = true;
                        console.log('Enemy bought defensive heavy weapon');
                    }
                } else {
                    // In attack mode or planning, buy offensive weapons if affordable
                    const randomChoice = Math.random();
                    if (randomChoice < 0.25 && enemyWeapons.resources >= 500) {
                        enemyWeapons.missiles++;
                        enemyWeapons.resources -= 500;
                        bankMoney += 500;
                        purchased = true;
                        console.log('Enemy bought offensive missile');
                    } else if (randomChoice < 0.45 && enemyWeapons.resources >= 300) {
                        enemyWeapons.drones++;
                        enemyWeapons.resources -= 300;
                        bankMoney += 300;
                        purchased = true;
                        console.log('Enemy bought offensive drone');
                    } else if (randomChoice < 0.65 && enemyWeapons.resources >= 600) {
                        enemyWeapons.soldiers++;
                        enemyWeapons.resources -= 600;
                        bankMoney += 600;
                        purchased = true;
                        console.log('Enemy bought offensive soldier');
                    } else if (randomChoice < 0.8 && enemyWeapons.resources >= 1000) {
                        enemyWeapons.tanks++;
                        enemyWeapons.resources -= 1000;
                        bankMoney += 1000;
                        purchased = true;
                        console.log('Enemy bought offensive tank');
                    } else if (randomChoice < 0.9 && enemyWeapons.resources >= 1500) {
                        enemyWeapons.heavyWeapons++;
                        enemyWeapons.resources -= 1500;
                        bankMoney += 1500;
                        purchased = true;
                        console.log('Enemy bought offensive heavy weapon');
                    } else if (randomChoice < 1.0 && enemyWeapons.resources >= 800) {
                        enemyWeapons.influencers++;
                        enemyWeapons.resources -= 800;
                        bankMoney += 800;
                        purchased = true;
                        console.log('Enemy bought influencer');
                    }
                }
                
                if (purchased) {
                    weaponsBought++;
                } else {
                    // Can't afford any more weapons, stop trying
                    break;
                }
            }
            
            updateDisplay();
        }

        // Input Handling
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            tank.aimAt(mouseX, mouseY);
        });

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            if (gameState.phase === 'defense' && viewMode === 'own') {
                // Defense mode viewing own city - shoot with tank
                tank.shoot();
            } else if (gameState.phase === 'attack' && viewMode === 'enemy') {
                // Attack mode viewing enemy city - click building to select weapon
                let clickedBuilding = null;
                
                for (let building of enemyBuildings) {
                    const inX = mouseX >= building.x && mouseX <= building.x + building.width;
                    const inY = mouseY >= building.y - building.height && mouseY <= building.y;
                    
                    if (inX && inY && building.health > 0) {
                        clickedBuilding = building;
                        break;
                    }
                }
                
                if (clickedBuilding) {
                    showWeaponSelectDialog(clickedBuilding);
                } else {
                    showStatus('üéØ Click on a building to target it!', 1500);
                }
            }
        });

        // Game Loop
        function gameLoop() {
            // Clear canvas with evil sky for enemy city
            if (viewMode === 'enemy') {
                // Evil red-tinted dark sky
                const evilGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                evilGradient.addColorStop(0, '#0a0000'); // Very dark red
                evilGradient.addColorStop(0.3, '#1a0505'); // Dark red
                evilGradient.addColorStop(0.6, '#150000'); // Darker
                evilGradient.addColorStop(1, '#000000'); // Black
                ctx.fillStyle = evilGradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Add ominous red glow at horizon
                const glowGradient = ctx.createRadialGradient(canvas.width/2, canvas.height - 200, 0, 
                                                               canvas.width/2, canvas.height - 200, canvas.width/2);
                glowGradient.addColorStop(0, 'rgba(139, 0, 0, 0.2)');
                glowGradient.addColorStop(0.5, 'rgba(80, 0, 0, 0.1)');
                glowGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = glowGradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            } else {
                // Normal black sky
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Update and render stars (make them red-tinted for evil city)
            stars.forEach(star => {
                star.update();
                if (viewMode === 'enemy') {
                    // Red-tinted stars for evil atmosphere
                    ctx.fillStyle = `rgba(255, 100, 100, ${star.brightness * 0.6})`;
                    ctx.fillRect(star.x, star.y, star.size, star.size);
                } else {
                    star.render(ctx);
                }
            });

            // Render based on viewMode (not phase)
            if (viewMode === 'enemy') {
                // Render enemy city
                if (enemyTerrain) {
                    enemyTerrain.render(ctx);
                }

                if (enemyGroundLayer) {
                    enemyGroundLayer.render(ctx);
                }

                // Update and render enemy cars on roads
                enemyCars.forEach(car => {
                    car.update();
                    car.render(ctx);
                });

                // Update and render enemy train on railway
                if (enemyTrain) {
                    enemyTrain.update();
                    enemyTrain.render(ctx);
                }

                // Update and render enemy metro trains in subway
                enemyMetros.forEach(metro => {
                    metro.update(enemyGroundLayer);
                    metro.render(ctx, enemyGroundLayer);
                });

                enemyBuildings.forEach(building => {
                    building.render(ctx);
                    
                    // Add evil dark overlay to buildings
                    if (building.health > 0 && !building.destroyed) {
                        const yPos = building.isUnderground ? canvas.height - 80 : building.y;
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.4)'; // Dark overlay
                        ctx.fillRect(building.x, yPos - building.height, building.width, building.height);
                        
                        // Add subtle red glow outline
                        ctx.strokeStyle = 'rgba(139, 0, 0, 0.3)';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(building.x, yPos - building.height, building.width, building.height);
                    }
                });

                // Update and render enemy people
                enemyPeople = enemyPeople.filter(person => {
                    person.update();
                    person.render(ctx);
                    return person.x > -50 && person.x < canvas.width + 50 && 
                           person.y > -50 && person.y < canvas.height + 50;
                });
                
                // Update and render AI-controlled enemy tank (during attack phase)
                if (gameState.phase === 'attack' && enemyTank) {
                    enemyTank.update();
                    enemyTank.render(ctx);
                }
                
                // Update and render enemy bullets
                enemyBullets = enemyBullets.filter(bullet => {
                    // Store trail
                    bullet.trail.push({ x: bullet.x, y: bullet.y });
                    if (bullet.trail.length > 5) bullet.trail.shift();
                    
                    bullet.x += bullet.vx;
                    bullet.y += bullet.vy;
                    
                    // Check collision with offensive weapons
                    if (window.offensiveWeapons) {
                        window.offensiveWeapons.forEach(weapon => {
                            if (!weapon.exploded && !weapon.destroyed && weapon.canBeIntercepted) {
                                const dist = Math.sqrt((bullet.x - weapon.x) ** 2 + (bullet.y - weapon.y) ** 2);
                                if (dist < weapon.radius + bullet.radius) {
                                    weapon.exploded = true;
                                    weapon.destroyed = true;
                                    bullet.dead = true;
                                    createExplosion(weapon.x, weapon.y, 25);
                                    playSound('explosion');
                                    showStatus('‚ùå Weapon intercepted by enemy tank!', 1500);
                                }
                            }
                        });
                    }
                    
                    // Remove if off screen
                    if (bullet.y < 0 || bullet.y > canvas.height || bullet.x < 0 || bullet.x > canvas.width) {
                        bullet.dead = true;
                    }
                    
                    // Render bullet
                    if (!bullet.dead) {
                        // Trail
                        ctx.strokeStyle = 'rgba(255, 100, 100, 0.3)';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        bullet.trail.forEach((pos, i) => {
                            if (i === 0) ctx.moveTo(pos.x, pos.y);
                            else ctx.lineTo(pos.x, pos.y);
                        });
                        ctx.stroke();
                        
                        // Bullet
                        ctx.fillStyle = '#FF0000';
                        ctx.shadowColor = '#FF0000';
                        ctx.shadowBlur = 8;
                        ctx.beginPath();
                        ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    }
                    
                    return !bullet.dead;
                });
                
                // Update and render enemy defensive units (during attack phase)
                if (gameState.phase === 'attack') {
                    enemyDefensiveDrones.forEach(drone => {
                        drone.update();
                        drone.render(ctx);
                    });
                    
                    enemyDefensiveInterceptors.forEach(interceptor => {
                        interceptor.update();
                        interceptor.render(ctx);
                    });
                    
                    enemyDefensiveSoldiers.forEach(soldier => {
                        soldier.update();
                        soldier.render(ctx);
                    });
                    
                    enemyDefensiveTanks.forEach(tank => {
                        tank.update();
                        tank.render(ctx);
                    });
                    
                    enemyDefensiveHeavyWeapons.forEach(heavy => {
                        heavy.update();
                        heavy.render(ctx);
                    });
                }
                
                // Highlight selected building in attack mode
                if (gameState.phase === 'attack' && selectedTarget && selectedTarget.building) {
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(
                        selectedTarget.building.x - 2,
                        selectedTarget.building.y - selectedTarget.building.height - 2,
                        selectedTarget.building.width + 4,
                        selectedTarget.building.height + 4
                    );
                }
            }
            else {
                // Render own city
                if (terrain) {
                    terrain.render(ctx);
                }

                // Draw ground layer (roads, railways, parks) - below buildings
                if (groundLayer) {
                    groundLayer.render(ctx);
                }

                // Update and render cars on roads
                cars.forEach(car => {
                    car.update();
                    car.render(ctx);
                });

                // Update and render train on railway
                if (train) {
                    train.update();
                    train.render(ctx);
                }

                // Update and render metro trains in subway
                metros.forEach(metro => {
                    metro.update(groundLayer);
                    metro.render(ctx, groundLayer);
                });

                // Update and render buildings
                buildings.forEach(building => building.render(ctx));

                // Update and render people (only in defense mode)
                people = people.filter(person => {
                    person.update();
                    person.render(ctx);
                    return person.x > -50 && person.x < canvas.width + 50 && 
                           person.y > -50 && person.y < canvas.height + 50;
                });
            }

            // Update factory production (16ms ~= 60fps)
            updateFactoryProduction(16);

            // Update and render game objects
            // Only show tank in defense phase
            if (gameState.phase === 'defense') {
                tank.update();
                tank.render(ctx);
            }

            // Update and render defensive units (only during defense phase)
            if (gameState.phase === 'defense') {
                defensiveDrones.forEach(drone => {
                    drone.update();
                    drone.render(ctx);
                });
                
                defensiveInterceptors.forEach(interceptor => {
                    interceptor.update();
                    interceptor.render(ctx);
                });
                
                defensiveSoldiers.forEach(soldier => {
                    soldier.update();
                    soldier.render(ctx);
                });
                
                defensiveTanks.forEach(defTank => {
                    defTank.update();
                    defTank.render(ctx);
                });
                
                defensiveHeavyWeapons.forEach(heavy => {
                    heavy.update();
                    heavy.render(ctx);
                });
            }

            // Update and render offensive weapons (both attack phase and enemy attacks during defense)
            if (window.offensiveWeapons) {
                window.offensiveWeapons = window.offensiveWeapons.filter(weapon => {
                    weapon.update();
                    weapon.render(ctx);
                    return !weapon.exploded && !weapon.destroyed;
                });
            }

            bullets = bullets.filter(bullet => {
                bullet.update();
                bullet.render(ctx);
                return !bullet.dead;
            });

            enemies = enemies.filter(enemy => {
                enemy.update();
                enemy.render(ctx);
                return !enemy.dead;
            });

            explosions = explosions.filter(explosion => {
                explosion.update();
                explosion.render(ctx);
                return !explosion.done;
            });

            particles = particles.filter(particle => {
                particle.update();
                particle.render(ctx);
                return particle.life > 0;
            });

            // Update and render money rewards
            updateMoneyRewards();

            // Check phase completion
            checkPhaseComplete();

            animationId = requestAnimationFrame(gameLoop);
        }

        // Update population metrics periodically
        function updatePopulationMetrics() {
            // Update player side
            const playerSide = gameState[gameState.currentSide];
            
            // Food consumption (civilians consume food)
            const foodConsumption = Math.floor(playerSide.civilians / 50); // 1 food per 50 civilians
            playerSide.food = Math.max(0, playerSide.food - foodConsumption);
            
            // Hungry people increase if food is low
            if (playerSide.food < 1000) {
                playerSide.hungry = Math.min(playerSide.civilians, playerSide.hungry + Math.floor(playerSide.civilians * 0.01));
            } else {
                playerSide.hungry = Math.max(0, playerSide.hungry - 5);
            }
            
            // Health recovery for wounded
            if (playerSide.wounded > 0) {
                const recovered = Math.floor(playerSide.wounded * 0.05); // 5% recovery rate
                playerSide.wounded = Math.max(0, playerSide.wounded - recovered);
                playerSide.health = Math.min(100, playerSide.health + 1);
            }
            
            // Illness increases if health is low or people are hungry
            if (playerSide.health < 50 || playerSide.hungry > 100) {
                playerSide.ill = Math.min(playerSide.civilians, playerSide.ill + Math.floor(Math.random() * 5));
            } else if (playerSide.ill > 0) {
                playerSide.ill = Math.max(0, playerSide.ill - 2);
            }
            
            // Update enemy side
            const enemyFoodConsumption = Math.floor(enemyWeapons.civilians / 50);
            enemyWeapons.food = Math.max(0, enemyWeapons.food - enemyFoodConsumption);
            
            if (enemyWeapons.food < 1000) {
                enemyWeapons.hungry = Math.min(enemyWeapons.civilians, enemyWeapons.hungry + Math.floor(enemyWeapons.civilians * 0.01));
            } else {
                enemyWeapons.hungry = Math.max(0, enemyWeapons.hungry - 5);
            }
            
            if (enemyWeapons.wounded > 0) {
                const recovered = Math.floor(enemyWeapons.wounded * 0.05);
                enemyWeapons.wounded = Math.max(0, enemyWeapons.wounded - recovered);
                enemyWeapons.health = Math.min(100, enemyWeapons.health + 1);
            }
            
            if (enemyWeapons.health < 50 || enemyWeapons.hungry > 100) {
                enemyWeapons.ill = Math.min(enemyWeapons.civilians, enemyWeapons.ill + Math.floor(Math.random() * 5));
            } else if (enemyWeapons.ill > 0) {
                enemyWeapons.ill = Math.max(0, enemyWeapons.ill - 2);
            }
            
            updateDisplay();
        }

        // Initialize
        window.onload = function() {
            initializeCanvas();
            initializeGame();
            setupModalListeners();
            gameLoop();
            
            // Update population metrics every 3 seconds
            setInterval(updatePopulationMetrics, 3000);
            
            // Enemy strategic weapon buying every 2 seconds (aggressive)
            setInterval(enemyStrategicBuy, 2000);

            // Enable audio on first user interaction
            const enableAudio = function() {
                if (!audioInitialized) {
                    initializeAudio();
                }
                document.removeEventListener('click', enableAudio);
                document.removeEventListener('keydown', enableAudio);
            };
            
            document.addEventListener('click', enableAudio, { once: true });
            document.addEventListener('keydown', enableAudio, { once: true });
        };
    </script>
</body>
</html>
